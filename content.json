{"meta":{"title":"Seo's Blog","subtitle":"Programming & Study","description":null,"author":"Seo Young Ki","url":"http://dudri63.github.io"},"pages":[{"title":"Tags","date":"2019-01-15T11:23:13.000Z","updated":"2019-01-15T11:38:54.543Z","comments":true,"path":"Tags/index.html","permalink":"http://dudri63.github.io/Tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2019-01-15T12:11:54.000Z","updated":"2019-01-16T10:55:20.481Z","comments":true,"path":"Categories/index.html","permalink":"http://dudri63.github.io/Categories/index.html","excerpt":"","text":""}],"posts":[{"title":"[딥러닝/머신러닝] TensorFlow","slug":"adl2","date":"2019-01-30T13:14:44.000Z","updated":"2019-01-31T08:51:49.021Z","comments":true,"path":"2019/01/30/adl2/","link":"","permalink":"http://dudri63.github.io/2019/01/30/adl2/","excerpt":"","text":"1. TensorFlow2. TensorFlow 예제3. TensorFlow 구조4. placeholder5. Tesnor, Ranks, Shapes, Types 1. TensorFlow 텐서플로우(TensorFlow)는 구글에서 만든 오픈 소스 라이브러리이다.텐서플로우는 데이터 플로우 그래프(Data Flow Graph)를 이용하여 수 계산(Numerical Computation)을 할 수 있다는 특징이 있다.또한, ‘파이썬(Python)’ 언어를 이용하여 텐서플로우를 활용할 수 있다. Data Flow Graph란 다음 그림과 같은 것이다. ‘노드’와 노드간을 연결하는 ‘엣지’로 구성되어 있는 것을 그래프라고 한다.Data Flow Graph에서 노드는 하나의 operation이다.엣지는 데이터(tensor)이다.데이터들은 연속적으로 연산하여 결과를 추출하는 것이 Data Flow Graph의 방식이다. 리눅스 환경에서 텐서플로우를 설치한 후, 파이썬에서 텐서플로우 모듈을 import 및 버전 정보를 확인한 결과는 위와 같다. 2. TensorFlow 예제 “Hello, TensorFlow!”라는 내용의 constant 노드를 만들고, 변수 hello에 이를 할당한다.(computation 그래프 내에 노드 1개가 만들어진 형태이다.)이 후, session을 만든 뒤 실행(run)시켰다.(computation 그래프를 실행하기 위해서는 session을 만들어야 한다.) (b’라는 문자열은 간단하게 byte string이라는 의미이다. 프로그램 동작과는 무관하다) a와 b라는 노드가 있고, ‘+’라는 노드로 연결되는 간단한 그래프를 만든 것이다. node1은 ‘3’이라는 내용, data type은 float32인 constant 노드이다.node2는 ‘4’라는 내용의 constant 노드이다. node2는 암묵적으로 node1과 마찬가지로 data type이 float32임을 유의한다.node3은 node1, node2를 더하는 add 노드이다. 이 후, node1, node2, node3를 print() 함수를 이용하여 출력하면, 각각의 노드들은 Tensor이며, 그 내용들을 확인할 수 있다. 결과값을 확인할 수는 없다. 결과값을 확인하기 위해서 1. session을 만들고, 2. 해당 session에 원하는 노드들을 넣은 뒤 3. run한다. 3. TensorFlow 구조 텐서플로우의 구조는 위와 같은데 기존의 프로그래밍과는 조금 다르다. 먼저 그래프를 빌드한다. session을 만든 뒤 run한다. 결과로 graph내의 값을 업데이트한다. 4. plcaeholder 위에서는 그래프를 만들면서, 각 노드들의 숫자들을 지정하였다.그렇다면, 그래프를 미리 만들어 놓고, 실행시키는 단계에서 값을 던지고 싶다면 어떻게 해야할까? constant 노드가 아니라, placeholder라는 특별한 노드를 사용한다. a, b, adder_node, 총 3개의 placeholder 노드를 만들었다.이 후, session을 생성한 뒤, feed_dict로 a, b 노드에 값을 할당한 뒤 실행시킨다.1개의 값이 아닌 여러개의 값을 넘겨줄 수도 있다. 5. Tensor, Ranks, Shapes, Types 5.1. Tensor TensorFlow 프로그램은 모든 데이터를 tensor 데이터 구조를 사용해서 표현한다.TensorFlow의 tensor는 n-차원 배열 또는 리스트라고 생각할 수 있다.하나의 tesnor는 정적 타입, 동적 차원을 가지고 있다.그리고 Computation 그래프의 노드들은 오직 tensor만을 전달할 수 있다. 5.2. Rank TensorFlow 시스템에서 tensor는 rank라는 차원 단위로 표현된다. 위 표는 rank에 따른 tensor의 형식이다.5.3. ShapeTensorFlow 문서는 tensor 차원을 표현할 때, 세 가지 기호를 사용한다.rank, shape, 차원수가 그것들이다.다시 말하면, tensor의 차원을 알기 위해서 rank, shape, 차원수를 살펴볼 수 있다. 5.4. Data Types Tensor는 차원 말고도 데이터 타입을 갖는다. 아래의 데이터 타입을 tensor에 지정할 수 있다. Reference 랭크, 크기, 타입-텐서플로우 문서 한글 번역본, 텐서플로우, 2019. 1. 30, https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\\_types.html 섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/","categories":[{"name":"딥러닝/머신러닝","slug":"딥러닝-머신러닝","permalink":"http://dudri63.github.io/categories/딥러닝-머신러닝/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://dudri63.github.io/tags/Deep-Learning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://dudri63.github.io/tags/딥러닝/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://dudri63.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://dudri63.github.io/tags/머신러닝/"}]},{"title":"[딥러닝/머신러닝] 머신러닝이란","slug":"adl1","date":"2019-01-30T10:32:44.000Z","updated":"2019-01-31T07:38:05.609Z","comments":true,"path":"2019/01/30/adl1/","link":"","permalink":"http://dudri63.github.io/2019/01/30/adl1/","excerpt":"","text":"1. 이세돌과 알파고2. 머신러닝이란 1. 이세돌과 알파고 그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의 순간적인 직관이 매우 중요한 것으로 여겨졌다.따라서 바둑이라는 종목에 한해서는 컴퓨터가 인간을 넘어서기 힘들 것으로 꽤 오랜 시간 간주되었다.그러나 이세돌 9단이 알파고에게 4:1로 패배하였다. 인공지능이란 무엇인가에 대하여 많은 이목이 쏠린 역사적인 사건이다.인공지능은 과연 사람처럼 직관적인 의사결정을 할 수 있는 것인가? Dr.Andrew Ng에 의하면 오늘날의 시대를 살기 위해서는 머신러닝 학습이 필수적이라고 이야기한다.또한, 머신러닝을 잘 활용하는 사람이 Super Power를 지닐 수 있다고 한다. 2. 머신러닝이란 머신러닝(Machine Learning)이란 일종의 소프트웨어, 프로그램이다.그러나 기존 프로그래밍 기법과는 차이점이 있다. 기존 explicit programming이란 개발자가 환경에 따라서 프로그램이 어떻게 반응할지를 정의한다.그런데 explicit하게, 즉, 명확하게 프로그래밍하기 어려운 경우가 있다.예를 들어, 스팸 메일을 필터링하는 프로그램을 작성할 때 모든 경우를 고려하여 스팸 or not을 결정하기가 어렵다. 머신러닝의 시작은 상황이 복잡할 때 모든 경우를 일일이 프로그래밍하지 않고, ‘어떤 현상이나 자료에서 자동적으로 배우는 것은 어떨까?’라는 생각이다.즉, 머신러닝은 프로그램인데, 개발자가 모든 경우를 명확하게 프로그래밍 하지 않고, 프로그램이 스스로 학습하여 배운 뒤 처리할 수 있도록 하는 것이라고 할 수 있다. 머신러닝은 학습하는 방법에 따라서 Supervised Learning, Unsupervised Learning으로 구분할 수 있다.Supervised Learning은 정해져있는 데이터(labeled, training set)를 이용하여 학습하는 것이다.예를 들어, 개나 고양이 사진들의 label을 각각 개, 고양이로 달고 학습을 시킬 수 있다. 그런데, 모든 경우 label을 달 수 있는 것은 아니다.Google news는 자동적으로 유사한 뉴스들을 grouping을 한다.또한, 유사한 단어들을 grouping하는 것도 특정한 label을 달기 어렵다.이 경우 Unsupervised Learning(학습)하여야 한다. 머신러닝에서 대부분의 문제들은 Supervised Learning으로 해결할 수 있다.Supervised Learning의 예는 다음과 같다. X: feature, Y: label label이 정해져 있는 feature들을 가지고 학습을 한다.(네모칸 안에 있는 표를 training data set이라고 한다.) 이 후, 내가 모르는 Xtest의 label을 물어보면, ML은 Y=3이라고 대답한다. 알파고의 원리도 위와 다르지 않다.기존 바둑 기사들이 둔 기보를 이용하여 학습한 뒤, 이세돌 9단과 대결할 때, 학습한 것을 바탕으로 각 수를 놓는 것이다. Supervised Learning의 Type은 다음과 같다. 공부한 시간에 따른 시험 성적(0~100) 예상 : regression 공부한 시간에 따른 시험 결과(pass or fail) 예상 : binary classification 공부한 시간에 따른 시험 성적(A,B,C,D,F) 예상 : multi-label classification ML을 이용한 공부한 시간에 따른 시험 성적(0~100) 예상이 어떻게 되는지는 다음과 같다. 왼쪽 표는 training data set이다.regression 모델을 왼쪽 표를 이용하여 training한다. 이 후, x=7(7시간)일 때, y(점수)를 물어보면, 학습한 것을 바탕으로 y=70을 내놓는다. Reference 섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/, https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/","categories":[{"name":"딥러닝/머신러닝","slug":"딥러닝-머신러닝","permalink":"http://dudri63.github.io/categories/딥러닝-머신러닝/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://dudri63.github.io/tags/Deep-Learning/"},{"name":"딥러닝","slug":"딥러닝","permalink":"http://dudri63.github.io/tags/딥러닝/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://dudri63.github.io/tags/Machine-Learning/"},{"name":"머신러닝","slug":"머신러닝","permalink":"http://dudri63.github.io/tags/머신러닝/"}]},{"title":"[Python] 클래스","slug":"python8","date":"2019-01-29T12:31:58.000Z","updated":"2019-01-30T10:23:26.924Z","comments":true,"path":"2019/01/29/python8/","link":"","permalink":"http://dudri63.github.io/2019/01/29/python8/","excerpt":"","text":"1. 클래스 1. 클래스 C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있다.그러나 프로그램 작성 시 클래스를 사용하면 프로그래머가 얻을 수 있는 이점이 굉장히 많다. 클래스는 ‘과자틀’, 객체는 과자틀에 의해 만들어진 ‘과자’에 비유할 수 있다.클래스란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고, 객체란 클래스에 의해서 만들어진 피조물을 뜻한다. 클래스에 의해서 만들어진 객체는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 동일한 클래스에 의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다. 123456789101112131415161718class Cal: # Cal이라는 새로운 class를 정의 def __init__(self, v1, v2): # 생성자 self.v1 = v1 self.v2 = v2 def add(self): # add 함수 return self.v1+self.v2 def subtract(self): # subtract 함수 return self.v1-self.v2 c1 = Cal(10,10) # 객체 c1 생성 및 변수에 객체 할당print(c1.add()) # 객체의 멤버에 접근print(c1.subtract()) # 객체의 멤버에 접근c2 = Cal(30,20) # 객체 c2 생성 및 변수에 객체 할당print(c2.add()) # 객체의 멤버에 접근print(c2.subtract()) # 객체의 멤버에 접근 __init__ : 생성자객체를 생성할 때, 생성자의 self를 제외한 매개변수 숫자만큼 인자를 채워야 한다.ex. __init(self,v1, v2)__ -&gt; c1 = Cal(v1,v2) self : 객체의 인스턴스 그 자체, 파이썬에서는 클래스의 메소드를 정의할 때 self를 꼭 명시해야 한다. 1234567891011class C(object): def __init__(self, v): self.value = v def show(self): print(self.value) c1 = C(10)print(c1.value) # 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출 c1.value = 20 # 객체 c1의 멤버 변수 value의 값을 변경print(c1.value) # 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출c1.show() # 객체 c1의 멤버 함수 show()를 호출, show() 함수는 value의 값을 인자로 print() 함수 호출 cf. 객체와 인스턴스 클래스에 의해서 만들어진 객체를 인스턴스라고도 한다. 그러나 객체와 인스턴스는 미묘하지만 차이점이 있다. 예를 들어 Cookie라는 클래스가 있다고 가정한다. a = Cookie() 로 만들어진 a는 객체이다. 그리고 a라는 객체는 Cookie의 인스턴스이다. 즉, 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 인스턴스” 보다는 “a는 객체”라는 표현이 어울리며, “a는 Cookie의 객체” 보다는 “a는 Cookie의 인스턴스”라는 표현이 훨씬 잘 어울린다. cf. 변수 값을 넣을 수 있는 이름이 붙어있는 공간. 일반적으로 값을 변경할 수 있다. 값을 변경할 수 없을 경우 특별하게 ‘상수’라고 한다. cf. 인스턴스 변수와 클래스 변수 인스턴스 변수와 클래스 변수를 합쳐서 ‘멤버 변수’라고 한다. 인스턴스 변수는 객체를 생성할 때 생성된다. 각각의 인스턴스마다 다른 값을 가질 수 있다. 클래스 변수는 인스턴스 변수에 static이 붙은 형식이다. 인스턴스 변수는 각각 고유한 값을 가질 수 있는 것에 반해 클래스 변수는 모든 인스턴스가 동일한 값을 공유한다. 인스턴스 변수, 클래스 변수 모두 Class 내부에서 선언된다. cf. 캡슐화 캡슐화(Encapsulation)는 객체 지향 프로그래미에서 다음 2가지 측면이 있다. 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추어 은닉한다. 외부로부터 영향을 받지 변경되지 않도록 기본적으로 캡슐화를 이용한다. 함수나 변수도 캡슐로 감싼 예 중 하나이다. 또한 함수들을 다시 묶어서 모듈로 감쌀 수도 있다. 접근 지정자를 따로 지정하여 외부에서 캡슐에 얼마나 접근할 수 있을지 설정하기도 한다. 12345678910111213class C(object): def __init__(self, v): self.value = v def show(self): print(self.value) def getValue(self): # 인스턴스의 value를 반환 return self.value def setValue(self, v): # 인스턴스의 value를 설정 self.value = vc1 = C(10) # C의 인스턴스 c1 생성 print(c1.getValue()) # c1의 value값을 받아온 뒤, print() 호출c1.setValue(20) # c1의 value값을 설정print(c1.getValue()) # c1의 value값을 받아온 뒤, print() 호출 set은 객체 내부의 데이터를 직접 바꾸기 위한 메소드,get은 객체 내부의 데이터를 직접 받아오기 위한 메소드이다. 1234567891011121314class Person: bag = [] # bag 속성(클래스 속성) def put_bag(self, stuff): self.bag.append(stuff) james = Person()james.put_bag(&apos;책&apos;) maria = Person()maria.put_bag(&apos;열쇠&apos;) print(james.bag)print(maria.bag) 클래스 속성으로서 bag 속성을 만들었다. james 인스턴스에서 ‘책’을 넣었고, maria 인스턴스에서 ‘열쇠’를 넣었는데, james, maria 모두 bag 속성으로서 책과 열쇠를 모두 갖는다.클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다. 123456789101112131415class Person: def __init__(self): self.bag = [] # bag 속성(인스턴스 속성) def put_bag(self, stuff): self.bag.append(stuff) james = Person()james.put_bag(&apos;책&apos;) maria = Person()maria.put_bag(&apos;열쇠&apos;) print(james.bag)print(maria.bag) 인스턴스 속성으로서 bag 속성을 만들었다. 이 경우, 클래스 속성으로 만들었을 때와는 달리 각 인스턴스마다 고유한 속성을 갖게 된다. Reference 05-1 클래스, 점프 투 파이썬, 2019. 1. 29, https://wikidocs.net/28 35.1 크래스 속성과 인스턴스 속성 알아보기, 코딩도장, 2019. 1. 29, https://dojang.io/mod/page/view.php?id=2378 객체와 변수, 생활코딩, 2019. 1. 29, https://opentutorials.org/course/1750/10000","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Algorithm] 동전 거스름돈 (동적계획)","slug":"algo23","date":"2019-01-29T09:07:17.000Z","updated":"2019-01-31T15:33:53.315Z","comments":true,"path":"2019/01/29/algo23/","link":"","permalink":"http://dudri63.github.io/2019/01/29/algo23/","excerpt":"","text":"1. 동전 거스름돈2. 알고리즘3. 시간 복잡도 1. 동전 거스름돈 거스름돈을 동전으로 받을 때, 누구나 적은 수의 동전을 받길 원한다고 가정한다.동전 거스름돈 문제는 그리디 알고리즘으로 해결할 수도 있으나, 160원짜리 동전을 추가로 발행하는 등의 상황이 있을 때는 항상 최적해를 찾을 수는 없다.동적 계획 알고리즘은 모든 동전 거스름돈 문제에 대하여 항상 최적해를 찾는다. 다른 문제들과 마찬가지로 동적 계획 알고리즘을 고안하기 위해서는 부분문제들을 찾아내야 한다.동전 거스름돈 문제에 주어지는 일반적인 문제 요소들을 고려한다.정해진 동전의 종류, 거스름돈이 그것들이다. 동전 거스름돈 문제도 배낭 문제와 마찬가지로 동전 거스름돈도 1원씩 증가시켜 문제를 해결한다.그리고 부분문제들의 해를 1차원 배열 C에 저장한다. 1원을 거슬러 받을 때 사용되는 최소의 동전 수 C[1] 2원을 거슬러 받을 때 사용되는 최소의 동전 수 C[2] 3원을 거슬러 받을 때 사용되는 최소의 동전 수 C[3]… n원을 거슬러 받을 때 사용되는 최소의 동전 수 C[n] 그렇다면, C[j]를 구하는 데 어떤 부분문제가 필요한가? 500원짜리 동전이 거스름돈 j원에 필요하면 C[j-500] = C[j-d1]에 500원짜리 동전 1개를 추가한다. 100원짜리 동전이 거스름돈 j원에 필요하면 C[j-100] = C[j-d2]에 100원짜리 동전 1개를 추가&gt;한다. 50원짜리 동전이 거스름돈 j원에 필요하면 C[j-50] = C[j-d3]에 50원짜리 동전 1개를 추가&gt;한다. 10원짜리 동전이 거스름돈 j원에 필요하면 C[j-10] = C[j-d4]에 10원짜리 동전 1개를 추가&gt;한다. 1원짜리 동전이 거스름돈 j원에 필요하면 C[j-1] = C[j-d5]에 1원짜리 동전 1개를 추가&gt;한다. 위 다섯 가지 중에서 가장 작은 값을 C[j]로 정한다. 그리하여 C[j]의 정의는 다음과 같다. C[j] = min1&lt;=i&lt;=k{C[j-di] + 1}, if j &gt;= di 2. 알고리즘 다음은 거스름돈 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 배열 C는 최소의 동전 수를 저장하는 데 사용된다.123456789101112DPCoinChange입력: 거스름돈 n원, k개의 동전의 액면, d1&gt;d2&gt;...&gt;dk=1출력: C[n]for i = 1 to n C[i] = ∞C[0] = 0for j = 1 to n &#123; // j는 1원부터 증가하는 임시 거스름돈 액수, j=n이면 입력에 주어진 거스름돈 for i = 1 to k &#123; // 액면이 가장 높은 동전부터 1원짜리 동전까지 if (di &lt;= j) and (C[j-di] + 1 &lt; C[j]) // 액면이 가장 높은 동전부터 1원짜리 동전까지 C[j] = C[j-di] + 1 &#125;&#125;return C[n] 다음은 d1=16, d2=10, d3=5, d4=1이고, 거스름돈 n=20일 때, DPCoinChange 알고리즘이 수행되는 과정이다. Line 4~5 : 배열 C를 초기화한다. Line 6~9 : j = 1일 때(임시 거스름론), i = 1, 2, 3일 때,d1 = 16 &gt; j, d2=10 &gt; j, d3=5 &gt; jif 조건을 만족하지 않음 i = 4일 때,d4 = 1 &lt; j, C[j-d4]+1 = C[1-1]+1 = 0+1 = 1 &lt; C[j] = C[1] = ∞if 조건을 만족C[j] = C[j-d4] + 1 = C[1] = C[1-1] + 1 = 0 + 1 = 1 Line 6~9 : j = 2, 3, 4일 때, i = 4일 때에만 if 조건을 만족함(j = 1일 때와 동일)C[2] = C[2-1] + 1 = 2, C[3] = 3, C[4] = 4 Line 6~9 : j = 5일 때 i = 1, 2일 때,d1 = 16 &gt; j, d2=10 &gt; jif 조건을 만족하지 않음 i = 3일 때,d3 = 5 = j, C[j-d3]+1 = C[5-5]+1 = 0+1 = 1 &lt; C[j] = C[5] = ∞if 조건을 만족C[5] = C[j-d3]+1 = C[5-5]+1 = 0+1 = 1 i = 4일 때,d4 = 1 = j, C[j-d4]+1 = C[5-1]+1 = 4+1 = 5 &gt; C[j] = C[5] = 1if 조건을 만족하지 않음 Line 6~9 : j = 6, 7, 8, 9일 때 i = 3일 경우에만 if 조건을 만족함(j = 5일 때와 동일)C[6] = C[6-5] + 1 = 2, C[7] = 3, C[8] = 4, C[9] = 5 Line 6~9 : j = 10일 때 i = 1일 때,d1 = 16 &gt; jif 조건을 만족하지 않음 i = 2일 때,d2 = 10 = j, C[j-d2]+1 = C[10-10]+1 = 0+1 = 1 &lt; C[j] = C[10] = ∞if 조건을 만족C[10] = C[j-d2]+1 = C[10-10]+1 = 0+1 = 1 i = 3,4 일 때,di &lt; j = 10,C[j-d3]+1 = C[10-5]+1 = 2 &gt; 1, C[j-d4]+1 = C[10-1]+1 = 6 &gt; 1if 조건을 만족하지 않음 Line 6~9 : j = 11, 12, 13, 14, 15일 때 i = 2일 경우에만 if 조건을 만족함(j = 10일 때와 동일)C[11] = 2, C[12] = 3, C[13] = 4, C[14] = 5 Line 6~9 : j =15일 때 i = 1일 때,d1 = 16 &lt; jif 조건을 만족하지 않음 i = 2일 때,d2 = 10 &gt; j, C[j-d2]+1 = C[15-10]+1 = 1+1 = 2 &lt; C[j] = C[10] = ∞if 조건을 만족C[15] = C[j-d2]+1 = C[15-10]+1 = 2 i = 3,4일 때,if 조건을 만족하지 않음 Line 6~9 : j = 16일 때 i = 1일 때,d1 = 16 = j, C[j-d1]+1 = C[16-16]+1 = 0+1 = 1 &lt; C[j] = C[16] = ∞if 조건을 만족C[16] = C[j-d1]+1 = C[16-16]+1 = 0+1 = 1 i = 2, 3, 4일 때,if 조건을 만족하지 않음 Line 6~9 : j = 17, 18, 19일 때 i = 1일 경우에만 if 조건을 만족함(j = 16일 때와 동일)C[17] = 2, C[18] = 3, C[19] = 4 Line 6~9 : j = 20일 때 i = 1if 조건을 만족하지 않음 i = 2if 조건을 만족C[20] = C[j-d2]+1 = C[10]+1 = 2 i = 3C[20] = C[j-d3]+1 = C[15]+1 = 3 &gt; 2if 조건을 만족하지 않음 i = 4일 때C[20] = C[j-d4]+1 = C[19]+1 = 5 &gt; 2if 조건을 만족하지 않음 Line 12 C[20] = 2를 return 3. 시간복잡도 DPCoinChange 알고리즘의 시간복잡도는 O(nk)이다.왜냐하면 거스름돈 j가 1원부터 n원까지 변하며, 각각의 j에 대하여 최악의 경우 모든 동전을 1번씩 고려하기 때문이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"동적계획","slug":"동적계획","permalink":"http://dudri63.github.io/tags/동적계획/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 배낭 문제 (동적계획)","slug":"algo22","date":"2019-01-29T06:53:17.000Z","updated":"2019-01-29T09:07:01.324Z","comments":true,"path":"2019/01/29/algo22/","link":"","permalink":"http://dudri63.github.io/2019/01/29/algo22/","excerpt":"","text":"1. 배낭 문제2. 알고리즘3. 시간 복잡도 1. 배낭 문제 배낭 문제(Knapsack)는 n개의 물건과 각 물건 i의 무게 wi와 가치 vi가 주어지고, 배낭의 용량이 C일 때, 배낭에 담을 수 있는 물건의 최대 가치를 찾는 문제이다.단, 배나에 담은 물건의 무게의 합이 C를 초과하지 말아야 하고, 각 물건은 1개씩만 있다. 이러한 배낭 문제를 0-1 배낭 문제라고 하는데, 이는 각 물건이 담기지 않은 경우 ‘0’, 담긴 경우 ‘1’로 간주하기 때문이다. 배낭 문제는 제한적입 입력에 대해서 동적 계획 알고리즘으로 풀 수 있다.배낭 문제의 부분 문제를 정의하기 위해서 물건, 물건의 무게, 물건의 가치, 배낭의 용량, 4가지의 요소를 고려할 수 있다. 배낭 문제의 부분문제의 정의를 위해 물건은 하나씩 차례로 고려하면 되지만, 물건의 무게는 각각 다를 수 있기 때문에, 무게에 대해서는 배낭의 용량 0(kg)으로부터 1(kg)씩 증가하여 입력으로 주어진 용량 C가 될 때까지 변화시켜 가며 물건을 배낭에 담는 것이 가치가 더 커지는지를 결정해야 한다. 따라서 배낭 용량이 0부터 1씩 증가할 경우의 용량을 ‘임시’ 배낭 용량이라고 한다.따라서 배낭 문제의 부분문제를 다음과 같이 정의할 수 있다. K[i,w] = 물건 1~i까지만 고려하고, (임시) 배낭 용량이 w일 때의 최대 가치단, i - 1, 2, …, n, w = 1, 2, 3, …, C이다. 문제의 최적해는 K[n,C]이다. 2. 알고리즘 다음은 배낭 문제의 동적 계획 알고리즘이다. 2차원 배열 K가 최대 가치를 저장하는 데 사용된다. 1234567891011121314Knapsack입력: 배낭의 용량 C, n개의 물건, 각 물건 i의 무게 wi, 가치 vi, 단, i = 1,2,3,...,n출력: K[n,C]for i = 0 to n K[i,0]=0 // 배낭의 용량이 0일 때 총 가치 0으로 초기화for w = 0 to C K[0,w]=0 // 배낭에 아무것도 담기지 않았을 때 총 가치 0으로 초기화for i = 1 to n &#123; for w = 1 to C &#123; if (wi &gt; w) // 물건 i의 무게가 임시 배낭의 용량을 초과하면 K[i,w] = K[i-1,w] else // 물건 i를 배낭에 담지 않을 경우와 담을 경우를 고려 K[i,w] = max&#123;K[i-1,w], K[i-1,w-wi]+vi&#125; &#125;&#125;return K[n,C] Line 8~9 : 현재 배낭에 담으려고 고려하는 물건 i의 무게 wi가 임시 배낭의 무게 w보다 크면 배낭에 담을 수 없다. 따라서 K[i,w]는 물건 (i-1)까지 담은 K[i-1,w]가 된다. Line 10~11 : 고려하는 물건 i의 무게 wi가 임시 배낭의 무게 w보다 같거나 작으면, 물건 i를 배낭에 담을 수 있다. 그러나 배낭에서 물건 i를 담을 공간을 마련하는 작업을 고려하여야 한다.(배낭의 무게가 부족할 경우) 즉, 물건 i를 배낭에 담기 위해서는 2가지 경우를 살펴보아야 한다. 1) 물건 i를 배낭에 담을 수 없는 경우, K[i,w] = K[i-1,w]2) 물건 i를 배낭에 담을 수 있는 경우, K[i,w] = max{K[i-1,w],K[i-1,w-wi]+vi}, 기존 물건을 빼고 물건 i를 담거나, 물건 i를 담지 않거나, 기존 물건들은 배낭에 냅둔 체 물건 i를 새롭게 담는 경우로서 3가지 경우를 망라한다. 배낭의 용량이 C=10kg, 각 물건의 무게와 가치가 다음과 같을 때 위 알고리즘이 적용되는 것을 본다. Line 3~4 : 0번 행과 0번 열의 각 원소를 ‘0’으로 초기화한다. Line 5 : 물건을 하나씩 고려하기 위해 물건 번호 i가 1~4까지 변화Line 6 : 배낭의 임시 용량 w가 1씩 증가하여 마지막엔 10kg이 된다. i = 1일 때, w = 1일 때, 물건 1을 배낭에 담으려고 한다. 그러나 w1=5 &gt; w=1, K[1,1] = K[1-1,1] = 0 w = 2, 3, 4일 때, w1 &gt; w, K[1,2]=K[1,3]=K[1,4]=0 w = 5일 때, w1 = w = 5,K[1,5] = max{K[i-1,w], K[i-1,w-wi]+vi} = max{K[0,5], K[0,0] + 10} = max{0, 10} = 10 w = 6, 7, 8, 9, 10일 때, w = 5일 때와 같다. K[1,6] = K[1,7] = K[1,8] = K[1,9] = K[1,10] = 10이다. i = 2일 때, 물건 1에 대한 부분문제들의 해는 구한 상태, 이를 이용하여 물건 2를 고려한다. w = 1, 2, 3일 때, 물건 2를 배낭에 담으려고 한다. 그러나 w2=4 &gt; w, K[2,1] = K[2,2] = K[2,3] = 0 w = 4일 때, 물건 2를 배낭에 담을 수 있다.K[2,4] = max{K[i-1,w], K[i-1,w-wi]+vi} = max{K[1,4], K[1,0]+40} = max{0, 40} = 40 w = 5일 때, 물건 2를 배낭에 담을 수 있다. 그러나 물건 1이 배낭에 담았을 때의 가치와 물건 2를 담았을 때의 가치를 비교하여, 더 큰 가치를 얻는 물건을 배낭에 담는다.K[2,5] = max{K[i-1,w], K[i-1,w-wi]+vi} = max{K[1,5], K[1,1]+40} = max{10,40} = 40물건 1을 배낭에서 뺀 후, 물건 2를 담는 것의 가치가 더 높으므로 물건 2를 담는다. w = 6, 7, 8일 때, 물건 1을 빼내고 물건 2를 담는 것이 더 큰 가치를 얻는다. K[2,6] = K[2,7] = K[2,8] = 40 w = 9일 때, 물건 2를 배낭에 담을 수 있다.K[2,9] = max{K[i-1,w], K[i-1,w-wi&lt;/sub]&gt;+vi} = max{10,50} = 50배낭에 물건 1,2를 모두 담을 수 있고, 그때 가치가 50이 된다. w = 10일 때, w = 9일 때와 마찬가지로 물건 1,2를 모두 담을 수 있고, K[2,10] = 50이 된다. i = 3, 4일 때 알고리즘 수행 결과는 다음과 같다. 최적해는 물건 2와 4의 가치의 합인 90이다. 3. 시간 복잡도 Knapsack 알고리즘은 line 8에서 무게를 한번 비교한 후 line 9에서 1개의 부분문제의 해를 참조 line 11에서 2개희 해를 참조한 계산이므로 O(1) 시간이 걸린다. 그런데, 부분문제의 수는 원소 수인 n*C이므로, 시간복잡도는 O(1)*n*C = O(nC)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"동적계획","slug":"동적계획","permalink":"http://dudri63.github.io/tags/동적계획/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 편집 거리 문제 (동적계획)","slug":"algo21","date":"2019-01-29T05:32:05.000Z","updated":"2019-01-29T07:48:57.938Z","comments":true,"path":"2019/01/29/algo21/","link":"","permalink":"http://dudri63.github.io/2019/01/29/algo21/","excerpt":"","text":"1. 편집 거리 문제2. 알고리즘3. 시간 복잡도 1.편집 거리 문제 문서 편집기를 사용하는 중에 하나의 문자열을 수정하여 다른 문자열로 변환시키고자 할 때, 삽입(insert), 삭제(delete), 대체(substitute) 연산이 사용된다. 예를 들어, A를 B로 변환시키는 데 필요한 최소의 편집 연산 횟수를 편집 거리(Edit Distance)라고 한다. 편집 거리 문제는 편집 거리를 찾는 문제이다. 예를 들어, ‘strong’을 ‘stone’으로 편집하는 과정을 본다. ‘s’, ‘t’는 그대로 사용, ‘o’를 삽입, ‘r’, ‘o’를 삭제, ‘n’을 그대로 사용, ‘g’를 ‘e’로 대체한다.이 경우, 총 4회의 편집 연산이 수행되었다.(삽입 1회, 삭제 2회, 대체 1회) 반면에 위 경우, ‘r’ 삭제, ‘g’를 ‘e’로 대체, 단 2회의 편집 연산을 수행하였다. 이처럼 문자를 편집할 때, 어떤 연산을 어느 문자에 수행하느냐에 따라서 편집 연산 횟수가 달라진다. 부분 문제를 정의하기 위하여 스트링 S, T를 위와 같이 지정하고, 길이를 각각 m, n이라고 한다. 그리고 각각의 문자를 si,ti이라 한다. E[i,j]는 S의 접두부의 i개 문자를 T의 접두부 j개 문자로 변환시키는 데 필요한 최소 편집 연산 횟수, 즉 편집 거리이다.예를 들어, ‘strong’의 접두부는 ‘stro’이므로 i = 4, ‘stone’의 접두부는 ‘sto’이므로 j = 3인데, 각 문자열의 접두부를 바꾸기 위한 편집 거리를 찾는 문제는 E[i,j] = E[4,3]이다.E[4,3]을 점진적으로 E[6,5]를 해결하면 문제의 해를 찾을 수 있다. s1 -&gt; t1 부분문제 : E[1,1] = 0 S1 -&gt; t1t2 부분문제 : E[1,2] = 1, ‘s’를 ‘st’로 편집, ‘t’ 삽입 1회 연산 s1s2 -&gt; t1 부분문제 : E[2,1] = 1, ‘st’를 ‘s’로 편집, ‘t’ 삭제 1회 연산 s1s2 -&gt; t1t2 부분문제 : E[2,2] = 0 이 때, 부분문제 s1s2s3s4 -&gt; t1t2t3 : E[4,3], ‘stro’를 ‘sto’로 편집은 어떻게 계산하는가? E[4,2] (부분문제 s1s2s3s4 -&gt; t1t2)를 알면, t3 = ‘o’를 삽입하면 된다. 그러므로 E[4,3] = E[4,2] + 1이다. E[3,3] (부분문제 s1s2s3 -&gt; t1t2t3)를 알면, s4 = ‘o’를 삭제하면 된다. 그러므로 E[4,3] = E[3,3] + 1이다. E[3,2] (부분문제 s1s2s3 -&gt; t1t2)를 알면, s4 -&gt; t3로 편집하는데 필요한 연산을 계산하면 도니다. 그러나 이 경우, 2개의 문자가 ‘o’로 같으므로 편집할 필요가 없다. 그러므로 E[4,3] = E[3,2]이다. 따라서 E[4,3]의 편집 거리를 계산하려면 앞의 3가지 부분문제의 해, 즉, E[4,2], E[3,3], E[3,2]의 편집 거리를 알아야 한다. 그런데 이 경우, (2+1), (1+1), 1 중에서 최솟값인 1이 E[4,3]의 편집 거리가 된다. 일반적으로 E[i-1,j], E[i,j-1], E[i-1,j-1]의 해가 미리 계산되어 있으면 E[i,j]를 계산할 수 있다. 그러므로 편집 거리 문제의 부분문제 간의 함축적인 순서는 다음과 같다. 위 E[4,3] 예제와 비교하면, 위 그림이 의미하는 바는 금방 파악된다.세 가지 경우 중 가장 적은 값을 E[i,j]의 해로서 선택한다.E[i,j] = min{E[i,j-1]+1, E[i-1,j]+1, E[i-1,j-1]+a} 단, if si=tj a=0, else a=1 위 식을 위해, E[0,0], E[1,0], … , E[m,0]과 E[0,1], E[0,2], … , E[0,n]을 다음과 같이 초기화한다. ε = (공 문자열)공 문자열에서 문자열이 하나씩 추가되는 것이므로 삽입 연산에 의해 1씩 증가하는 것은 자명한 사실이다.**2. 알고리즘다음은 편집 거리 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 2차원 배열 E는 편집 거리를 저장하는 데 사용된다.123456789EditDistance입력: 스트링 S,T, 단, S와 T의 길이는 각각 m,n이다.출력: S를 T로 변환하는 편집 거리, E[m,n]for i=0 to m E[i,0]=i // 0번 열의 초기화for j=0 to n E[0,j]=j // 0번 행의 초기화for i=1 to m for j=1 to n E[i,j] = min&#123;E[i,jj-1]+1, E[i-1,j]+1, E[i-1,j-1]+a&#125;return E[m,n] 위 그림은 EditDistance 알고리즘이 ‘strong’을 ‘stone’으로 바꾸는 데 필요한 거리를 계산한 결과인 배열 E이다.a = 0 or a = 1인 경우에 유의하여 9시, 11시, 12시 방향에서 가장 작은 값을 푸른색 배경의 셀에 넣으면서 나아가면 된다. 3. 시간 복잡도 EditDistance 알고리즘의 시간복잡도는 O(mn)이다. 총 부분문제의 수가 m*n이고, 각 부분문제를 해결하기 위해서 주위의 3개의 부분문제들의 해를 참조한 후 최솟값을 찾는 것이므로 O(1) 시간이 걸리기 때문이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"동적계획","slug":"동적계획","permalink":"http://dudri63.github.io/tags/동적계획/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Python] 함수, 모듈","slug":"python7","date":"2019-01-28T15:08:23.000Z","updated":"2019-01-30T10:27:05.568Z","comments":true,"path":"2019/01/29/python7/","link":"","permalink":"http://dudri63.github.io/2019/01/29/python7/","excerpt":"","text":"1. 함수2. 모듈 1. 함수 함수란 믹서기와 같다. 입력값을 가지고 어떤 일을 수핸한 다음에 그 결과물을 내놓는 역할을 한다.예를 들어 y = 4x + 5도 함수이다. 프로그래밍을 하다 보면 똑같은 내용을 반복해서 작성할 수 있다. 이 때, 함수를 사용하면 유용하다.또한, 프로그램을 함수화하면 프로그램의 흐름을 일목요연하게 볼 수 있다. 이 경우, 에러가 발생 시에도 어디서 발생하였는지 금방 알 수 있다. 123def a3(): # 함수 a3() 정의 print(&apos;aaa&apos;)a3() def : 함수를 정의한다. 123def a3(): return &apos;aaa&apos;print(a3()) 123def a(num): return &apos;a&apos;*numprint(a(3)) 123def make_string(str, num): return str*numprint(make_string(&apos;b&apos;, 3)) 1234567891011input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)def login(_id): members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;] for member in members: if member == _id: return True return Falseif login(input_id): print(&apos;Hello, &apos;+input_id)else: print(&apos;Who are you?&apos;) 2. 모듈 모듈이란 함수나 변수 또는 클래스들을 모아놓은 파일이다.또한, 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.다른 사람들이 이미 만들어놓은 모듈을 사용할 수도 있고, 직접 만들어서 사용할 수도 있다. 1234import mathprint(math.ceil(2.9))print(math.floor(2.9))print(math.sqrt(16)) math 모듈은 여러가지 수학 관련 함수를 담고 있는 모듈이다. ceil(x) : x를 가까운 정수까지 반올림한 뒤 반환floor(x) : x를 가까운 정수까지 버림한 뒤 반환sqrt(x) : x의 제곱근을 반환 egoing.py123456def a(): return &apos;a&apos;def b(): return &apos;b&apos;def c(): return &apos;c&apos; k8805.py12def a(): return &apos;B&apos; 6.py1234from egoing import a as zimport k8805 as kprint(z())print(k.a()) egoing 모듈로부터 모듈함수를 import할 수 있다. 이 경우, 모듈이름을 붙이지 않고 바로 해당 모듈의 함수를 사용할 수 있다.또한, 모듈을 import할 경우, 해당 모듈 함수를 사용하기 위해서는 모듈이름을 붙여야 한다. auth.py123456def login(_id): members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;] for member in members: if member == _id: return True return False 6.py123456import authinput_id = input(&quot;아이디를 입력해주세요.\\n&quot;)if auth.login(input_id): print(&apos;Hello, &apos;+input_id)else: print(&apos;Who are you?&apos;) Reference ‘04-1 함수’, 점프 투 파이썬, 2019. 1. 29, https://wikidocs.net/24#_1 ‘05-5 내장 함수’, 점프 투 파이썬, 2019. 1. 29, https://wikidocs.net/32#len ‘[파이썬]공통함수,수학(math) 함수’, andamiro25, 2019. 1. 29, https://andamiro25.tistory.com/","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 반복문","slug":"python6","date":"2019-01-28T14:46:58.000Z","updated":"2019-01-28T15:26:19.176Z","comments":true,"path":"2019/01/28/python6/","link":"","permalink":"http://dudri63.github.io/2019/01/28/python6/","excerpt":"","text":"1. 반복문, while2. 컨테이너와 반복문3. for 1. 반복문, while 1.1 반복문이 없다면 12345678910print(&quot;Hello world 0&quot;)print(&quot;Hello world 9&quot;)print(&quot;Hello world 18&quot;)print(&quot;Hello world 27&quot;)print(&quot;Hello world 36&quot;)print(&quot;Hello world 45&quot;)print(&quot;Hello world 54&quot;)print(&quot;Hello world 63&quot;)print(&quot;Hello world 72&quot;)print(&quot;Hello world 81&quot;) 1.2 while 123while False: print(&apos;Hello world&apos;)print(&apos;After while&apos;) 1234i = 0while i &lt; 3: print(&apos;Hello world&apos;) i = i + 1 1234i = 0while i &lt; 10: print(&apos;print(&quot;Hello world &apos;+str(i*9)+&apos;&quot;)&apos;) i = i + 1 str() : 숫자를 문자열로 변환하는 함수 12345i = 0while i &lt; 10: if i == 4: print(i) i = i + 1 1234567i = 0while i &lt; 10: if i == 4: break print(i) i = i + 1print(&apos;after while&apos;) 2. 컨테이너와 반복문 12345members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]i = 0while i &lt; len(members): print(members[i]) i = i + 1 3. for 123members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]for member in members: print(member) 12for item in range(5, 11): print(item) 12345678input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]for member in members: if member == input_id: print(&apos;Hello!, &apos;+member) import sys sys.exit()print(&apos;Who are you?&apos;) Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 28, https://opentutorials.org/course/1750/9621, https://opentutorials.org/course/1750/9874","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Algorithm] 연속 행렬 곱셈 (동적계획)","slug":"algo20","date":"2019-01-28T07:59:17.000Z","updated":"2019-01-28T14:04:05.429Z","comments":true,"path":"2019/01/28/algo20/","link":"","permalink":"http://dudri63.github.io/2019/01/28/algo20/","excerpt":"","text":"1. 연속 행렬 곱셉 (Chained Matrix Multiplications)2. 알고리즘3. 시간 복잡도 1. 연속 행렬 곱셉 (Chained Matrix Multiplications) 연속 행렬 곱셉 (Chained Matrix Multiplications) 문제는 연속된 행렬들의 곱셉에 필요한 원소 간의 최소 곱셉 횟수를 찾는 문제이다. 예를 들어, 위와 같은 두 개의 행렬을 곱하는 경우, 10*20 행렬 A와 20*5 행렬 B를 곱하는데 원소간의 곱셈 횟수는 10*20*5 = 1000이다. 그리고 두 행렬을 곱한 결과 행렬 C는 10*5이다. 또 다른 예시로, 세 개의 행렬을 곱하는 경우를 고려한다.행렬의 곱셈에서는 결합법칙이 허용됨을 기억한다. A*B*C = (A*B)*C = A*(B*C) A*B를 먼저 계산한 후에 그 결과 행렬과 행렬 C를 곱하는 경우, 곱셈 횟수는 다음과 같다.A*B = 10*20*5 = 1000, AB*C = 10*5*15 = 750총 1000 + 750 = 1750회의 원소의 곱셈이 필요하다. B*C를 먼저 계산한 후에 그 결과 행렬과 행렬 A를 곱하는 경우, 곱셈 횟수는 다음과 같다.B*C = 20*5*15 = 1500, A*BC = 10*20*15 = 3000총 1500 + 3000 = 4500회의 원소의 곱셈이 필요하다. 동일한 결과를 얻음에도 불구하고 원소 간의 곱셈 횟수가 차이가 난다. 따라서 연속 행렬을 곱하는 데 필요한 원소 간의 곱셈 횟수를 최소화시키기 위한 적절한 곱셈 순서를 찾아야 한다. 연속 행렬 곱셈 문제는 대표적인 동적 계획 알고리즘 문제이다.단, 이웃하는 행렬끼리 먼저 곱해야 하는 특징 때문에 비교적 간단하게 해결할 수 있다. 행렬 A, B, C, D, E를 곱하는데 다음과 같은 부분 문제가 만들어진다. 부분 문제들이 겹쳐있다는 것이 중요하다. 크기가 3인 부분문제가 3인 경우도 서로 이웃하는 부분문제들끼리 겹쳐 있음을 알 수 있다. 마지막 부분문제의 갯수가 1개인 경우는 주어진 문제로서 입력이다. 2. 알고리즘 다음은 연속 행렬 곱셈을 위한 동적 계획 알고리즘이다.단, 원소 간의 최소 곱셈 횟수를 C[i,j]에 저장한다.1234567891011121314151617MatrixChain입력: 연속된 행렬 A1\\*A2\\*...\\*An,출력: 입력의 행렬 곱셈에 필요한 원소 간의 최소 곱셈 횟수for i = 1 to n C[i,i] = 0for L = 1 to n-1 &#123; //L은 부분문제의 크기를 조절하는 인덱스 for i = 1 to n-L &#123; j = i + L C[i,j] = ∞ for k = i to j-1 &#123; temp = C[i,k] + C[k+1,j] + d(i-1)dkdj if (temp &lt; C[i,j]) C[i,j] = temp &#125; &#125;&#125;return C[1,n] A1 : 10*20, A2 : 20*5, A3 : 5*15, A4 : 15*30일 때, MatrixChain 알고리즘 수행 과정은 다음과 같다. Line 4~5 : C[1,1] = C[2,2] = C[3,3], C[4,4] = 0으로 초기화 Line 6 : L이 1부터 n-1 = 4-1 = 3까지 변하고, 각각의 L값에 대해, i가 변화, C[i,j]를 계산 L = 1일 때, i는 1부터 n-L = 4-1 = 3까지 변한다. i = 1이면, j = i+L = 1+1 = 2, C[1,2] = ∞,temp = C[1,1] + C[2,2] + d0d1d2 = 0 + 0 + (10*20*5) = 1000temp = 1000 &lt; C[1,2] = ∞, C[1,2] = 1000 i = 2이면, j = i+L = 2+1 = 3, C[2,3] = ∞temp = C[2,2] + C[3,3] + d1d2d3 = 0 + 0 + (20*5*15) = 1500temp = 1500 &lt; C[2,3] = ∞, C[2,3] = 1500 i = 3이면, j = i+L = 3+1 = 4, C[3,4] = ∞temp = C[3,3] + C[4,4] + d2d3d4 = 0 + 0 + (5*15*30) = 2250temp = 2250 &lt; C[3,4] = ∞, C[3,4] = 2250 A1 * A2 = 1000, A2 * A3 = 1500, A3 * A4 = 2250 L = 2일 때, i는 1부터 n-L = 4-2 = 2까지 변한다. i = 1이면, j = i+L = 1+2 = 3, C[1,3] = ∞ k = 1일 때, temp = C[1,1] + C[2,3] + d0d1d3 = 0 + 1500 + (10*20*15) = 4500temp = 4500 &lt; C[1,3] = ∞, C[1,3] = 4500A2*A3 = 1500, A1*A2A3 = 3000 + 1500 k = 2일 때, temp = C[1,2] + C[3,3] + d0d2d3 = 1000 + 0 + (10*5*15) = 1750temp = 1750 &lt; C[1,3] = 4500, C[1,3] 1750A1*A2 = 1000, A1A2*A3 = 1000 + 750 i =2이면, j = i+L = 2+2 = 4, C[2,4] = ∞ k = 2일 때, temp = C[2,2] + C[3,4] + d1d2d4 = 0 + 2250 + (20*5*30) = 5250temp = 5250 &lt; C[2,4] = ∞, C[2,4] = 5250A3*A4 = 2250, A2*A3A4 = 3000 + 2250 k = 3일 때, temp = C[2,3] + C[4,4] + d1d3d4 = 1500 + 0 + (20*15*30) = 10500temp = 10500 &gt; C[2,4] = 2250, C[2,4] = 5250A2*A3 = 1500, A2A3*A4 = 9000 + 1500 L = 3일 때, i는 1부터 n-L = 4-3 = 1까지 변한다.(i=1일때만 수행) i = 1이면, j = i+L = 1+3 = 4, C[1,4] = ∞ k = 1일 때, temp = C[1,1] + C[2,4] = d0d1d4 = 0 + 5250 + (10*20*30) = 11250temp = 11250 &lt; C[1,4] = ∞, C[1,4] = 11250A2*A3*A4 = 5250, A1*A2A3A4 = 6000 k = 2일 때, temp = C[1,2] + C[3,4] = d0d2d4 = 1000 + 2250 + (10*5*30) = 4750temp = 4750 &lt; C[1,4] = ∞, C[1,4] = 4750A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1000 + 1500 + 2250 = 4750 k = 3일 때, temp = C[1,3] + C[4,4] = d0d3d4 = 1750 + 0 + (10*15*30) = 6250temp = 6250 &gt; C[1,4] = 4750, C[1,4] = 4750A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1750 + 4500 = 6250 C[1,4]= 4750을 반환 3. 시간복잡도 3중 for문 -&gt; O(n3) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"동적계획","slug":"동적계획","permalink":"http://dudri63.github.io/tags/동적계획/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Python] 컨테이너, 리스트","slug":"python5","date":"2019-01-27T10:12:22.000Z","updated":"2019-01-30T10:26:30.510Z","comments":true,"path":"2019/01/27/python5/","link":"","permalink":"http://dudri63.github.io/2019/01/27/python5/","excerpt":"","text":"1. 컨테이너2. 리스트 1. 컨테이너 변수는 컨테이너와 비슷하다. ex. name = ‘seo’ 와 같이 값을 대입할 수 있다.위 예에서 볼 수 있듯이 변수는 ‘하나의 값을 담는 그릇’과 같다. 하나의 그릇에 여러 개의 값을 담을 수는 없을까?-&gt; 컨테이너라는 것을 만들어서 각각의 값을 담을 수 있다. 위 그림은 컨테이너의 개념을 파악하는 데 유용하다.하나의 그릇에 세 개의 값(‘Egoing’, ‘Leezche’, ‘Graphittie’)을 담았다. 또한, 그릇데 담긴 값들은 각각 0, 1, 2라는 번호가 부여된다.또한, 컨테이너를 다시 변수에 담을 수 있다. 그리하여 변수의 이름을 통해 컨테이너에 접근할 수 있다. 컨테이너란 포괄적인 개념이며, 파이썬에서는 보통 ‘리스트(list)’로 지칭한다. 2. 리스트 리스트란 “0개 이상의 값의 원소들의 순서있는 집합”이다. 즉, 일종의 집합이나 컨테이너의 형태로 그 내부에 여러 개의 값을 원소로 가질 수 있으며 다른 언어에서는 배열 혹은 벡터로 불리는 타입과 비슷하다.리스트는 순서있는 집합이므로 각 원소는 리스트 내부에서 고유한 순서를 가지고 있는데, 이 순서를 인덱스라고 한다. 12345678910print(type(&apos;egoing&apos;)) # &apos;egoing&apos;의 타입(stirng)을 출력name = &apos;egoing&apos;print(name) # 변수 name에 담긴 것을 출력print(type([&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;])) # [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]의 타입(list)을 출력names = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;] # 변수 name에 list를 담음print(names) print(names[2]) # 변수 name의 2번을 출력egoing = [&apos;programmer&apos;, &apos;seoul&apos;, 25, False] # list 생성 및 변수 name에 담음egoing[1] = &apos;busan&apos; # egoing의 1번을 변경print(egoing) # [&apos;programmer&apos;, &apos;busan&apos;, 25, False] 123456al = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;] # list al 생성print(len(al)) # al의 전체 요소 개수를 반환al.append(&apos;E&apos;) # al list에 &apos;E&apos;를 추가print(al) # [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]del(al[0]) # al list의 0번을 제거print(al) # [&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;] len() : 입력값의 길이 또는 요소의 전체 개수를 반환하는 함수.append() : 리스트에 요소를 추가하는 함수.del() : 리스트의 요소를 삭제하는 함수.ex. del a[1] : a list의 1번을 삭제 del a[1:] : a list의 1번부터 삭제(여러개의 요소를 한꺼번에 삭제) Reference (연재) 파이썬은 처음이라 - 리스트는 처음이라, Wireframe-숩은 아직 20대, 2019. 1 .27, https://soooprmx.com/archives/8824 “Python &amp; Ruby”, 생활코딩, 2019. 1. 27, https://opentutorials.org/course/1750/9681, https://opentutorials.org/course/1750/9619, https://opentutorials.org/course/1750/9626","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Algorithm] 모든 쌍 최단 경로 (동적계획)","slug":"algo19","date":"2019-01-26T16:04:54.000Z","updated":"2019-01-28T07:58:41.502Z","comments":true,"path":"2019/01/27/algo19/","link":"","permalink":"http://dudri63.github.io/2019/01/27/algo19/","excerpt":"","text":"1. 모든 쌍 최단 경로 (All Pairs Shortest Paths)2. 플로이드-워셜(Floyd-Warshall) 알고리즘3. 시간 복잡도 1. 모든 쌍 최단 경로(All Pairs Shortest Paths) 모든 쌍 최단 경로(All Pairs Shortest Paths) 문제는 각 쌍의 점 사이의 최단 경로를 찾는 문제이다.이 문제를 해결하려면, 각 점을 시작점으로 다익스트라 알고리즘을 수행하면 된다.이 때, 시간 복잡도는 (n-1)*O(n2) = O(n3)이다. 모든 쌍 최단 경로를 찾는 동적 계획 알고리즘을 플로이드-워셜(Floyd-Warshall) 알고리즘이라고 한다.(이하, 플로이도 알고리즘)플로이드 알고리즘의 시간복잡도는 O(n3)으로 다익스트라 알고리즘을 (n-1)번 사용할 때의 시간복잡도와 동일하다.그러나 플로이드 알고리즘은 매우 간단하다는 장점이 있다. 동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면 먼저 부분문제들을 찾아야 한다. 그래프에 3개의 점이 있는 경우,점 i에서 점 j까지의 최단 경로를 찾으려면 2가지 경로, 점 j로 직접 가능 경로와 1을 경유하는 경로 중에서 짧은 것을 선택. 다른 아이디어는 경유 가능한 점들을 점 1로부터 시작하여, 점 1과 2, 그 다음에는 점 1,2,3으로 하나씩 추가, 마지막에는 점 1에서 점 n까지의 모든 점을 경유 가능한 점들로 고려, 모든 쌍의 최단 경로의 거리를 계산하는 것이다. 위 아이디어를 이용하면 부분문제들을 만들 수 있다. Dijk = 점 {1,2,…,k}만을 경유하는 점들로 고려, 점 i로부터 점 j까지의 모든 경로 중에서 가장 짧은 경로의 거리(단, 점 1에서 k까지의 모든 점들을 반드시 경유하는 경로를 의미하는 것은 아님) Dij1은 i에서 점 1을 경유하여 j로 가는 경로, i에서 j로 직접 가는 경로, 즉 선분 (i,j) 중에서 짧은 거리이다. 단, i≠1, j≠1 i에서 점 2를 경유하여 j로 가는 경로의 거리와 Dij1 중에서 짧은 거리를 Dij2로 정한다. 단, 점 2를 경유하는 경로의 거리는 Di21 + D2j1 이다. 단, i≠2, j≠2 … i에서 점 k를 경유하여 j로 가는 경로의 거리와 Dijk-1 중에서 짧은 것을 Dijk로 정한다. 단, 점 k를 경유하는 경로의 거리는 Dikk-1+Dkjk-1이다. 단, i≠k, j≠k 이런 방식으로 k가 1에서 n이 될 때까지 Dijk를 계산해서 모든 점을 경유 가능한 점들로 고려된 모든 쌍 i와 j의 최단 경로의 거리를 찾는 방식이 플로이드의 모든 쌍 최단 경로 알고리즘이다. 2. 플로이드 알고리즘 1234567AllPairsShortest입력: 2차원 배열 D, 단, D[i,j] = 선분 (i,j)의 가중치, 만일 선분 (i,j)이 존재하지 않으면 D[i,j] = ∞, 모든 i에 대해 D[i,j]=0이다.출력: 모든 쌍 최단 경로의 거리를 저장한 2차원 배열 Dfor k = 1 to n for i = 1 to n (단, i≠k) for j = 1 to n (단, j≠k, j≠i) D[i,j] = min&#123;D[i,k]+D[k,j],D[i,j]&#125; 배열 D의 원소들이 k가 1부터 5까지 증가함에 따라서 갱신되는 것을 살펴본다. k = 1일 때 : D[2,3] = min{D[2,1]+D[1,3], D[2,3]} = min{∞+2,1} = 1 D[2,4] = min{D[2,1]+D[1,4], D[2,4]} = min{∞+5,∞} = ∞ D[2,5] = min{D[2,1]+D[1,5], D[2,5]} = min{4,∞+∞} = 4 D[3,2] = min{D[3,1]+D[1,2], D[3,2]} = min{1+4,3} = 3 D[3,4] = min{D[3,1]+D[1,4], D[3,4]} = min{1+5,1} = 1 D[3,5] = min{D[3,1]+D[1,5], D[3,5]} = min{1+∞,2} = 2 D[4,2] = min{D[4,1]+D[1,2], D[4,2]} = min{-2+4,∞} = 2 // 갱신됨 (∞-&gt;2) D[4,3] = min{D[4,1]+D[1,3], D[4,3]} = min{-2+2,∞} = 0 // 갱신됨 (∞-&gt;0) D[4,5] = min{D[4,1]+D[1,5], D[4,5]} = min{-2+∞,2} = 2 D[5,2] = min{D[5,1]+D[1,2], D[5,2]} = min{∞+4,-3} = -3 D[5,3] = min{D[5,1]+D[1,3], D[5,3]} = min{∞+2,3} = 3 D[5,4] = min{D[5,1]+D[1,4], D[5,4]} = min{∞+5,1} = 1 즉, 모든 i,j에 대한 Dij1을 계산한 결과는 다음과 같다. k = 2일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij2을 계산한 결과는 다음과 같다. k = 3일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij3을 계산한 결과는 다음과 같다. k = 4일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij4를 계산한 결과는 다음과 같다. k = 5일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij5를 계산한 결과는 다음과 같다. (최종 해) 3. 시간 복잡도 3중 for문 -&gt; O(n3)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"동적계획","slug":"동적계획","permalink":"http://dudri63.github.io/tags/동적계획/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 동적 계획 알고리즘","slug":"algo18","date":"2019-01-26T11:02:09.000Z","updated":"2019-01-26T16:08:18.242Z","comments":true,"path":"2019/01/26/algo18/","link":"","permalink":"http://dudri63.github.io/2019/01/26/algo18/","excerpt":"","text":"‘동적 계획(Dynamic Programming)’ 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 동적 계획 알고리즘은 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다. 단, 분할 정복 알고리즘과는 달리 부분문제의 해를 중복 사용하기도 한다. 동적계획 알고리즘에는 부분문제들 사이에 의존적 관계가 존재한다. 이러한 관계는 문제 또는 알고리즘에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 ‘함축적인 순서(implicit order)’라고 한다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"동적계획","slug":"동적계획","permalink":"http://dudri63.github.io/tags/동적계획/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 허프만 압축 (그리디)","slug":"algo17","date":"2019-01-25T14:02:55.000Z","updated":"2019-01-26T10:55:29.741Z","comments":true,"path":"2019/01/25/algo17/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo17/","excerpt":"","text":"1. 허프만 압축2. 알고리즘3. 시간 복잡도 1. 허프만 압축 파일의 각 문자가 8bit 아스키(ASCII) 코드로 저장되면, 그 파일의 bit 수는 8 * (파일의 문자수)이다.즉, 파일의 각 문자는 고정된 크기의 코드로 표현된다.이러한 고정된 크기의 코드로 구성된 파일을 저장하거나 전송할 때 파일의 크기를 줄이고, 필요시 원래의 파일로 변환할 수 있으면,메모리 공간을 효율적으로 사용할 수 있고, 파일 전송 시간을 단축시킬 수 있다.주어진 파일의 크기를 줄이는 방법을 파일 압축(file compression)이라고 한다. 허프만(Huffman) 압축은 파일에 빈번히 나타나는 문자에는 짧은 이진 코드를 할당, 드물게 나타나는 문자에는 긴 이진 코드를 할당한다. 허프만 압축 방법으로 변환시킨 문자 코드들 사이에는 접두부 특성(Prefix Property)이 존재한다.이는 각 문자에 할당된 이진 코드는 어떤 다른 문자에 할당된 이진 코드의 접두부가 되지 않는다는 것을 의미.즉, 문자 ‘a’에 할당된 코드가 ‘101’이라면, 다른 모든 문자의 코드는 ‘101’로 시작되지 않으며 또한 ‘1’이나 ‘10’으로도 시작되지 않는다.접두부 특성을 가진 코드의 장점은 코드와 코드 사이를 구분할 특별한 코드가 필요 없다는 것이다.예를 들어. 101#100#0#111#…에서 ‘#’이 인접한 코드를 구분 짓는데, 허프만 압축에서는 이러한 특별한 코드가 필요 없이 파일을 압축 및 해제할 수 있다. 허프만 압축은 입력 파일에 대해 각 문자의 출현 빈도수에 기반을 둔 이진트리를 만든 뒤, 각 문자에 이진 코드를 할당한다. 이 때, 이 이진 코드를 허프만 코드라고 한다. 2. 알고리즘 다음은 파일 압축을 위한 허프만 코드를 찾기 위한 그리디 알고리즘이다.입력 파일에 대해 각 문자에 할당될 이진 코드를 추출할 이진 트리인 허프만 트리를 리턴한다.1234567891011HuffmanCoding입력: 입력 파일의 n개의 문자에 대한 각각의 빈도수출력: 허프만 트리각 문자에 대해 노드를 만들고, 그 문자의 빈도수를 노드에 저장한다.n개의 노드들의 빈도수에 대해 우선순위 큐 Q를 만든다.while (Q에 있는 노드 수 &gt;=2) &#123; 빈도수가 가장 작은 2개의 노드(A와 B)를 Q에서 제거한다. 새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다. 노드 N을 Q에 삽입한다.&#125;return Q // 허프만 트리의 루트를 리턴하는 것이다. 입력 파일이 4개의 문자로 구성되어 있고, 각 문자의 빈도수는 다음과 같다고 가정한다. A: 450 T: 90 G:120 C:270 Line 5 : 4개의 문자들의 빈도수에 대해 우선순위 Q를 만든다. Line 6 : while-루프 조건이 ‘참’이므로, Line 7~10을 수행한다.즉, Q에서 ‘T’와 ‘G’를 제거한 후, 새 부모 노드를 Q에 삽입한다. Line 6 : while-루프 조건 ‘참’, Line 7~10을 수행.즉, Q에서 ‘T’와 ‘G’의 ‘부모 노드’와 ‘C’를 제거한 후, 새 부모 노드를 Q에 삽입한다. Line 6 : while-루프 조건 ‘참’, Line 7~10을 수행.즉, Q에서 ‘c’의 ‘부모 노드’와 ‘A’를 제거한 후, 새 부모 노드를 Q에 삽입한다. Line 6 : while-루프 조건 ‘거짓’, Line 11에서 Q에 있는 노드를 리턴.즉, 허프만 트리의 루트가 리턴된다. 반환한 트리를 보면, 문자는 leaf 노드에만 존재한다.루트로부터 왼쪽 자식 노드로 내려가면 ‘0’, 오른쪽 자식 노드로 내려가면 ‘1’을 부여할 수 있다.그리하여 leaf 노드에 도착할 때까지 이진수를 추출, 문자의 이진코드를 구할 수 있다.빈도수가 가장 높은 ‘A’는 가장 짧은 코드인 ‘0’,빈도수가 가장 낮은 ‘T’는 가장 긴 코드인 ‘100’이 부여됐다.또한 이렇게 얻은 숫자에 대한 코드는 접두부 특성을 가지고 있다.(왜냐하면, leaf 노드에만 문자가 있고, 내부 노드에는 문자 없으며 코드를 부여하지 않았기 때문) 위 예제에서 압축된 파일의 bit 수는 (450*1)+(90*3)+(120*3)+(270*3) = 1620 bit이다.반면에 아스키 코드로 된 파일 크기는 (450+90+120+270)*8 = 7440 bit이다.압축률은 (1620/7440)*100 = 21.8%이다. 3. 시간 복잡도 line 4, n개의 노드생성, 각 빈도수를 노드에 저장, O(n)line 5, n개의 노드로 우선순위 큐 Q를 만듬. 힙 자료 구조 사용, O(n)line 6~10, 노드 2개를 Q에서 제거, 새 노드를 Q에 삽입하므로 O(long), while-루프는 (n-1)번 반복, (n-1)*O(logn) = O(nlogn)line 8, 트리의 루트를 리턴, O(1) 따라서 HuffmanCoding의 알고리즘은 O(nlogn) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 25, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 작업 스케줄링 (그리디)","slug":"algo16","date":"2019-01-25T13:56:10.000Z","updated":"2019-01-25T14:52:37.946Z","comments":true,"path":"2019/01/25/algo16/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo16/","excerpt":"","text":"1. 작업 스케줄링2. 알고리즘3. 시간 복잡도 1. 작업 스케줄링 기계에서 수행되는 n개의 작업 t1, t2, … tn이 있고, 각 작업은 시작시간과 종료시간이 있다.작업 스케줄링(Task Scheduling) 문제는 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정하는 문제이다. 작업 스케줄링 문제는 학술대회에서 발표자들을 강의실에 배정하는 문제와 같다. 작업 스케줄링 문제에 주어진 문제 요소들은 작업의 수, 각 작업의 시작시간과 종료시간이다.작업의 시작시간과 종료시간은 정해져 있으므로 작업의 길이도 주어진 것이다.그리하여 시작시간, 종료시간, 작업 길이에 대해 다음과 같은 그리디 알고리즘들을 생각할 수 있다. 빠른 시작시간 작업을 우선(Earliest start time first) 배정 빠른 종료시간 작업을 우선(Earliest finish time first) 배정 짧은 작업 우선(Shortest job first) 배정 긴 작업을 우선(Longest job first) 배정 위 4가지 알고리즘들 중 첫 번째 알고리즘을 제외, 나머지 3가지 알고리즘은 항상 최적해를 찾지 못한다.(추후 공부 필요) 2. 알고리즘 다음은 작업 스케줄링 문제를 위한 빠른 시작시간 작업을(Earilest start time first) 우선 배정하는 그리디 알고리즘이다. 12345678910111213JobScheduling입력: n개의 작업 t1, t2, ... , tn출력: 각 기계에 배정된 작업 순서시작시간의 오름차순으로 정렬한 작업 리스트를 L이라고 한다.while (L ≠ ∅) &#123; L에서 가장 이른 시작시간을 가진 작업 ti를 가져온다. if (ti를 수행할 기계가 있으면) ti를 수행할 수 있는 기계에 배정한다. else 새로운 기계에 ti를 배정한다. ti를 L에서 제거한다.&#125;return 각 기계에 배정된 작업 순서 t1 = [7,8],t2 = [3,7],t3 = [1,5],t4 = [5,9],t5 = [0,2],t6 = [6,8],t7 = [1,6]과 같은 작업 이 있다고 가정한다. 단, [s,f]에서 s는 시작시간, f는 종료시간이다. Line 4 : L = {[0,2], [1,6], [1,5], [3,7], [5,9], [6,8], [7,8]}이다. Line 5~11 : while-루프를 반복 수행하면서 각 작업이 적절한 기계에 배정된다. 이 경우 최적해는 3대의 기계에 모든 작업을 마지막 그림과 같이 배정하는 것이다. 3. 시간 복잡도 Line 4에서 n개의 작업을 정렬하는 데 O(nlogn) 시간이 걸린다.while-루프에서 작업을 L에서 가져다가 수행 가능한 기계를 찾아 배정하므로 O(m)이 걸린다.(m은 사용된 기계의 수)while-루프가 수행된 총 횟수는 n번이므로, line 5~12까지는 O(m)*n = O(mn) 시간이 걸린다.따라서 O(nlogn) + O(nm)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 집합 커버 문제 (그리디)","slug":"algo15","date":"2019-01-25T12:24:18.000Z","updated":"2019-01-25T13:57:06.037Z","comments":true,"path":"2019/01/25/algo15/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo15/","excerpt":"","text":"1. 집합 커버 문제2. 알고리즘3. 시간 복잡도 1. 집합 커버 문제 n개의 원소를 가진 집합인 U가 있고, U의 부분 집합들을 원소로 하는 집합 F가 주어질 때, F의 원소들인 집합들 중에서 어떤 집합들을 선택하여 합집합하면 U와 같게 되는가?집합 커버(Set Cover) 문제는 F에서 선택하는 집합들의 수를 최소화하는 문제이다. 다음은 신도시를 계획함에 있어서 학교를 배치하는 문제이다. 위 그림과 같이 신도시에 10개의 마을이 만들어질 계획이다.이 때, 아래의 2가지 조건이 만족되도록 학교의 위치를 선정하여야 한다고 가정한다. 학교는 마을에 위치한다. 등교 거리는 걸어서 15분 이내여야 한다. 어느 마을에 학교를 신설해야 학교의 수가 최소로 될 것인가?2번 마을에 학교를 만들면 마을 1, 2, 3, 4, 8이 커버된다.또한, 6번 마을에 학교를 만들면 마을 5, 6, 7, 9, 10이 커버된다.즉, 2번과 6번을 선택하면 학교 수를 최소로 신설할 수 있다. 위 신도시 계획 문제를 집합 커버 문제로 변환하면 아래와 같다. U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} // 신도시의 마을 10개F = {S1, S2, S3, S4, S5, S6, S7, S8, S9, S10}S1 = {1, 2, 3, 8}S2 = {1, 2, 3, 4, 8}S3 = {1, 2, 3, 4}S4 = {2, 3, 4, 8}S5 = {4, 5, 6, 7}S6 = {5, 6, 7, 9, 10}S7 = {4, 5, 6, 7}S8 = {1, 2, 4, 8}S9 = {6, 9}S10 = {6, 10} Si 집합들 중에서 어떤 집합들을 선택하여야 그들의 합집합이 U와 같은가?(단, 선택된 집합의 수는 최소이어야 한다.)답은 S2 ∪ S6 = {1, 2, 3, 4, 8} ∪ {5, 6, 7, 9, 10} = {1, 2, 3, 4, 5, 6, 7, 8, 9 10} = U 집합 커버 문제의 최적해를 찾는 가장 간단한 방법은 F에 있는 집합들의 모든 조합을 하나씩 합집합하여 U가 되는지 확인, U가 되는 조합의 집합 수가 최소인 것을 찾는 것이다.그런데 이 경우 F에 n개의 원소가 있으면 (2n-1)개를 다 검사, n이 커지면 최적해를 찾는 것은 실질적으로 불가능하다. 이를 극복하기 위한 방법은 최적해를 찾는 대신 최적해에 근사한 근사해(Approximation Solution)을 찾는 것이다. 2. 알고리즘 다음은 집합 커버 문제를 위한 근사 알고리즘이다. 12345678910SetCover입력: U, F=&#123;Si&#125;, i=1,2,...,n출력: 집합 커버 CC = ∅while (U ≠ ∅) do &#123; U의 원소들을 가장 많이 포함하고 있는 집합 Si를 F에서 선택한다. U = U - Si Si를 F에서 제거하고, Si를 C에 추가한다.&#125;return C 위 신도시 계획 문제에 이 알고리즘을 적용한다. Line 4 : C = ∅로 초기화한다. Line 5 : while-조건 (U ≠ ∅)을 만족한다. Line 6 : U의 원소들을 가장 많이 커버하는 집합인 S4를 F에서 선택한다. Line 7 : U - S4 = {1, 6, 9, 10} Line 8 : S4를 F에서 제거, 즉, F = {S1, S2, S3, S5, S6, S7, S8, S9, S10},S4를 C에 추가, 즉, C = {S4} Line 5 : while-조건 만족 Line 6 : U의 원소들을 가장 많이 커버하는 집합인 S6를 F에서 선택. Line 7 : U = S6 = {1] Line 8 : S6를 F에서 제거, F = {S1, S2, S3, S5, S7, S8, S9, S10},S6를 C에 추가, C = {S4, S6} Line 5 : while-조건 만족 Line 6 : U의 원소들을 가장 많이 커버하는 집합인 S1을 F에서 선택.(S2, S3, S8을 선택해도 무방) Line 7 : U = ∅ Line 8 : S1을 F에서 제거,S1을 C에 추가, C = {S1, S4, S6} Line 5 : while-조건 불만족 Line 9 : C={S1, S4, S6}를 리턴 3. 시간 복잡도 Line 5 : while-루프 조건 검사 시간 O(1)Line 6 : Si 각각을 U와 비교하여야 한다. Si들의 수가 최대 n이라면, O(n2) 시간Line 7 : 집합 U에서 집합 Si의 원소를 제거, O(n) 시간이 걸린다.Line 8 : Si를 F에서 제거, Si를 C에 추가, O(1) 시간이 걸린다.따라서 루프 1회의 시간 복잡도는 O(1)+O(n2)+O(n)+O(1) = O(n2)이다.그러므로 SetCover 알고리즘의 시간복잡도는 O(n)*O(n2) = O(n3) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 부분 배낭 문제 (그리디)","slug":"algo14","date":"2019-01-25T11:21:08.000Z","updated":"2019-01-25T12:23:57.460Z","comments":true,"path":"2019/01/25/algo14/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo14/","excerpt":"","text":"1. 부분 배낭 문제2. 알고리즘3. 시간 복잡도 1. 부분 배낭 문제 배낭(Knapsack) 문제는 n개의 물건이 있고, 각 물건은 무게와 가치를 가지고 있을 때, 최대의 가치를 갖도록 한정된 용량의 배낭에 넣을 물건들을 정하는 문제이다.원래의 배낭 문제는 물건을 통째로 배낭에 넣어야 하는 것에 반해,부분 배낭(Fractional Knapsack) 문제는 물건을 부분적으로 담는 것이 허용 된다. 부분 배낭 문제에서는 물건을 부분적으로 배낭에 담을 수 있으므로, 최적해을 위해서 ‘욕심을 내어’ 단위 무게당 가장 값나가는 물건을 배낭에 넣고, 계속해서 그 다음으로 값나가는 물건을 넣는다. 그런데 만일 그 다음으로 값나가는 물건을 ‘통째로’ 배낭에 넣을 수 없게 되면, 배낭에 넣을 수 있을 만큼만 물건을 부분적으로 배낭에 담도록 한다. 2. 알고리즘 다음은 부분 배낭 문제를 위한 그리디 알고리즘이다. 12345678910111213141516171819FractionalKnapsack입력: n개의 물건과 각 물건의 무게와 가치, 배낭의 용량 C출력: 배낭에 담은 물건 리스트 L과 배낭에 담은 물건의 가치 합 v각 물건의 단위 무게당 가치를 계산.물건들을 단위 무게당 가치를 기준으로 내림차순으로 정렬, 정렬된 물건 리스트를 S라고 한다.L=∅, w=0, v=0 // L: 배낭에 담을 물건 리스트, w: 배낭에 담긴 물건들의 무게의 합, v: 배낭에 담긴 물건들의 가치의 합S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다.while((w + x의 무게)&lt;=C)&#123; x를 L에 추가시킨다. w = w + x의 무게 v = v + x의 가치 x를 S에서 제거한다. S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다.&#125;if ((C-w) &gt; 0) &#123; // 배낭에 물건을 부분적으로 더 담을 여유가 있으면 물건 x를 (C-w)만큼만 L에 추가한다. v = v + (C-w)만큼의 x의 가치&#125;return L, v 위와 같은 4개의 금속 분말이 있고, 배낭의 최대 용량(C)이 40g이라고 가정한다.FractionalKnapsack 알고리즘의 수행 과정은 다음과 같다. Line 4 : 단위 무게당 가치, 주석 1천원, 백금 6만원, 은 4천원, 금 5만원 Line 5 : S = {백금,금,은,주석} Line 6 : L=∅, w=0, v=0로 각각 초기화한다. Line 7 : S에서 단위 무게당 가장 큰 물건인 백금을 x로서 가져온다. Line 8 : w + x의 무게 = 10g &lt; C = 40g 으로 while-문 조건을 만족한다. Line 9 : 백금 x를 L에 추가, L = {백금} Line 10 : w = 0 + 10g = 10g Line 11 : v = 0 + 60만원 = 60만원 Line 12 : S = {금,은,주석} Line 13 : S에서 금을 x로서 가져온다. Line 8 : w + x의 무게 = 10g + 15g &lt; C = 40g, while-문 조건 만족 Line 9 : L ={백금, 금} Line 10 : w = 10g + 15g = 25g Line 11 : v = 60만원 + 75만원 = 135만원 Line 12 : S = {은,주석} Line 13 : S에서 은을 x로서 가져온다. Line 8 : w + x의 무게 = 25g + 25g = 50g &gt; C = 40g, while-문 조건 만족X Line 15 : C-w = 40g - 25g = 15g &gt; 0, if-문 조건 만족 Line 16 : 물건 x인 은을 (C-w) = 15g만큼만 L에 추가, L = {백금,금,은} Line 17 : v = 135만원 + (C-w)만큼의 x의 가치 = 135만원 + 15X4천원 = 141만원 Line 19 : L = {백금, 금, 은}, v = 141만원 반환 3. 시간 복잡도 Line 4에서 n개의 물건 단위 무게당 가치를 계산하는 데 O(n) 시간이 걸림.Line 5에서 물건의 단위 무게당 가치에 대해 정렬하므로 O(nlogn) 시간이 걸림.Line 8~13의 while-루프의 수행은 n번을 넘지 않으며, 루프 내부의 수행은 O(1) 시간,Line 14~17, O(1) 시간이 걸림. 따라서 O(n) + O(nlogn) + n*O(1) + O(1) = O(nlogn) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Python] PEP, 객체","slug":"python4","date":"2019-01-22T11:02:13.000Z","updated":"2019-01-28T14:13:08.764Z","comments":true,"path":"2019/01/22/python4/","link":"","permalink":"http://dudri63.github.io/2019/01/22/python4/","excerpt":"","text":"1. PEP2. 객체 1. PEP 파이썬은 수많은 사람들이 의견을 수용하고 토론하며 발전해온 언어이다.언어 발전을 위해 논의된 주제를 PEP라는 이름으로 문서화해왔다.수많은 PEP 문서들이 있는데, 개발자들마다 작성한 코드 스타일이 다르다.그렇기 때문에 대부분은 PEP 8문서를 통해 권장하는 파이썬 스타일을 학습한다. 2. 객체 파이썬은 모든 것이 객체(Object)로 이루어져 있다.객체란 ‘어떠한 속성(attribute)값과 행동(method)을 가지고 있는 데이터’이다.파이썬의 존재하는 숫자, 문자, 함수 등은 여러 속성과 행동을 가지고 있는 데이터이다. 예를들어, 문자 ‘a’는 파이썬에서 단순하게 문자를 표현되는 것으로 끝나지 않는다.a.join, a.upper와 같이 문자 자체를 객체로 만들고 다양한 속성과 행동을 넣을 수 있다. 이러한 프로그래밍 기법을 객체지향 프로그래밍이라고 한다.객체지향 프로그래밍은 해결할 문제를 실제의 세계처럼 다양한 정보들을 가진 객체로 표현하고, 객체들 간의 통신으로 해결하는 기법이다. 2.1 객체의 타입, 클래스 파이썬에서 객체의 타입(type)은 객체를 어떤 클래스(Class)로 만들어졌는냐에 따라 결정된다.클래스는 객체를 만드는 일종의 틀이다.클래스는 생성할 객체들의 속성과 행동을을 정의하는 공간이고,객체끼리 서로 같은 타입을 가진다면 같은 속성과 행동을 가지게 된다.타입의 예로는 int, float, str 등이 있다. Reference 2.파이썬은 객체로 이뤄져잇다, 제대로 파이썬, 2019. 1. 22, https://wikidocs.net/21733, https://wikidocs.net/20456, https://wikidocs.net/20457, https://wikidocs.net/21719,","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 입력과 출력, 논리 연산, 주석","slug":"python3","date":"2019-01-22T10:32:22.000Z","updated":"2019-01-22T11:41:52.221Z","comments":true,"path":"2019/01/22/python3/","link":"","permalink":"http://dudri63.github.io/2019/01/22/python3/","excerpt":"","text":"1. 입력과 출력2. 논리 연산3. 주석 (Comment) 1. 입력과 출력 12in_str = input(&quot;입력해주세요.\\n&quot;)print(in_str.upper()+&quot; World!&quot;) input() 사용자가 입력한 값을 반환하는 함수 입력할 값에 대한 안내를 출력할 수도 있다. 사용자가 입력한 값은 문자열로 취급 입력한 값을 정수로 저장하고 싶다면 int() 함수를 이용한다.ex. x = int(input(“숫자를 입력해주세요.\\n”)) string.upper() : 문자열을 대문자로 변환하여 반환string.lower() : 문자열을 소문자로 변환하여 반환 123456789in_str = input(&quot;아이디를 입력해주세요.\\n&quot;)real_egoing = &quot;11&quot;real_k8805 = &quot;ab&quot;if real_egoing == in_str: print(&quot;Hello!, egoing&quot;)elif real_k8805 == in_str: print(&quot;Hello!, k8805&quot;)else: print(&quot;Who are you?&quot;) 2. 논리 연산 1234567in_str = input(&quot;아이디를 입력해주세요.\\n&quot;)real_egoing = &quot;egoing&quot;real_k8805 = &quot;k8805&quot;if real_egoing == in_str or real_k8805 == in_str: print(&quot;Hello!&quot;)else: print(&quot;Who are you?&quot;) if를 중첩해서 사용한 경우1234567891011input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)input_pwd = input(&quot;비밀번호를 입력해주세요.\\n&quot;)real_id = &quot;egoing&quot;real_pwd = &quot;11&quot;if real_id == input_id: if real_pwd == input_pwd: print(&quot;Hello!&quot;) else: print(&quot;잘못된 비밀번호입니다&quot;)else: print(&quot;잘못된 아이디입니다&quot;) and로 통합한 경우12345678input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)input_pwd = input(&quot;비밀번호를 입력해주세요.\\n&quot;)real_id = &quot;egoing&quot;real_pwd = &quot;11&quot;if real_id == input_id and real_pwd == input_pwd: print(&quot;Hello!&quot;)else: print(&quot;로그인에 실패했습니다&quot;) 3. 주석(Comment) 파이썬에서 주석 사용은 다음과 같다. ‘’’~’’’ : ‘’’ 사이에 주석을 작성(‘은 아포스트로피) #~ : # 뒤에 주석을 작성 Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/1750/9681, https://opentutorials.org/course/1750/9619, https://opentutorials.org/course/1750/9626","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 변수, 비교, 조건문","slug":"python2","date":"2019-01-22T01:49:38.000Z","updated":"2019-01-30T10:25:31.518Z","comments":true,"path":"2019/01/22/python2/","link":"","permalink":"http://dudri63.github.io/2019/01/22/python2/","excerpt":"","text":"1. 변수2. 비교(Boolean) 1. 변수 Python은 C언어를 비롯한 다른 언어들과는 다르게 변수 선언을 미리 하지 않고도, 변수에 데이터를 저장할 수 있다.123456x=10 # 정수형 변수y=5print(x+y) title = &quot;python &amp; ruby&quot; # 문자열형 변수print(&quot;Title is &quot;+title) 1.1 문자열에서 변수의 사용1234name = &quot;서영기&quot;print(&quot;안녕하세요. &quot;+name+&quot;님&quot;) # 두 문자열을 합친 결과를 출력print(name+&quot;님을 위한 강의를 준비했습니다.&quot;)print(name+&quot;님 꼭 참석 부탁드립니다.&quot;) 1.2 수 계산에서 변수의 사용1234donation = 200student = 10sponsor = 100print((donation*student)/sponsor) 2. 비교(Boolean) bool연산(boolean)의 결과를 확인할 수 있다.12345678a=1b=1print(a==b)print(1==2)print(1&gt;2)print(1&lt;2)print(True)print(False) 3. 조건문(Conditional Statement) 1234if True: # true라고 쓰면 오류 print(&quot;code1&quot;) print(&quot;code2&quot;)print(&quot;code3&quot;) 1234if False: # false라고 쓰면 오류 print(&quot;code1&quot;) print(&quot;code2&quot;)print(&quot;code3&quot;) if 조건문에 포함되어 있는 것들은 “code1”, “code2” 문자열을 각각 출력하는 print() 함수이다. 조건이 True일 때 if 조건문 내부에 있는 것들이 동작, Flase일 때 조건문 내부에 있는 것들이 동작하지 않음을 알 수 있다. 그리고 code3 문자열을 출력하는 print() 함수는 조건문 내부에 포함되어 있지 않다. 1234input = 11real = 11if real == input: print(&quot;Hello!&quot;) 123456input = 11real = 11if real == input: print(&quot;Hello!&quot;)else: print(&quot;Who are you?&quot;) 123456input = 11real = 12if real == input: print(&quot;Hello!&quot;)else: print(&quot;Who are you?&quot;) 123456789input = &quot;ab&quot;real_egoing = 11real_k8805 = &quot;ab&quot;if real_egoing == input: print(&quot;Hello!, egoing&quot;)elif real_k8805 == input: print(&quot;Hello!, k8805&quot;)else: print(&quot;Who are you?&quot;) else if를 elif 라고 함을 주의하자. 또한, 문자열 비교도 가능한 것을 알 수 있다. Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/1750/9616, https://opentutorials.org/course/1750/9618, https://opentutorials.org/course/1750/9620","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 실행, 수와 계산, 문자 및 문자열","slug":"python1","date":"2019-01-21T03:40:35.000Z","updated":"2019-01-30T10:24:57.011Z","comments":true,"path":"2019/01/21/python1/","link":"","permalink":"http://dudri63.github.io/2019/01/21/python1/","excerpt":"","text":"1. Execution2. 수와 계산3. 문자 및 문자열 1. Execution 1.1 대화형 모드로 실행 터미널에서 python3를 입력한다. 1.2 파일 모드로 실행 대화형 모드로 간단하게 코드를 작성하기는 편리하지만, 크고 많은 양의 코드를 작성하는 것은 어려움. 따라서 파일을 사용하여 실행한다.windows의 경우, 메모장, linux의 경우 gedit을 사용할 수 있다. gedit을 연 뒤, 코드 작성, 확장자를 *.py로 하여 저장한다.이 후, $ python3 명령어 뒤에 경로 및 파일이름, 확장자를 실행한다. 2. 수와 계산 1234print(10 + 5)print(10 - 5)print(10 * 5)print(10 / 5) 12345import mathprint(math.ceil(2.2)) # ceil : 소수점 이하를 올림print(math.floor(2.7)) # floor : 소수점 이하를 버림print(math.pow(2,10)) # 2^10, pow : 제곱print(math.pi) # pi : 3.14 math 모듈을 가져오고, 해당 모듈을 이용하여 위와 같은 연산을 실시할 수 있다. 3. 문자 및 문자열 1234print(&apos;Hello&apos;)print(&quot;Hello&quot;)print(&quot;Hello &apos;world&apos;&quot;)print(&apos;Hello &quot;world&quot;&apos;) 12345print(&apos;Hello &apos;+&apos;world&apos;) # 두 문자열을 합친 결과를 출력print(&apos;Hello &apos;*3) # 해당 문자열을 3회 출력print(&apos;Hello&apos;[0]) # 해당 문자열(배열)의 특정 원소를 출력print(&apos;Hello&apos;[1])print(&apos;Hello&apos;[2]) 12345print(&apos;hello world&apos;.capitalize()) # 문자열의 첫 글자를 대문자로 변경print(&apos;hello world&apos;.upper()) # 문자열이 모든 문자를 대문자로 변경print(&apos;hello world&apos;.__len__()) # 문자열의 길이를 출력print(len(&apos;hello world&apos;))print(&apos;Hello world&apos;.replace(&apos;world&apos;, &apos;programming&apos;)) # 특정 문자열을 다른 문자열로 변경 123456print(&quot;egoing&apos;s \\&quot;tutorial\\&quot;&quot;) # &quot;를 문자로서 출력하기 위해 \\(escape)를 사용print(&quot;\\\\&quot;) # 첫번째 \\은 뒤의 \\의 임무(escape)를 해제print(&quot;Hello\\nworld&quot;) # \\: 줄바꿈print(&quot;Hello\\t\\tworld&quot;) # \\t: 탭print(&quot;\\a&quot;) # \\a: 경고음을 출력print(&apos;Hello\\nworld&apos;) 12print(10+5) # 수의 합을 출력print(&quot;10&quot;+&quot;5&quot;) # 문자열의 합을 출력 Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/1750/9612, https://opentutorials.org/course/1750/9614, https://opentutorials.org/course/1750/9615","categories":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Git] GitHub (2)","slug":"git12","date":"2019-01-21T02:36:03.000Z","updated":"2019-01-21T03:23:44.085Z","comments":true,"path":"2019/01/21/git12/","link":"","permalink":"http://dudri63.github.io/2019/01/21/git12/","excerpt":"","text":"1. 원격 저장소 생성2. 원격 저장소에 push 1. 원격 저장소 생성 깃허브에 로그인한다. new repository 버튼을 클릭한다. 저장소 이름을 설정한다. public / private option을 설정한다. readme (프로젝트에 대한 설명) 파일 생성 여부를 설정한다. 저장소를 생성한다. https를 선택 및 저장소의 고유 주소를 확인한다. 2. 원격 저장소에 push $ git remote add ‘별명’ ‘경로’ 명령어를 실행하여 생성한 저장소 주소의 별명을 설정하고, 원격 저장소로서 설정한다. $ git push ‘별명’ ‘branch 이름’ 명령어를 실행하여 origin이 가리키는 원격 저장소의 master branch에 현재 지역 저장소의 branch를 push한다.-u : 서로 연결할 때, 최초 1회 사용한다. 이후에는 git push만 해도 위 설정대로 push하게 된다. 위 페이지와 같이 원격저장소에 성공적으로 push된 것을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/2708/15426","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"},{"name":"원격 저장소","slug":"원격-저장소","permalink":"http://dudri63.github.io/tags/원격-저장소/"},{"name":"GitHub","slug":"GitHub","permalink":"http://dudri63.github.io/tags/GitHub/"}]},{"title":"[Git] GitHub (1)","slug":"git11","date":"2019-01-21T01:49:56.000Z","updated":"2019-01-26T16:10:45.847Z","comments":true,"path":"2019/01/21/git11/","link":"","permalink":"http://dudri63.github.io/2019/01/21/git11/","excerpt":"","text":"1. GitHub란2. GitHub 둘러보기3. GitHub 프로젝트 가져오기 1. GitHub란 ‘깃허브(GitHub)’는 분산 버전 관리 툴인 깃을 사용하는 프로젝트를 지원하는 웹호스팅 서비스이다. 다른 말로, 자신의 서버를 직접 운영하지 않고도, 온라인 서비스를 이용하여 원격 저장소를 사용할 수 있게 해주는 웹 서비스이다. 2. GitHub 둘러보기(‘git’ project) GitHub 홈페이지에서 git을 검색하여 git/git 항목으로 접속한다.위와 같이 git이라는 오픈 소스 프로젝트의 원격 저장소를 볼 수 있다.상위 리스트들의 수치가 의미하는 바는 다음과 같다. 54,244 commits : 총 54,244번의 commit으로 현재까지 옴 (매우 큰 프로젝트) 5 branches : 5개의 branch가 있음 1240 contributors : 소스 코드에 접근하여 수정할 수 있는 인원 Fork 14,817 : 다른 사람들에 의해 fork한 횟수 cf. fork 버튼을 누르면 이 프로젝트 나의 것이 된다. contributor에 속하지 않아도 코드를 수정할 수 있다. 그러나 해당 프로젝트의 소스 코드를 수정하는 것이 아니라, 나의 저장소로 복제된 코드를 수정하는 것이다. fork 숫자가 높을수록 높은 영향력을 지닌 개발자의 코드이다. 3. Github 프로젝트 가져오기 위 페이지에서 ‘Clone or download’라고 쓰인 초록색 버튼을 클릭하면, 주소가 나오는데 이를 복사한다.이 후, 터미널에서 적당한 디렉토리로 이동한다.1$ git clone &apos;주소&apos; &apos;디렉토리 이름&apos; 위와 같은 명령어를 실행하면 해당 디렉토리 이름으로 저장소를 만들고 그 곳의 주소가 가리키는 것들을 복사하여 저장한다. gitsrc라는 저장소 생성 및 해당 저장소에 git 프로젝트를 복사하였다.$git log 명령어를 실행하여 git 프로젝트의 commit history를 파악할 수 있다. 1$ git log --reverse // commit을 과거순으로 확인 가능 $ git log –reverse 명령어를 실행하여 가장 상위에 있는 commit(최초의 commit) ID를 복사한다. 최초의 commit으로 checkout한 뒤, $ls -al 명령어를 실행하여 git 프로젝트의 최초 코드를 확인할 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/2708/15426","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"},{"name":"원격 저장소","slug":"원격-저장소","permalink":"http://dudri63.github.io/tags/원격-저장소/"},{"name":"GitHub","slug":"GitHub","permalink":"http://dudri63.github.io/tags/GitHub/"}]},{"title":"[Algorithm] 최단 경로 찾기 (그리디)","slug":"algo13","date":"2019-01-21T01:26:27.000Z","updated":"2019-01-24T10:11:12.009Z","comments":true,"path":"2019/01/21/algo13/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo13/","excerpt":"","text":"1. 최단 경로 찾기1. 다익스트라 알고리즘1. 시간 복잡도1. 응용 1. 최단 경로 찾기 최단 경로(Shortest Path) 문제는 주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제이다. 최단 경로를 찾는 가장 대표적인 그리디 알고리즘은 다익스트라(Dijkstra) 최단 경로 알고리즘이다. 다익스트라 알고리즘은 프림의 최소 신장 트리 알고리즘과 거의 흡사한 과정으로 진행된다. 차이점은 다음과 같다. 프림 알고리즘은 임의의 점에서 시작하지만, 다익스트라 알고리즘은 주어진 출발점에서 시작 프림 알고리즘은 트리에 하나의 점, 선분을 추가시킬 때 현재 상태의 트리에서 가장 가까운 점을 추가시키지만, 다익스트라 알고리즘은 출발점으로부터 최단거리가 확정되지 않은 점들 중 출발점으로부터 가장 가까운 점을 추가, 그 점의 최단 거리를 확정 2. 다익스트라 알고리즘 다음은 다익스트라 최단 경로 알고리즘이다. 단, 입력 그래프는 양수의 가중치 그래프로서 하나의 연결요소로 되어 있다. 또한, s는 출발점이다.12345678ShortestPath(G, s)입력: 가중치 그래프 G=(V,E), |V|=n(점의 수), |E|=m(선분의 수)출력: 출발점 s로부터 (n-1)개의 점까지 각각 최단 거리르 저장한 배열 D배열 D를 ∞로 초기화한다. 단, D[s]=0으로 초기화한다. // 배열 D[v]에는 출발점 s로부터 점 v까지의 거리로 저장된다.while (s로부터의 최단 거리가 확정되지 않은 점이 있으면)&#123; 현재까지 s로부터 최단 거리가 확정되지 않은 각 점 v에 대해 최소의 D[v]의 값을 가진 점 vmin을 선택, 출발점 s로부터 vmin까지의 최단 거리 D[vmin]을 확정시킨다. s로부터 현재보다 짧은 거리로 점 vmin을 통해 우회 가능한 각 점 w에 대해서 D[w]를 갱신한다.&#125;return D 위와 같이 서울에서부터 각 지역까지 최단 거리를 알 수 있다. 3. 시간 복잡도 ShortestPath 알고리즘은 while-루프가 (n-1)번 반복되고, 1회 반복될 때 line 6에서 최소의 D[v]를 가진 점 vmin을 찾는 데 O(n) 시간이 걸린다.(입력만큼 비교)또한 line 7에서 vmin에 연결된 점의 수가 최대 (n-1)개이므로, 각 D[w]를 갱신하는 데 걸리는 시간은 O(n이다.)따라서 시간복잡도는 (n-1)X{O(n)+O(n)}=O(n2)이다. 4. 응용 최단 경로 알고리즘은 구글 웹사이트의 지도 서비스에서 사용된다.또한, 자동차 네비게이션, 네트워크 및 통신 분야, 로봇 공학 등에 널리 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 최소 신장 트리 (그리디)","slug":"algo12","date":"2019-01-20T20:50:19.000Z","updated":"2019-01-24T09:32:51.477Z","comments":true,"path":"2019/01/21/algo12/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo12/","excerpt":"","text":"1. 최소 신장 트리란2. 크러스컬 알고리즘3. 크러스컬 알고리즘의 시간복잡도4. 프림 알고리즘5. 프림 알고리즘의 시간복잡도6. 응용 1. 최소 신장 트리란 최소 신장 트리(Minimum Spanning Tree)란 주어진 가중치 그래프에서 사이클 없이 모든 점들을 연결시킨 트리들 중 선분들의 가중치 합이 최소인 트리이다. 위 경우에서 (a)를 주어진 가중치 그래프라고 가정한다.(점들끼리 연결된 선분들마다 가중치(숫자)가 다른 그래프이다.) (b) 최소 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 이러한 종류의 트리들 중 가중치의 합이 최소임. (c) 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 단, 이러한 종류의 트리들 중 가중치의 합이 최소는 아님. (d) 부분그래프 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시키지 못함. 그래프의 점의 수가 n이면, 신장 트리에는 정확히 (n-1)개의 선분이 있다. 만일 (n-1)개의 선분보다 많다면, 반드시 사이클이 만들어져 신장 트리가 아니게 된다. 최소 신장 트리를 찾는 대표적인 그리디 알고리즘은 크러스컬(Kruskal)과 프림(prim) 알고리즘이다. 2. 크러스컬 알고리즘 다음은 크러스컬 알고리즘이다.크러스컬 알고리즘은 가중치가 가장 적은 선분이 사이클을 만들지 않을 때에만 ‘욕심 내어’ 그 선분을 추가시킨다.단, 알고리즘의 입력은 1개의 연결요소로 된 가중치 그래프이다.(cf. 연결요소) 12345678910111213KruskalMST(G)입력: 가중치 그래프 G=(V,E), |V|=n (점의 수), |E|=m (선분의 수)출력: 최소 신장 트리 T가중치의 오름차순으로 선분들을 정렬한다. 정렬된 선분 리스트를 L이라고 하자.T=∅ // 트리 T를 초기화시킨다.while (T의 선분 수 &lt; n-1) &#123; L에서 가장 작은 가중치를 가진 선분 e를 가져오고, e를 L에서 제거한다. if (선분 e가 T에 추가되어 사이클을 만들지 않으면) e를 T에 추가시킨다. else // e가 T에 추라되어 사이클이 만들어지는 경우 e를 버린다.&#125;return 트리 T // 이 때, T는 최소 신장 트리이다. 3. 크러스컬 알고리즘의 시간복잡도 Line 4에서 선분들을 가중치를 기준으로 정렬하는데 O(mlogm)의 시간이 걸린다.(이 때, m은 입력 그래프에 있는 선분의 수이다.)Line 5에서는 T를 초기화하므로 O(1) 시간이 걸린다.Line 6~11에서는 그래프의 선분을 검사하는데, 이 때, 선분의 수만큼 m번 수행된다.(최악의 경우)또한, while-루프 내에서는 L로부터 가져온 e가 사이클을 만드는지를 검사하는데, O(log*m) 시간이 걸린다.따라서 크러스컬 알고리즘의 시간복잡도는 O(mlogm)+O(mlog*m) = O(mlogm)이다. 4. 프림 알고리즘 다음은 프림 알고리즘이다.프림 알고리즘은 주어진 가중치 그래프에서 임의의 점 하나를 선택한 후, (n-1)개의 선분을 하나씩 추가시켜 트리를 만든다. 현재까지 만들어진 트리에 새로운 선분을 추가하면서 연결시킬 때 ‘욕심 내어서’ 항상 최소의 가중치로 연결되는 선분을 추가시킨다.단, 알고리즘의 입력은 1개의 연결요소로 된 가중치 그래프이다. 12345678910111213141516171819PrimMST(G)입력: 가중치 그래프 G=(V,E), |V|=n(점의 개수), |E|=m(선분의 개수)출력: 최소 신장 트리 T그래프 G에서 임의의 점 p를 시작점으로 선택, D[p]=0 // D[v]는 T에 있는 점 u, v를 연결하는 선분의 최소 가중치를 저장for (점 p가 아닌 각 점 v에 대하여)&#123; // 배열 D의 초기화 if (선분 (p,v)가 그래프에 있으면) D[v] = 선분 (p,v)의 가중치 else D[v] = ∞&#125;T&#123;p&#125; // 초기에 트리 T는 점 p만을 가진다.while (T에 있는 점의 수 &lt; n) &#123; T에 속하지 않은 각 점 v에 대하여, D[v]가 최소인 점 vmin과 연결된 선분 (u,vmin)을 T에 추가한다. 단, u는 T에 속한 점이고, 이 때 점 vmin도 T에 추가된다. for (T에 속하지 않은 각 점 w에 대해서)&#123; if (선분(vmin, w)의 가중치 &lt; D[w]) D[w] = 선분 (vmin, w)의 가중치 // D[w]를 갱신한다. &#125;&#125;return T 위 그림에 프림 알고리즘을 적용한다. Line 4: 임의로 점 c를 선택, D[c]=0 Line 5~9: 시작점 c와 선분으로 연결된 각 점 v에 대해 D[v]를 각 선분의 가중치로 초기화, 나머지 각 점 w에 대해 D[w]는 ∞로 초기화D[a]=∞, D[b]=1, D[c]=0, D[d]=∞, D[e]=∞, D[f]=1 Line 10: T={c}로 초기화 Line 11: 현재 T에는 점 c만 있으므로 루프 조건 ‘참’ Line 12: T에 속하지 않은 각 점 v에 대해 D[v]가 최소인 점 vmin을 선택. 단, 이 경우, D[b]=D[f]=1로서 최소값이므로 점 b나 점 f 중 하나를 선택. 점 b를 선택한 상황을 가정한다. 점 b와 선분 (c,b)를 T에 추가T={c, b, (c,b)} Line 13~15: 점 b에 연결된 점 a와 d의 D[a]와 D[b]를 각각 3, 4로 갱신. 점 f는 점 b와 선분으로 연결되어 있으나 선분 (b,f)의 가중치인 2가 현재 D[f]=1보다 크므로 D[f]를 갱신 안함D[a]=3, D[b]=1, D[c]=∞, D[d]=4, D[e]=∞, D[f]=1 Line 11: 루프 조건 ‘참’ Line 12: T에 속하지 않은 각 점 v에 대해 vmin인 점 f를 찾고, 점 f와 선분 (c,f)를 T에 추가T={c, b, f, (c,b), (c,f)} Line 13~15: 점 f에 연결된 점 e의 D[e]=9로 갱신. D[d]는 선분 (f,d)=7보다 작아서 if 조건문을 만족하지 못하므로 제외D[a]=∞, D[b]=1, D[c]=0, D[d]=∞, D[e]=9, D[f]=1 Line 11~15 과정을 반복한다. Line 16 : T를 리턴한다. 프림 알고리즘은 항상 T 밖에 있는 점을 추가하므로 사이클을 만들지 않는다. 5. 프림 알고리즘의 시간 복잡도 프림 알고리즘은 while-루프가 (n-1)번 반복, 1회 반복될 때 line 9에서 T에 속하지 않은 각 점 v에 대해 vmin을 찾는 데 O(n) 시간이 걸린다. 따라서 프림 알고리즘의 시간복잡도는 (n-1)XO(n) = O(n2)이다. 6. 응용 최소 신장 트리 알고리즘은 최소 비용으로 선로 또는 파이프 네트워크를 설치하는 데 활용되며, 여행자 문제를 근사적으로 해결하는 데 이용된다. cf. 연결요소 1개의 연결요소로 된 그래프 2개의 연결요소로 된 그래프 Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid= “6장 그래프 - (3) 그래프 탐색 문제1 - 연결 요소(11724번)”, 살구의 개발자 첫걸음을 위한 , 2019. 1. 21, http://salguru.tistory.com/","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 동전 거스름돈 (그리디)","slug":"algo11","date":"2019-01-20T19:59:30.000Z","updated":"2019-01-20T21:16:49.528Z","comments":true,"path":"2019/01/21/algo11/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo11/","excerpt":"","text":"1. 동전 거스름돈 문제란2. 동전 거스름돈 알고리즘 1. 동전 거스름돈 문제란 거스름돈을 동전으로 받아야 할 때, 누구나 적은 수의 동전을 거스름돈으로 받기를 원한다고 가정한다.동전 거스름돈 문제를 해결하는 가장 간단하고 효율적인 방법은 남은 액수를 초과하지 않는 조건하에 ‘욕심내어’ 가장 큰 액면의 동전을 취하는 것이다. 2. 동전 거스름돈 알고리즘 다음은 동전 거스름돈 문제의 최소 동전 수를 찾는 그리디 알고리즘이다. 12345678910CoinChange(W)입력: 거스름돈 액수 W출력: 거스름돈 액수에 대한 최소 동전 수change=W, n500=n100=n50=n10=n1 //n500, n100, n50, n10, n1은 각각의 동전수를 위한 변수while(change&gt;=500) change=change-500, n500++ //500원짜리 동전수를 증가while(change&gt;=100) change=change-100, n100++ //100원짜리 동전수를 증가while(change&gt;=50) change=change-50, n50++ //50원짜리 동전수를 증가while(change&gt;=10) change=change-10, n10++ //10원짜리 동전수를 증가while(change&gt;=1) change=change-1, n1++ //1원짜리 동전수를 증가return (n500+n100+n50+n10+n1) //총 동전수를 반환 Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 그리디 알고리즘","slug":"algo10","date":"2019-01-20T19:49:01.000Z","updated":"2019-01-20T21:16:36.139Z","comments":true,"path":"2019/01/21/algo10/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo10/","excerpt":"","text":"그리디(Greedy) 알고리즘은 최적화 문제를 해결하는 알고리즘이다. 최적화(Optimization) 문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다. 그리디 알고리즘은 입력 데이터 간의 관계를 고려하지 않고 수행 과정에서 최솟값 또는 최댓값을 가진 데이터를 선택한다. 이러한 선택을 ‘근시안적’인 선택이라고도 하는데, 그리디 알고리즘은 근시안적인 선택으로 부분적인 최적해를 찾고, 이들을 모아서 문제의 최적해를 얻는다. 또한, 그리디 알고리즘은 일단 한번 선택하면, 이를 절대로 번복하지 않는다. 위와 같은 그리디 알고리즘의 특징들 때문에 그리디 알고리즘은 매우 단순하며 제한적인 문제들만이 그리디 알고리즘으로 해결이 가능하다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"그리디","slug":"그리디","permalink":"http://dudri63.github.io/tags/그리디/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 주의할 점 (분할정복)","slug":"algo9","date":"2019-01-20T19:33:06.000Z","updated":"2019-01-20T21:16:28.523Z","comments":true,"path":"2019/01/21/algo9/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo9/","excerpt":"","text":"분할 정복은 분활된 부분문제의 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우 사용기하게 부적절하다.예를 들어, 피보나치 수를 구할 때, F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 한다고 가정한다. 그러나 이 경우는 n이라는 숫자로 인해 2개의 부분문제인 F(n-1), F(n-2)이 만들어지고, 입력의 크기의 합이 (n-1) + (n-2)가 되어 분할 후 입력의 총 크기가 거의 2배가 된다. 위와 같이 6의 피보나치 수를 구할 때, 분할 정복을 사용하면, 중복되는 부분문제들이 생겨서 오히려 총 소요 시간이 증가함을 알 수 있다. 피보나치 수와 같은 경우에는 분할 정복(재귀 호출)을 사용하지 않고, for-루프를 사용하는 것이 더욱 효율적이다.12345FiboNumber(n)F[0]=0F[1]=1for i=2 to n F[i] = F[i-1] + F[i-2] 위와 같은 알고리즘을 사용하면, 루프의 수행 횟수로서 시간복잡도가 O(n)이 된다. 주어진 문제를 분할 정복 알고리즘으로 해결하려고 하라 때 중의해야 하는 점 중 다른 하나는 취합 과정이다. 입력을 분할 한다고 해서 효율적인 알고리즘이 만들어지는 것은 아니다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “3장분할정복알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Git] 원격 저장소(Remote Repository)","slug":"git10","date":"2019-01-20T15:34:11.000Z","updated":"2019-01-21T03:12:49.676Z","comments":true,"path":"2019/01/21/git10/","link":"","permalink":"http://dudri63.github.io/2019/01/21/git10/","excerpt":"","text":"1. 원격 저장소란1. 원격 저장소 생성 1. 원격 저장소란 원격 저장소(Remote Repository)란 흔히 지역 저장소(Local Repository)와 구별되는 개념이다. 자신의 컴퓨터에서 작업하고 commit하면 저장되는 곳이 지역 저장소이다. 그런데, 작업물들을 인터넷에 올려서 백업을 하거나 다른 사람들과 협업을 할 경우, 컴퓨터와 연결된 다른 저장소가 필요하다. 원격 저장소의 역할은 크게 다음과 같다. 협업 백업 일반적으로 원격 저장소는 같은 컴퓨터에 연결되어 있지 않고, 인터넷을 통하여 다른 컴퓨터와 연결되어 있다. 원격 저장소는 프로젝트가 커지는 과정에서 굉장히 중요한 역할을 한다. 그러나 혼자서 프로젝트를 진행할 때에는 원격 저장소가 필요한 일은 많지 않다. 주로, dropbox 등과 같은 서비스를 이용한다. 2. 원격 저장소 생성 앞서 이야기하였듯이, 원격 저장소는 주로 인터넷을 통해 연결, 같은 컴퓨터 안에 있지 않는다. 그러나 원격 저장소 개념을 알기 위하여 본 포스팅에서는 한 대의 컴퓨터, 다른 디렉토리에 원격 저장소를 생성, 원격 저장소에 commit할 것이다. 위와 같이 gitfth2 디렉토리에 ‘local’이라는 이름의 저장소를 생성한다. 이 후, f1.txt를 add하고 commit한다.(local 이름의 저장소를 지역 저장소라고 가정한다.) gitfth2 디렉토리에 또 다른 저장소 ‘remote’를 생성한다.(remote 이름의 저장소를 원격 저장소라고 가정한다.) cf.1$ git init --bare &apos;저장소 이름&apos; // 작업이 불가능, 저장만 가능한 저장소를 생성 remote 저장소는 –bare option을 적용하였기 때문에 .git 디렉토리가 내부에 존재하지 않고 위와 같은 파일들이 존재한다.원격 저장소는 일반적으로 작업을 하지 않고, 저장만 하는 경우가 많다. cf.123$ git remote add &apos;별명&apos; &apos;경로&apos; // 경로에 있는 디렉토리를 별명으로 설정 및 원격저장소로 연결$ git remote -v // 연결된 저장소 및 별명을 파악할 수 있음$ git remote remove &apos;별명&apos; // 연결된 원격원격소를 제거 별명을 설정하는 이유는 항상 경로를 입력하기가 불편하기 때문이다.같은 경로에 대하여 별명을 여러 개 설정할 수도 있다. 위와 같이 remote 디렉토리를 origin이라는 별명으로 하여 원격저장소로서 연결한다. cf.1234$ git push // 현재 저장소의 현재 branch를 연결시킨 원격 저장소에 upload$ git config --global push.default.simple // git의 push 형식을 simple 방식으로 설정$ git push --set-upstream origin master // 현재 branch를 origin의 master branch로 push // 또한, 앞으로 git push할 경우 위와 같이 psuh하겠음을 설정 remote 디렉토리에서 확인하면, push가 잘 되었음을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/2708/15395","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"},{"name":"원격 저장소","slug":"원격-저장소","permalink":"http://dudri63.github.io/tags/원격-저장소/"}]},{"title":"[Git] Branch (4)","slug":"git9","date":"2019-01-20T14:23:16.000Z","updated":"2019-01-20T15:32:41.941Z","comments":true,"path":"2019/01/20/git9/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git9/","excerpt":"","text":"1. $ git branch -d, -D2. Branch 병합 시 충돌 해결 1. $ git branch -d, -D 12$ git branch -d &apos;branch name&apos; // 해당 branch를 제거$ git branch -D &apos;branch name&apos; // 강제로 해당 branch를 제거 2. Branch 병합 시 충돌 해결 2.1 충돌이 일어나지 않는 경우 위와 같이 master, exp branch가 있고, 각각의 branch에서 master.txt, exp.txt가 commit된 상태임을 가정한다. master branch에서 $ git merge exp 명령어를 실행하면, master branch에서 exp branch를 병합하는 새로운 commit이 생성된 것을 확인할 수 있다. 또한, ls -al 명령을 실행하면, 새로 생긴 commit은 master.txt, exp.txt를 모두 포함하는 것을 확인할 수 있다.이것은 branch 병합시 충돌이 일어나지 않는 경우인데, 병합 시, 공통된 이름의 파일이 존재하지 않았기 깨문에 가능한 것이다. 다음은 또다른 상황을 가정한다. master branch, exp branch에 모두 common.txt가 있는데, 위와 같이 각각의 common.txt의 내용은 다를 경우를 가정한다.(첫 번째 이미지가 master branch의 common.txt, 두 번째 이미지가 exp branch의 common.txt이다.) $ git merge master 명령어를 실행하면, 위와 같이 충돌 없이 두 branch가 병합되었음을 알 수 있다. 또한, $ cat 명령어를 이용하여 확인하면, common.txt에 function a, b, c가 모두 포함되어 있음을 확인할 수 있다.서로 다른 branch에 같은 이름의 파일이 존재하고, 각 파일들은 서로 다른 내용을 포함하고 있지만 충돌없이 병합할 수 있는 경우이다. 2.2 충돌이 일어나는 경우 위와 같이 master branch와 exp branch의 common.txt라는 같은 이름의 파일이 존재하지만, 그 내용이 각각 다른 경우를 가정한다. master branch에서 $ git merge exp 명령어를 실행하면, Conflict가 발생한다. 구체적으로, $ git status 명령어를 실행하면, common.txt가 서로 다른 branch에서 both modified되었기 때문에 conflict가 발생하여 merge에 실패하였음을 확인할 수 있다. common.txt를 텍스트 편집기를 이용하여 불러오면, 위와 같이 텍스트 내용이 변경되었음을 확인할 수 있다.=======를 구분자로 하여 구분자를 중심으로 위 쪽은 현재 checkout한 branch인 master의 충돌 요인, 아래 쪽은 exp의 충돌 요인을 확인할 수 있다. 2.3 충돌 해결 방법 위와 같은 상황에서 common.txt를 위와 같이 수정한다.(구분자를 비롯하여 나머지 부분들은 삭제한다.)이 후, common.txt를 add, commit하면 충돌 없이 병합할 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15275","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Branch (3)","slug":"git8","date":"2019-01-20T13:53:07.000Z","updated":"2019-01-20T15:32:28.871Z","comments":true,"path":"2019/01/20/git8/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git8/","excerpt":"","text":"작업을 분기한 뒤, 각자의 history들을 이어가다가 병합할 필요성이 있을 수 있다.1$ git merge &apos;branch name&apos; 이럴 경우, $ git merge ‘branch name’ 명령어를 실행하면 현재 chekcout되어 있는 branch에서 명령어에 함께 입력한 branch의 버전 정보들을 포함하는 새로운 commit이 생성된다. 현재 저장소에 2 version에서 5 version으로 진행된 master branch, 3,4 version으로 진행된 exp branch가 있다고 가정한다. master branch에서 $ git merge exp 명령어를 실행하면, commit message를 작성하는 화면이 나온다. 이 때, commit message를 작성 완료한 뒤, $ git log –branches 명령어를 실행하면, master branch에서 각 branch의 최신 commit들을 병합한 새로운 commit이 생성되었음을 확인할 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15261","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Branch (2)","slug":"git7","date":"2019-01-20T13:05:31.000Z","updated":"2019-01-20T13:51:59.941Z","comments":true,"path":"2019/01/20/git7/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git7/","excerpt":"","text":"1. $ git log –branches –decorate2. $ git log –branches –decorate –graph3. $ git log –branches –decorate –graph –oneline4. $ git log ‘branch name a’..’branch name b’ 123&lt;a name=&quot;1&quot;&gt;1. $ git log --branches --decorate&lt;/a&gt;$ git log --branches --decorate 기본적으로 $ git log 명령어는 현재 속해있는 branch의 버전 history만을 출력한다. 그러나 –branches 옵션을 추가로 실행하면, 현재 checkout되어 있는 branch 뿐만 아니라 저장소에 속해있는 모든 branches의 버전 정보들을 출력한다. master의 최신 commit이 2, exp의 최신 commit이 4, 현재 checkout된 branch는 exp임을 알 수 있다. 2. $ git log –branches –decorate –graph 1$ git log --branches --decorate --graph –graph 옵션을 추가로 실행하면, 버전이 진행된 것을 도형(선)으로 나타내어 효율적으로 버전 정보들을 파악할 수 있다. 위와 같이 graph가 나타나 효율적으로 버전 histories를 파악할 수 있다. 2 version에서 exp branch는 3,4 version으로 차례대로 변화, master branch는 5 version으로 변화하였음을 알 수 있다. 3. $ git log –branches –decorate –graph –oneline 1$ git log --branches --decorate --graph --oneline 더 간결하게 histories를 graph로 나타낸다. 4. $ git log ‘branch name a’..’branch name b’ 1$ git log &apos;branch name a&apos;..&apos;branch name b&apos; 위 명령어는 branch name a에는 없는 branch name b의 commit들을 전시한다. master branch에는 없는 exp branch들의 commit들을 나타내었다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15261","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Branch (1)","slug":"git6","date":"2019-01-20T11:58:30.000Z","updated":"2019-01-20T13:06:36.757Z","comments":true,"path":"2019/01/20/git6/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git6/","excerpt":"","text":"1. Git을 쓰는 이유2. $ git branch, $ git checkout ‘branch name’ 1. Git을 쓰는 이유 예를 들어, report.xsl file을 버전 관리한다고 가정한다.파일 내용이 변경될 때마다 새로운 이름으로 저장한다. report1.xsl, report2.xsl, ….그런데, 순차적으로 수정이 되다가 경우에 따라서 나뉘어서 수정될 수 있다.고객용으로 수정되면, report2_client.xsl으로 파일 이름을 저장할 수 있다.그리고, 고객용이 아니라 또 다시 내용 변경되면, report3.xsl으로 파일 이름을 저장할 수 있다.이렇게 나뉘어서 버전이 증가하다가, 다시 합쳐지는 경우도 있음. 위와 같이 버전 관리를 할 경우, 파일 이름을 변경해야 하는데, 작업이 분기되거나 합쳐질 경우, 매우 복잡하다.git을 쓰면 위와 같이 과정을 쉽고, 세련되게 할 수 있다. 2. $ git branch, $ git checkout ‘branch name’ 123$ git branch // 현재 저장소의 branch들, 현재의 branch$ git branch &apos;branch name&apos; // 새로운 branch 생성$ git checkout &apos;branch name&apos; // 해당 branch로 이동 $ git branch 명령어를 실행하면 현재 저장소의 모든 branch들과 함께 현재 속해 있는 branch가 무엇인지 알 수 있다.$ gir branch ‘branch name’ 명령어를 실행하면 해당 name의 새로운 branch가 생성된다.$ git checkout ‘branch name’ 명령어를 입력하면 해당 branch로 이동한다. 기본적으로 저장소에는 master branch가 존재한다. $ git branch 명령어를 실행하면, master branch가 있음을 알 수 있고, $ git branch exp 명령어를 실행하여 새로운 branch exp를 만든 뒤, $ git checkout exp 명령어를 실행하여 exp branch로 이동하였다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15260","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Reset, Command","slug":"git5","date":"2019-01-20T11:25:27.000Z","updated":"2019-01-20T12:38:17.719Z","comments":true,"path":"2019/01/20/git5/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git5/","excerpt":"","text":"1. $ git reset2. $ git commit –help, -a, -m 1. $ git reset 버전 관리 시스템에서 과거로 돌아가기란 commit을 취소하는 것을 의미한다. Git에서 과거로 돌아가는 방법에는 크게 2가지가 있다. reset revert 과거로 돌아가는 작업은 상당히 위험한 작업이며, 프로젝트 폴더 전체를 copy한 뒤, 위험한 작업을 실시하는 것이 좋다. 12$ git reset &apos;Commit ID&apos; --hard // Commit ID version이 최신이 됨$ git revert // Commit을 취소하면서 새로운 버전을 생성 $ git reset 명령어 뒤에 3 commit ID를 붙여서 실행하였더니, 이 후에 버전들은 삭제되고, 3 commit이 최신 버전이 된 것을 확인할 수 있다.(실제로 이후에 버전들이 삭제된 것은 아니다. Git은 특별한 경우를 제외하고는 버전에 관한 정보들을 삭제하지 않는다.) 원격 저장소에 협업을 할 경우, 자신의 버전을 공유할 수 있다. 이 때, 공유한 이후에는 reset를 하면 안되고, reset은 local 저장소에서만 사용하도록 한다. 2. $ git commit –help, -a, -m 123$ git commit --help // commit에 대한 도움말을 볼 수 있다.$ git commit -a, --all // 수정하거나 삭제한 파일을 자동으로 stage에 올린다.$ git commit -m, --message // commit message를 바로 쓴다. cf.$ git commit -a : 자동으로 변경된 파일을 add시킨다. 그러나 이전에 한번도 add하지 않은 파일에 대해서는 add하지 않는다. 즉, 파일을 생성하면 최초 1회는 $ git add 명령어를 사용하여야 한다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15210, https://opentutorials.org/course/2708/15211","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Commit ID, Diff","slug":"git4","date":"2019-01-20T10:22:19.000Z","updated":"2019-01-20T11:27:19.900Z","comments":true,"path":"2019/01/20/git4/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git4/","excerpt":"","text":"1. Commit ID2. $ git diff 1. Commit ID 각각의 commit들은 고유한 ID가 있다.git log 명령어를 실행하였을 때 나오는 매우 긴 노란쌕 문자열이 고유 ID다. 1$ git log &apos;commit ID&apos; // 해당 commit을 포함하여 이전의 history들만을 출력 위와 같이 $ git log 명령어 뒤에 commit ID를 붙이면, 그 commit을 포함하여 이전의 history들만을 화면에 출력한다. 2. $ git diff 12$ git diff &apos;commit ID A&apos;..&apos;commit ID B&apos; // 두 개의 commit 사이의 차이점 출력$ gii diff // 마지막 commit으로부터 변경된 점 출력 $ git diff ‘commit ID A’..’commit ID B’ 명령어를 입력하면 두 개의 commit 사이의 차이점을 보여준다. f1.txt의 경우, ID A에서는 그 내용이 ‘f1.txt : 4’, ID B에서는 그 내용이 ‘source : 2’이었음을 알 수 있다.f2.txt의 경우, ID A에서는 그 내용이 ‘source : 2’, ID B에서는 해당 파일이 없었음을 알 수 있다.$ git diff 명령어를 실행하면, 마지막 commit으로부터 변경된 점을 출력한다.(단, 변경사항을 git add하여 stage area로 이동시키면, 출력하지 않는다.) f1.txt, f2.txt를 수정한 뒤, add하기 전에 $ git diff 명령어를 실행했을때의 결과는 위와 같다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 19, https://opentutorials.org/course/2708/15202","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Setting, Commit, Log","slug":"git3","date":"2019-01-19T15:31:03.000Z","updated":"2019-01-20T10:41:04.460Z","comments":true,"path":"2019/01/20/git3/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git3/","excerpt":"","text":"1. Setting2. $ git commit3. $ git log 1. Setting Git을 처음 쓰는 거라면, 앞으로 만들 버전이 내가 만들었음을 알리기 위하여 name, email을 setting한다.123$ git config --global user.name &quot;이름&quot;$ git config --global user.email &quot;이메일 주소&quot;$ git config --list // 입력한 사용자 정보 조회 2. $ git commit 1$ git commit // 버전 생성 git commit 명령어를 실행하면, add한 파일들에 한하여 해당 버전에 추가한다.또한, git commit 명령어를 실행하면, commit message를 작성할 수 있는데, commit message에는 어떠한 변화가 있는지 혹은 변화의 이유에 대하여 작성하도록 한다. 파일에 대하여 commit하고 싶으면 반드시 이전에 add하여야 한다. cf.버전 : 의미 있는 변화, 완성된 코드 단위git add : commit 대기 상태에 들어가게 한다.git commit : commit 대기 상태에 있는 파일들만 해당 버전에 추가한다.commit 대기 상태 : stage area에 올린다. 3. $ git log 12$ git log // 버전 생성이 되었는지 확인 가능$ git log -p // 각 commit 사이의 소스상 차이점을 파악할 수 있음 git log 명령어를 실행하면, 각 버전들의 verseion message, author, date 등을 확인할 수 있다.(version history를 파악할 수 있음) $ git log 명령어를 입력하면 각 commit들의 정보를 파악할 수 있다. $ git log -p 명령어를 입력하면 각 버전들 사이의 소스상 차이점을 알 수 있다.위 경우, version 4(commit message가 ‘4’인 버전) commit에서, version 4의 f1.txt의 내용이 ‘f1.txt : 4’, version 3의 f1.txt의 내용이 ‘source : 2’이었음을 알 수 있다.또한, version 3 commit에서, version 2에서는 f2.txt가 없었으나 version 3에서는 그 내용을 ‘source : 2’로 하는 f2.txt가 새로 생성되었음을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 19, https://opentutorials.org/course/2708/15202","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Init, Status, Add","slug":"git2","date":"2019-01-19T13:45:44.000Z","updated":"2019-01-19T16:55:50.663Z","comments":true,"path":"2019/01/19/git2/","link":"","permalink":"http://dudri63.github.io/2019/01/19/git2/","excerpt":"","text":"1. $ git init2. $ git status, $ git add 1. $ git init 1$git init //현재 디렉토리를 Git의 저장소로 등록 위와 같은 명령어를 실행하면, 현재 디렉토리를 Git으로 관리할 수 있다. 이 후, ls -al로 확인하면, .git 디렉토리가 현재 디렉토리 내부에 새롭게 생성된 것을 알 수 있다. 버전 관리를 하게 되면, 여러 가지 정보가 생성되는데, 이 때 이 정보들은 .git 디렉토리에 저장된다. 2. $ git status, $ git add Git은 init을 하여 관리하고 있는 디렉토리라고 할지라도, 기본적으로 새롭게 생성된 파일에 대해서는 관리하지 않는다. 파일을 관리하기 위해서는 관리 대상으로 등록해야 한다. 12git status // 현재 관리하고 있는 파일과 그렇지 않은 파일 확인git add + 파일 // 해당 파일을 git에게 추적하라고 명령 f1.txt의 내용을 ‘source:1’으로 하여 생성한다. git status를 실행하였을 때, f1.txt는 untracked file임을 확인할 수 있다. 즉, f1.txt는 버전 관리가 되고 있는 디렉토리에 존재하지만, 아직 git에 의해 관리되고 있지 않다.그러나 이 후, git add 명령어를 입력하여 git에게 f1.txt를 추적하라고 명령하면, 새롭게 f1.txt가 관리되기 시작하는 것을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 19, https://opentutorials.org/course/2708/15170, https://opentutorials.org/course/2708/15172","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Git의 기본","slug":"git1","date":"2019-01-19T09:32:02.000Z","updated":"2019-01-19T17:14:01.502Z","comments":true,"path":"2019/01/19/git1/","link":"","permalink":"http://dudri63.github.io/2019/01/19/git1/","excerpt":"","text":"1. 파일 복구 2. Git이란 1. 파일 복구 파일을 편집 전 상태로 돌리기 위한 방법 중 가장 간단한 것은 기존 파일을 미리 복사해두는 것이다. 이 경우에는 특별하게 파일명을 구분할 수 있게 해주어야 한다는 번거로움이 있다. 또한, 여러 명이 공유한 파일을 동시에 편집할 경우 다른 사람이 변경하고 있는 내용을 지워버릴 수 있다. 2. Git이란 이러한 문제점들을 해결하기 위하여 버전 관리 시스템이 ‘Git’을 사용한다.Git에서는 소스 코드가 변경된 이력을 쉽게 확인할 수 있고, 특정 시점에 저장된 버전과 비교하거나 특정 시점으로 되돌릴 수 있다.또한, 내가 업로드하는 파일이 누군가가 편집한 내용과 충돌한다면, 경고 메세지가 발생하여 사전에 다른 사람들과 조율할 수 있다. Reference Git의 기본(시작하기), 누구나 쉽게 이해할 수 있는 Git 입문, 2017. 1. 19, https://backlog.com/git-tutorial/kr/","categories":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Algorithm] 최근접 점의 쌍 찾기 (분할정복)","slug":"algo8","date":"2019-01-19T09:31:18.000Z","updated":"2019-01-24T08:54:38.398Z","comments":true,"path":"2019/01/19/algo8/","link":"","permalink":"http://dudri63.github.io/2019/01/19/algo8/","excerpt":"","text":"1. 최근접 점의 쌍 찾기2. 최근접 점의 쌍을 찾는 알고리즘3. 시간복잡도4. 응용 1. 최근접 점의 쌍 찾기 ‘최근접 점의 쌍(Closest Pair)’을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다. 최근접 점의 쌍을 찾는 가장 간단한 방법은 모든 점에 대하여 각각의 두 점 사이의 거리를 계산하여 가장 가까운 점의 쌍을 찾는 것이다. 그러나 이러한 방법을 사용할 경우, 경우의 수는 nC2 = n(n-1)/2 = O(n2)의 시간복잡도로써 굉장히 오랜 시간이 걸린다. 효율적인 방법은 분할 정복을 이용하는 것이다. 즉, n개의 점을 1/2로 분할하여 각각의 부분문제에서 최근점 점의 쌍을 찾고, 2개의 부분해 중에서 가장 짧은 거리를 가진 점의 쌍을 찾는다. 그러나 다음과 같은 경우도 있다. 2개의 부분해를 취합할 때, 더 가까운 거리를 가진 점의 쌍이 있는 경우이다.따라서 단순히 2개로 분할한 부분문제에서 더 짧은 거리의 점의 쌍이 전체 문제에서 최근접 점의 쌍이라고 할 수 없는 것이다.(중간 영역에 있는 점들 때문에) 다음은 배열에 점의 좌표가 저장되어 있을 때, 중간 영역에 있는 점들을 찾는 방법이다. 0 1 2 3 4 5 6 7 8 9 (1,- ) (13,-) (17,-) (25,-) (26,-) (28,-) (30,-) (37,-) (45,-) (56,-) (4번, 5번 점을 각각 왼쪽 부분문제의 가장 오른쪽 점, 오른쪽 부분문제의 가장 왼쪽 점이라고 한다.)(일단 y-좌표는 무시하고 생각한다.)2차원 공간에서 위와 같이 10개의 점이 있다고 가정한다.이 때, 중간 영역에 속한 점들은 어떤 점들인가? 왼쪽 부분문제의 가장 오른쪽 점의 x-좌표에서 d를 뺀값과 오른쪽 부분문제의 가장 왼쪽 점의 x-좌표에 d를 더한 값 사이의 x-좌표 값을 가진 점들이다.(이 때, d=min{왼쪽 부분의 최근접 점 쌍 사이의 거리, 오른쪽 부분의 최근접 점 쌍 사이의 거리})만약, d=10이라면, 26-d=16, 28+d=38, 즉, 16~38 사이의 점들이 그것들이다. 2. 최근접 점의 쌍을 찾는 알고리즘 다음은 최근접 점의 쌍을 찾는 분할 정복 알고리즘이다. 단, 입력 점들은 x-좌표를 기준으로 미리 정렬되어 있다고 가정한다.123456789ClosestPair(S)입력: x-좌표의 오름차순으로 정렬된 배열 S출력: S에 있는 점들 중 최근접 점의 쌍의 거리if(i&lt;=S) return (2 또는 3개의 점들 사이의 최근접 쌍) // 3개 이하일 경우, 분할 X정렬된 S를 같은 크기의 S1과 S2로 분할한다. 단 |S|가 홀수이면, S1이 1 더 많게 분할한다.CP1 = ClosestPair(S1) // CP1은 S1에서의 최근접 점의 쌍CP2 = ClosestPair(S2) // CP2는 S2에서의 최근접 점의 쌍d = min&#123;dist(CP1), dist(CP2)&#125;일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서 이를 CPc라고 한다. 단, dist()는 두 점 사이의 거리이다.return (CP1, CP2, CPc 중에거 거리가 가장 짧은 쌍) 3. 시간 복잡도 ClosestPair 알고리즘의 전처리 과정으로서 S의 점을 x-좌표로 정렬하여야 하는데, 이 과정에서 O(nlogn)의 시간이 소요된다.왜냐하면 합병 정렬 또는 퀵 정렬을 사용하면 O(nlogn)의 시간이 소요되기 때문이다. 이 후, Line 4에서 O(1) 시간이 걸린다. Line 5에서는 S1, S2로 S를 분할하는데, 배열의 중간 인덱스를 계산해야 하므로 O(1) 시간이 걸린다. Line 6~7에서는 S1, S2가 각각 ClosestPair를 호출한다.합병 정렬처럼 분할하면서 호출하는 데에는 특별한 시간이 소요되지 않는다.단, 합병하면서 O(nlgon) 시간이 소모된다. Line 8에서는 중간 영역에 속해 있는 점들 중에서 최근접 점의 쌍을 찾는다. 기준선을 중심으로 거리가 d 이내인 영역에 있는 점들을 y-좌표 기준으로 정렬한다. 제일 아래에 있는 점부터 시작해서 각 점을 자기보다 더 위에 있는 점이랑만 비교한다. 초록색 점을 기준으로 자기보다 위에 있는 점만 비교한다면, 빨간색 직사각형 내부의 점들만을 고려한다. y-좌표를 기준으로 정렬하였으니 O(nlogn) 시간이 소모된다. Line 9에서는 3개의 점의 쌍 중 가장 짧은 거리를 가진 점의 쌍을 리턴하므로 O(1) 시간이 걸린다. ClosestPair 알고리즘의 분할 과정은 합병 정렬의 분할 과정과 동일하다. 그러나 취합하여 올라가는 과정에서 O(nlogn) 시간이 추가로 걸린다.(y-좌표 기준 정렬)따라서, O(nlog2n)이 된다. 4. 응용 최근점 점의 쌍을 찾는 ClosestPair 알고리즘은 컴퓨터 그래픽스, 컴퓨터 비전, 지리 정보 시스템, 분자 모델링, 마케팅 등의 분야에서 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “알고리즘) Closest Pair”, Au commencement, 2019. 1. 19, https://m.blog.naver.com/PostView.nhn?blogId=babobigi&amp;logNo=220530321348&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F “최근접 점쌍 문제”, Wikipedia, 2019. 1. 19, https://ko.wikipedia.org/wiki/%EC%B5%9C%EA%B7%BC%EC%A0%91_%EC%A0%90%EC%8C%8D_%EB%AC%B8%EC%A0%9C","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 선택 문제 (분할정복)","slug":"algo7","date":"2019-01-18T12:05:24.000Z","updated":"2019-01-24T08:09:50.642Z","comments":true,"path":"2019/01/18/algo7/","link":"","permalink":"http://dudri63.github.io/2019/01/18/algo7/","excerpt":"","text":"1. 선택문제란2. 선택문제 알고리즘3. 시간 복잡도4. 응용 1. 선택문제란 ‘선택(selection) 문제’는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.선택문제는 Quick-Select 알고리즘이라고도 한다.간단한 방법은 최소 숫자들을 오름차순으로 정렬한 후, k번째 숫자를 찾는 것이다.그러나 이러한 알고리즘은 O(nlogn)의 수행 시간이 걸린다.이보다 효율적인 해결을 위하여 분할 정복 개념을 활용할 수 있다. 선택 문제는 입력이 정렬되어 있지 않으므로, 퀵 정렬과 마찬가지로 피봇을 선택하여 피봇보다 작은 숫자들은 피봇의 왼쪽으로, 큰 숫자들은 피봇의 오른쪽 숫자로 이동시킨다.이렇게 2개로 분할된 그룹들의 크기를 각각 파악하면, k번째로 작은 숫자가 2개의 그룹 중 어디에 속해있는 지를 알 수 있다.이 후, 원하는 숫자가 속해 있지 않은 그룹은 고려하지 않고, 숫자가 속해 있는 그룹에서 위와 같은 작업을 반복하여 k번째로 작은 숫자를 파악한다. 선택 문제 알고리즘은 문제가 2개의 부분문제로 분할되나,그 중에 1개의 부분문제는 고려할 필요 없으며,부분문제의 크기가 일정하지 않은 크기가 감소하는 형태의 분할 정복 알고리즘이다. 2. 선택문제 알고리즘 다음은 선택 문제를 위한 분할 정복 알고리즘이다. 1234567891011Selection(A, left, right, k)입력: A[left]~A[right]와 k, 단, 1&lt;=k&lt;=|A|, |A|=right-left+1출력: A[left]~A[right]에서 k번째 작은 원소피봇을 A[left]~A[right]에서 랜덤하게 선택,피봇과 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교,피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다. // 퀵 정렬과 일치S = p-left // S = small group의 크기if (k &lt;= S) Selection(A, left, p-1, k) // Small group에서 찾기else if (k = S+1) return A[p] // 피봇이 k번째 숫자인 경우else Selection(A, p+1, right, k-S-1) // Large group에서 찾기 위 이미지에 이 알고리즘을 적용하여 살펴본다. k=10, 피봇은 A[0]인 23을 선택한다. (이 경우, A[left]를 피봇으로 선정하였음, 자리 변경 없음) 퀵 정렬과 마찬가지로 피봇과 원소들을 비교하여 자리를 바꾼 뒤, 피봇을 두 그룹의 가운데로 이동한다. p=7, small group의 크기 S=7, 10보다 작으니깐 large group만 고려한다.(그림 상 2번 과정까지) Selection(A, 8, 15, 2)을 실시한다. 피봇은 A[8]인 44를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음) 2번 과정을 다시 수행한다. p’=11, small group’의 크기 S’=3, k’=2 &lt;=3이므로 찾고자 하는 수는 small group’내에 있다.(그림 상 3번 과정까지) Selection(A, 8, 10, 2)을 실시한다. 피봇을 A[8]인 39를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음) 2번 과정을 다시 수행한다. p’’=9, small group’’의 크기 S’’=1, k’’=2=S’’+1이므로, 피봇이 k=10번째 숫자이다. A[9]를 리턴한다. 3. 시간 복잡도 Selection 알고리즘은 분할 정복 알고리즘이기도 하지만 랜덤(Random) 알고리즘이기도 하다. 왜냐하면 위 알고리즘에서 line 4에서 피봇을 랜덤하게 정하기 때문이다. 만일 피봇이 입력을 너무 한 쪽으로 치우치게 분할하면, 알고리즘의 수행시간이 길어진다. 피봇이 입력을 분할하는 데, 두 그룹 중 하나의 크기가 입력 크기의 3/4과 같거나 그보다 크면 bad 분할이고, 그 반대의 경우는 good 분할이다. 그런데, bad 분할이 되거나 good 분할이 될 확률은 각각 1/2로 동일하다.즉, 피봇을 랜덤하게 정했을 때 good 분할이 될 학률이 1/2이므로 평균 2회 연속해서 랜덤하게 피봇을 정하면 good 분할을 할 수 있다.따라서, 매 2회 호출마다 good 분할이 되므로, good 반할만 연속하여 이루어졌을 때마다의 시간복잡도를 구하여, 그 값에 2를 곱하면 평균 경우 시간복잡도를 구할 수 있다. 처음 입력의 크기가 n일 때 피봇을 랜덤하게 정한 후 입력은 두 그룹으로 분할된다. 이 과정에서 소요시간은 O(n)이고, 분할 후 large group의 최대 크기는 (3n-1)/4이다. 왜냐하면 good 분할만 일어난다고 가정하였기 때문이다.(편의상 (3n-1)/4를 (3/4)n으로 하겠음)2번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)2n이다.3번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)3n이다.……..i번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)in이다. 즉, 입력의 크기가 계속해서 줄어들게 된다.그리하여 평균 경우 시간 복잡도는 다음과 같다.O(n + (3/4)n + (3/4)2n + (3/4)3n + … + (3/4)i) = O(n)(입력의 크기는 계속해서 줄어든다. 그리고 분할 된 리스트들 중에서는 가장 큰 것의 입력만을 고려하면 된다. 왜냐하면 작은 리스트들은 고려하지 않기 때문이다.)위 시간복잡도에 2를 곱한다.(평균 2회만에 good 분할이 되기 때문)그리하여 Selection 알고리즘의 시간복잡도는 2XO(n) = O(n)이다. 4. 응용 선택 알고리즘은 정렬을 하지 않고 k번째 작은 수를 선형 시간에 찾을 수 있게 해준다. 따라서 선택 알고리즘은 데이터 분석을 위한 중앙값을 찾는 데 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Quick Select”, AlgoCoding, 2019. 1. 18, http://www.algocoding.net/design/dc/quickselect.html","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 퀵 정렬 (분할정복)","slug":"algo6","date":"2019-01-17T10:07:32.000Z","updated":"2019-01-24T06:46:21.941Z","comments":true,"path":"2019/01/17/algo6/","link":"","permalink":"http://dudri63.github.io/2019/01/17/algo6/","excerpt":"","text":"1. 퀵 정렬이란2. 퀵 정렬 알고리즘3. 시간 복잡도4. 응용 1. 퀵 정렬이란 ‘퀵 정렬(Quick Sort)’은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 정복 후 분할하는 알고리즘이다. 퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다. 퀵 정렬의 아이디어는 피봇(pivot)이라 일컫는 배열의 원소를 기준으로 피봇보다 작은 숫자들은 왼편으로, 피봇보다 큰 숫자들은 오른편에 위치하도록 분할하고, 피봇을 그 사이에 놓는 것이다.단, 피봇은 분할된 왼편이나 오른편 부분에 포함되지 않는다. 위 경우는 피봇을 분할된 왼편과 오른편 부분에 가운데에 위치시켰다. 2. 퀵 정렬 알고리즘 다음은 퀵 정렬 알고리즘이다.123456789101112QuickSort(A, left, right)입력: 배열 A[left]~A[right]출력: 정렬된 배열 A[left]~A[right]if(left&lt;right)&#123; // 원소가 1개일 경우에는 정렬하지 않는다. 피봇을 A[left]~A[right] 중에서 선택, 피봇을 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교, 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고, 피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮긴다. 피봇은 A[p]에 놓는다. QuickSort(A, left, p-1) // 피봇보다 작은 그룹 QuickSort(A, p+1, right) // 피봇보다 큰 그룹&#125; 위 이미지를 이 알고리즘에 적용하여 살펴본다.초기상태의 배열에서 left는 0, right은 8이다.피봇(A[pivot])을 A[0]인 1으로 선택한다.피봇 A[pivot]를 A[left]과 자리를 바꾼다.(이 경우, 피봇과 A[left]가 일치)피봇과 배열의 각 원소들과 비교를 실시하여 자리를 옮긴 뒤 피봇의 위치를 A[p]로 옮긴다.이 과정은 아래 그림에 잘 나와 있다. 2개의 인덱스가 A[left+1], A[right]에서 출발하여 각각 오른쪽, 왼쪽으로 이동하면서, 비교를 진행한다.왼쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 작을 경우 정지,오른쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 클 경우 정지한다.양 쪽의 인덱스가 모두 정지하면 교환한다.교환한 후 인덱스는 다시 각각 오른쪽 왼쪽으로 이동하면서, 위 작업을 반복한다.작업을 계속 실시하다가 두 인덱스가 엇갈려서 지난 경우, stop한다.이 후, 피봇의 위치를 가운데로 옮긴다. 위 작업을 실시하면 피봇을 기준으로 왼쪽 부분 리스트와 오른쪽 부분 리스트가 생긴다.각 리스트들에 대해서도, 이 작업을 반복, 배열의 원소가 1개만 남을 때까지 반복한다. 3. 시간 복잡도 퀵 정렬의 성능은 기본적으로 피봇 선택이 결정한다.항상 1/2씩 분할한다면 최선의 경우가 되지만(O(nlogn))(합병 정렬과 일치),피봇으로 가장 작은 숫자 또는 가장 큰 숫자가 선택되면, 최악의 경우가 된다.(O(n2)) 최선의 경우 최악의 경우 그럼에도 불구하고 퀵 정렬은 합병정렬보다 빠를뿐 아니라 정렬 알고리즘 중에서 평균적으로 가장 빠르다.퀵 정렬을 불필요한 데이터 이동을 줄이고, 먼 거리의 데이터를 교환, 한 번 결정된 피봇들이 추후 연산에서 제외되는 특성 때문이다. 피봇 선정 방법 퀵 저렬의 불균형한 분할을 완화시키기 위해서, 일반적으로 다음과 같은 피봇 선정 방법이 사용된다. 랜덤하게 선정 세 숫자의 중앙 값으로 선정하는 방법 입력의 크기가 매우 클 때, 퀵 정렬의 성능을 더 향상시키기 위해서, 삽입 정렬이 동시에 사용되기도 한다. 퀵 정렬을 재귀 호출로 수행되어 문제가 크기가 작아지면 중단하고, 삽입 정렬을 사용하면 효율적이다. 4. 응용 퀵 정렬은 커다란 크기의 입력에 대해서 가장 좋은 성능을 보이는 정렬 알고리즘이다. 퀵 정렬은 실질적으로 어느 정렬 알고리즘보다 좋은 성능을 보인다. 생물 정보 공학에서 특정 유전자를 효율적으로 찾는 데 퀵 정렬이 사용되곤 한다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “[알고리즘] 퀵 정렬(quick sort)이란”, Heee’s Development Blog, 2019. 1. 17, https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 합병 정렬 (분할정복)","slug":"algo5","date":"2019-01-17T07:41:43.000Z","updated":"2019-01-24T06:28:58.960Z","comments":true,"path":"2019/01/17/algo5/","link":"","permalink":"http://dudri63.github.io/2019/01/17/algo5/","excerpt":"","text":"1. 합병 정렬이란?2. 합병 정렬 알고리즘3. 시간 복잡도4. 응용 1. 합병 정렬이란? ‘합병 정렬(Merge Sort)’은 입력이 2개의 부분문제로 분할, 부분 문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다. 합병 과정이 문제를 정복한다는 것이 중요하다.합병(merge)이란 2개의 각각 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것이다. 2. 합병 정렬 알고리즘 다음은 분할 정복에 기반을 둔 합병 정렬 알고리즘이다.123456789MereSort(A,p,q)입력: A[p]~A[q]출력: 정렬된 A[p]~A[q]if(p &gt; q) &#123; // 배열의 원소의 수가 2개 이상이면, k = [(p+q)/2] // (k는 배열을 반으로 나누기 위한 중간 원소의 인덱스이다.) MergeSort(A,p,k) // 앞부분 재귀 호출 MergeSort(A,k+1,q) // 뒷부분 재귀 호출 A[p]~A[q]와 A[k+1]~A[q]를 정렬된 형태로 합병한다.&#125; 분할하여 재귀 호출하는 것은 line 6, 7에서 수행되고, 합병은 line 8에서 수행된다. 위 그림에 이 알고리즘을 적용하여 살펴본다. 그림에서 가장 상위에 있는 배열을 A, p를 7, q를 0이라고 한다. 그리하여 k는 3이 되고, 배열 A는 A[0]~A[3], A[4]~A[7] 두 부분으로 나뉜다. 2번을 배열의 원소가 한 개씩 남을 때까지 반복한다. 원소가 단 1개인 배열들을 2개씩 합병한다.(합병이란 2개의 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것) 분할된 배열들이 완성된 한 개의 배열이 될 때까지 4번을 반복한다. 3. 시간 복잡도 정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 나타낸다.위 그림에서 알고리즘이 수행한 비교 횟수를 본다.분할하는 부분은 배열의 중간 인덱스 계산과 2번의 재귀 호출을 하는 것이므로 O(1) 시간이 걸린다.(비교 연산 및 이동 연산이 수행되지 않기 때문)이에 반해, 합병의 수행 시간은 입력의 크기에 비례한다.2개의 정렬된 배열 A, B의 크기가 각각 n, m이라면 최대 비교 횟수는 (n+m-1)이다.마지막에 합병되는 숫자는 비교할 대상이 없으므로, -1을 한다. 예를들어, 위 그림에서 {3,27,38,43} 배열과 {9,10,82} 배열을 합병하는 과정을 본다.3과 9를 비교, 최종 배열 {3}27과 9를 비교, 최종 배열 {3,9}27과 10을 비교, 최종 배열 {3,9,10}27과 82를 비교, 최종 배열 {3,9,10,27}38과 82를 비교, 최종 배열 {3,9,10,27,38}43과 82를 비교, 최종 배열 {3,9,10,27,38,43,82}총 6번의 비교를 하였다.(이 경우는 불운한 경우로서, 비교 횟수가 n+m-1로서 비교를 할 수 있는 최대의 경우만큼 비교하였다.) 즉, 1회 합병의 시간복잡도는 O(n+m)이다. 그러나 비교 횟수를 직접 세보는 것보다 더 쉬운 계산은 층별로 살피는 것이다. 위 그림에서 합병 과정은 총 3개의 층으로 이루어져 있는데, 각 층에서 모든 숫자가 합병에 참여하고 있다.앞서 알아보았 듯이, 합병은 입력의 크기에 비례하므로 각 층에서 수행된 비교 횟수는 O(n)이다.그런데, 층이 높아질수록(아래로 올라갈수록) 입력의 크기(배열의 크기)가 반씩 줄어든다.즉, 다음과 같다. 1층 : n/23 = 1 / {38}, {27}, {43}, {3}, {9}, {82}, {10} (n은 7) 2층 : n/22 = 2 / {27,38}, {3,43}, {9,82}, {10} 3층 : n/2 = 4 / {3,27,38,43}, {9,10,82} k번 1/2로 분할하였으면 k개의 층이 생기는 것이고, k=log2n임을 알 수 있다.결과적으로 합병 정렬의 시간복잡도는 (층수)XO(n) = log2nXO(n) = O(nlogn)이다.(각 층마다 모든 입력의 합은 n이다. 헷갈리지 말자. 그림을 보자.) 합병 정렬 알고리즘의 공간 복잡도는 O(n)이다.(단점)왜냐하면 입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요하기 때문이다. 2개의 정렬된 부분을 하나로 합병하는 데 있어서, 합병된 결과를 저장할 곳이 필요하다. 4. 응용 합병 정렬은 외부정렬의 기본이 되는 정렬 알고리즘이다. 연결 리스트에 있는 데이터를 정렬할 때 퀵 정렬이나 힙 정렬보다 훨씬 효율적이다. CPU와 GPU를 이용한 병렬 프로세싱에서도 합병 정렬 알고리즘이 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Merge Sort”, Wikipedia, 2019. 1. 17, https://en.wikipedia.org/wiki/Merge_sort “3장분할정복알고리즘-0”, 영산대학교 교수 블로그, 2017. 1. 23, https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 분할 정복 알고리즘","slug":"algo4","date":"2019-01-16T12:37:50.000Z","updated":"2019-01-20T21:15:45.685Z","comments":true,"path":"2019/01/16/algo4/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo4/","excerpt":"","text":"1. 분할 정복 알고리즘이란?2. 분할 정복 알고리즘의 분류 1. 분할 정복 알고리즘이란? ‘분할 정복(Divide-and-Conquer) 알고리즘’이란 주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다.분할된 입력에 대하여 동일한 알고리즘을 적용 및 계산하고 결과들을 취합하여 원래 문제의 결과를 얻는다.분할된 입력에 대한 문제를 부분문제(subproblem)라고 하고, 부분문제의 해를 부분해라고 한다. 부분문제는 더이상 분할할 수 없을 때까지 계속 분할한다. 위 이미지는 분할 정복의 예이다. 그렇다면 입력 크기가 n일 때 총 몇 번 분할하여야 더 이상 분할할 수 없는 크기인 1이 될까? 답을 계산하기 위해 분할한 총 횟수를 k라고 하고, 1번 분할할 때마다 각각의 입력 크기가 절반씩 줄어든다고 가정한다. 이 때, k번 분할하였으면, 입력의 크기는 n/2k이고, 입력 크기가 n/2k=1일 때 더 이상 분할할 수 없으므로, k = log2n이다. 2. 분할 정복 알고리즘의 분류 분할 정복 알고리즘은 분할되는 부분문제의 수와 부분문제의 크기에 따라서 다음과 같이 분류할 수 있다. 입력이 2개의 부분문제로 분할, 부분문제의 크기가 1/2로 감소하는 알고리즘-&gt; 합병 정렬(Merge Sort) 입력이 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘-&gt; 퀵 정렬(Quick Sort) 입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없는 알고리즘-&gt; 이진 탐색(Binary Search) 입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘-&gt; 선택 문제(Selection) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Divide-and-conquer algorithm”, Wikipedia, 2019. 1. 16, https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 알고리즘을 배우기 위한 준비(2)","slug":"algo3","date":"2019-01-16T09:41:23.000Z","updated":"2019-01-22T05:00:48.945Z","comments":true,"path":"2019/01/16/algo3/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo3/","excerpt":"","text":"4. 알고리즘의 분류5. 알고리즘의 효율성 표현6. 복잡도의 점근적 표기7. 왜 효율적인 알고리즘이 필요한가? 4. 알고리즘의 분류 알고리즘은 문제의 해결 방식에 따라 다음과 같이 분류된다. 분할 정복 알고리즘(Divide-and-Conquer) 그리디 알고리즘(Greedy) 동적 계획 알고리즘(Dynamic Programming) 근사 알고리즘(Approximation) 백트래킹 기법(Backtracking) 분기 한정 기법(Branch-and-Bound) 이 외에도 랜덤 알고리즘, 병렬 알고리즘, 분산 알고리즘, 양자 알고리즘, 유전자 알고리즘 등이 있다.문제에 따라 어떤 알고리즘이 더 효율적일지는 다를 것이다.또한, 이름 지어지지 못한 알고리즘들도 다수 존재한다.위와 같이 해결 방식에 따른 알고리즘 분류 외에도 문제에 기반을 두어 알고리즘을 분류하기도 한다.정렬 알고리즘, 그래프 알고리즘, 기하 알고리즘 등이 그 예이다. 5. 알고리즘의 효율성 표현 알고리즘의 효율성은 알고리즘의 ‘수행 시간’ 또는 알고리즘이 수행하는 동안 사용되는 ‘메모리 공간의 크기’로 나타낼 수 있다. 이들을 각각 ‘시간복잡도’, ‘공간복잡도’라고 한다. 일반적으로 알고리즘들을 비교할 때에는 시간복잡도가 주로 사용된다. 알고리즘을 프로그램으로 구현 및 실행 시켜 시간을 측정할 수 있으나, 이러한 방법은 객관적으로 평가하기가 어렵다. 왜냐하면 컴퓨터 환경, 프로그래밍 언어, 프로그래머 실력 등에 의하여 달라질 수 있기 때문이다. 그리하여 시간복잡도는 알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수로 표현한다.예를 들어, n장의 숫자 카드 중에서 최대 숫자를 찾는데, 순차탐색으로 찾을 경우, (n-1)번의 비교를 수행한다. 이 경우, 시간복잡도는 (n-1)이다. 알고리즘의 복잡도를 표현하는 대는 다음과 같은 분석 방법들이 있다. 최악 경우 분석(worst case analysis) 평균 경우 분석(average case analysis) 최선 경우 분석(best case analysis) 일반적으로 ‘최악 경우 분석’으로 알고리즘의 복잡도를 나타낸다. 6. 복잡도의 점근적 표기 시간복잡도, 공간복잡도는 입력 크기에 대한 함수로 표기한다.이 때, 함수는 주로 다항식인데, 이를 단순하게 나타내기 위해 ‘점근적 표기(asymptotic notation)‘를 사용한다. 이는 입력 크기 n이 무한대로 커질 때의 복잡도를 간단하게 표현하기 위함이다. 예를 들어, 3n3-15n2+10n-18을 n3으로, 4n+6을 n으로 단순화시킨다.이 단순화된 식에 상한, 하한, 동일한 증가율과 같은 개념을 적용하여, 다음과 같이 점근적 표기를 사용한다. O(Big-Oh)-표기 : 점근적 상한 Ω(Big-Omega)-표기 : 점근적 하한 θ(Theta)-표기 : 상한과 하한이 동시에 적용되는 경우 O-표기는 복잡도의 ‘점근적 상한’, Ω-표기는 복잡도의 ‘점근적 하한’, θ-표기는 복잡도의 ‘상한과 하한이 동시에 적용’되는 경우를 나타낸다. 복잡도가 f(n) = 2n2-8n+3이라면, f(n)의 O-표기는 O(n2)이다. 의미는 다음과 같다.f(n)의 단순화된 표현 n2에 임의의 상수 c를 곱한 cn2이 n이 증가함에 따라 f(n)의 상한이 된다. 단, c&gt;0 (cn2은 n0 이상일 때, 항상 f(n)보다 큼) 마찬가지로, 교차점 이후 상한 관계를 만족하는 어떤 양수 c가 존재한다면, f(n) = O(n2)이다. f(n)의 Ω-표기는 Ω(n2)이다. 단, 의미는 ‘n이 증가함에 따라 2n2-8n+3이 cn2보다 작을 수 없다.’이다. 그렇기 때문에 이 경우 c=1이다. θ-표기는 복잡도의 O-표기와 θ-표기가 같은 경우에 사용한다. 의미는 ‘f(n)은 n이 증가함에 따라 n2과 동일한 증가율을 가진다.’라는 뜻이다. f(n) = 2n2+10n+3 = O(n2) = Ω(n2)이므로, f(n) = θ(n2)이다. 위 그래프에서 n0보다 큰 모든 n에 대해서 θ-표기가 상한과 하한을 동시에 만족한느 것을 보여준다. 7. 왜 효율적인 알고리즘이 필요한가? 입력이 커질수록 알고리즘에 따른 수행 시간의 차이가 매우 커지게 된다. 효율적인 알고리즘은 값비싼 하드웨어의 기술 개발보다 훨씬 더 경제적이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"}]},{"title":"[Algorithm] 알고리즘을 배우기 위한 준비(1)","slug":"algo2","date":"2019-01-15T17:08:43.000Z","updated":"2019-01-20T21:15:26.643Z","comments":true,"path":"2019/01/16/algo2/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo2/","excerpt":"","text":"1. 알고리즘이란?2. 최초의 알고리즘3. 알고리즘의 표현 방법 1. 알고리즘이란? 알고리즘은 문제를 해결하는 단계적 절차 또는 방법이다.컴퓨터 분야에서는 컴퓨터를 이용하여 해결할 수 있는 문제여야 한다. 다음은 알고리즘의 일반적인 특성이다.정확성 : 모든 입력에 대하여 원칙적으로 올바른 답을 출력해야 한다.수행성 : 각 단계는 컴퓨터에서 수행이 가능하여야 한다. 애매모호한 표현이 있게 될 경우, 컴퓨터에서 수행할 수 없다.유한성 : 알고리즘은 일정한 시간 내에 종료되어야 한다.효율성 : 알고리즘은 항상 시간적, 공간적인 효율을 갖도록 고안되어야 한다. 2. 최초의 알고리즘 가장 오래된 알고리즘은 기원전 300년경에 만들어진 유클리드의 최대공약수를 찾는 알고리즘이다.유클리드는 2개의 자연수의 최대공약수는 ‘큰 수에서 작은 수를 뺀 수’와 ‘작은 수’와의 최대공약수와 같다는 성질을 이용하였다. 예를 들어, 22와 10의 최대공약수는 12(22-10), 10(작은 수)의 최대 공약수와 같다.이것을 반복하면 다음과 같다.최대 공약수(22, 10)= 최대공약수(22-10, 10) = 최대공약수(12, 10)= 최대공약수(12-10, 10) = 최대공약수(2, 10)= 최대공약수(10-2, 2) = 최대공약수(8, 2)= 최대공약수(8-2, 2) = 최대공약수(6, 2)= 최대공약수(6-2, 2) = 최대공약수(4, 2)= 최대공약수(4-2, 2) = 최대공약수(2, 2)= 최대공약수(2-2, 2) = 최대공약수(0, 2)= 최대공약수(2, 0) = 2(단, 최대공약수(a, 0) = a 라고 한다.) 위 예시를 뺄셈 대신 나눗셈을 사용할 경우 매우 빠르다.12345Euclid(a,b)입력: 정수 a,b; 단, a&gt;=b&gt;=0출력: 최대공약수(a,b)if(b=0) return areturn Euclid(b, a mod b) 이 경우, Euclid(22, 10)에 대하여 위 알고리즘이 수행되는 과정은 다음과 같다.b = 10이므로, Euclid(10, 22 mod 10) = Euclid(10 ,2)이 호출b = 2이므로, Euclid(2, 10 mod 2) = Euclid(2,0)이 호출b = 0이므로, return a, 최종적으로 2를 반환한다. 3. 알고리즘의 표현 방법 알고리즘의 형태는 단계별 절차이므로, 컴퓨터 프로그래밍 언어로만 표현할 필요는 없다.그러나 일반적으로 프로그래밍 언어와 유사한 의사 코드로 표현한다.이전 포스트에서 다룬 ‘최대 숫자 찾기’ 알고리즘은 다음과 같다. 보통 말로 표현한 알고리즘12345첫 카드의 숫자를 읽고 머릿속에 기억해 둔다.다음 카드의 숫자를 읽고, 그 숫자를 머릿속의 숫자와 비교한다.비교 후 큰 숫자를 머릿속에 기억해 둔다.다음에 읽을 카드가 남아 있으면 line 2로 간다.머릿속에 기억된 수자가 최대 숫자이다. 의사 코드로 표현한 알고리즘1234max=A[0]for i = 1 to 9 if(A[i] &gt; max) max = A[i]return max 위 경우는 카드가 10장 있다고 가정한 경우이다. 알고리즘이 매우 간단하면, 보통 말로도 표현할 수 있으나, 복잡하면 표현하기 어렵다.그리하여 많은 경우 알고리즘을 의사코드로 표현한다.‘플로우 차트’형식으로도 알고리즘을 표현하기도 하지만, 매우 제한적인 경우이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"}]},{"title":"[Algorithm] 알고리즘의 첫걸음","slug":"algo1","date":"2019-01-15T12:02:20.000Z","updated":"2019-01-22T03:51:22.607Z","comments":true,"path":"2019/01/15/algo1/","link":"","permalink":"http://dudri63.github.io/2019/01/15/algo1/","excerpt":"","text":"1. 최대 숫자 찾기2. 임의의 숫자 찾기3. 동전 거스름돈4. 한붓 그리기5. 미로 찾기6. 가짜 동전 찾기7. 독이 든 술단지 알고리즘이란 문제를 해결하기 위한 단계적인 절차이다.주어진 문제에 대하여 여러 종류의 알고리즘이 있을 수 있지만, 보다 더 효율적인 알고리즘을 고안하는 것이 중요하다. 1. 최대 숫자 찾기 임의의 숫자가 적혀진 카드 10장이 바닥에 놓여있는 상황을 가정한다.가장 큰 숫자가 적힌 카드를 찾는 방법들은 무엇인가? 한 가지 방법은 카드의 숫자를 하나씩 비교, 가장 큰 숫자를 기억해가며 진행하는 방법이다.이러한 방식을 ‘순차탐색(Sequential Search)’이라고 한다. 2. 임의의 숫자 찾기 위와 같은 상황에서 특정한 숫자가 적힌 카드를 찾는 방법들은 무엇인가? 한 가지 방법은 찾으려고 하는 특정 숫자를 머리 속에 기억하고 펼쳐진 카드를 한 장씩 읽으며 해당 숫자를 찾는다.이러한 방식 역시 ‘순차탐색’을 이용한 것이다. 그런데, 10장의 카드가 오름차순으로 미리 정렬되어 있다고 가정한다.이러한 경우에는 순차탐색보다 더 효율적인 방법이 있다. 오름차순으로 정렬된 데이터를 반으로 나누고 나누어진 반을 다시 반으로 나누는 것을 반복하면서 원하는 데이터를 찾는다.이러한 탐색 알고리즘을 ‘이진탐색(Binary Search)’이라고 한다. 3. 동전 거스름돈 물건을 사고 거스름돈을 동전으로 받는 상황을 가정한다.대부분의 사람들은 거스름 돈으로 적은 수의 동전을 받기를 원한다.예를 들어, 거스름돈이 700원이라면 500원짜리 1개, 100원짜리 2개를 받기를 원한다.특별한 경우를 제외하고는 100원짜리 7개, 또는 10원짜리 70개를 받기를 원하지 않는다.그렇다면, 적은 수의 동전을 거스름돈으로 받기 위한 일반적인 방법은 무엇인가? 일반적으로 거스름돈에 대하여 가장 큰 액면의 동전부터 차례로 고려한다.남은 거스름돈 액수를 넘지 않는 한도에서 가장 큰 액면의 동전을 계속하여 선택하는 방법이다.즉, 710원이 거스름돈일 경우, 500원짜리부터, 100원, 10원 순서대로 선택한다.(710 - 500X1 = 210, 210 - 100X2 = 10, 10 - 10X1 = 0)이러한 알고리즘을 ‘그리디(Greedy) 알고리즘’이라고 한다. 4. 한붓그리기 종이에서 연필을 떼지 않고 그리는 것을 한붓그리기라고 한다.어느 한 점에서 출발하여 모든 선분을 한 번만 지나서 출발점으로 돌아오되, 그리는 동안 종이에서 연필이 떨어져서는 안 된다. 단, 한 점을 여러 차례 방문하여도 괜찮다.한붓그리기의 경우, 어떻게 해결 방안을 찾을 것인가? 현재 점으로부터 진행하고자 하는 점을 지나서 현재 점으로 돌아오는 ‘사이클(cycle)’을 찾는다. 5. 미로 찾기 복잡한 미로 속에 갇혀있을 때, 미로에서 탈출하는 방법은 무엇인가?일반적인 방법은 현 위치에서 한 방향을 선택하여 이동 후, 길이 막혀 있으면 다시 돌아 나와서 다른 방향으로 시도하는 것을 반복하는 것이다.그러나 이러한 방법은 매우 비효율적이다. 미로에서 나가는 방법 중 하나는 ‘오른속 법칙’을 이용하는 것이다. 벽에 오른손을 댄 뒤, 출구가 나올 때까지 오른속을 벽에서 떼지 않고 걸어간다.이러한 방법은 크레타 섬 미로의 실타래가 없어도, 미로에 특별한 표시를 하지 않아도 항상 출구를 찾게 해준다. 6. 가짜 동전 찾기 아주 많은 동전 더미 속에 1개의 가짜 동전이 섞여 있는 상황을 가정한다.가짜 동전은 눈으로 식별하 수 없으며, 오직 양팔 저울만을 이용해서 찾을 수 있다.(가짜 동전은 가볍다.)가능한 저울에 동전을 다는 횟수를 줄일 수 있는 방법들은 무엇인가? 첫 째, 임의의 동전 1개를 저울 왼편에 올리고, 나머지 동전을 하나씩 오른편에 올려서 가짜 동전을 찾는다.이 경우, 운이 좋다면 1번만에 가짜 동전을 찾을 수 있다.그러나 최악의 경우, 가짜 동전을 마지막으로 선택한다면, (n-1)번 저울을 재야 한다. 둘 째, 동전을 2개씩 짝을 지어, n/2 짝을 각각 저울에 달아서 가짜 동전을 찾는다.이 경우에도 마찬가지로, 운이 좋으면 첫 번째 짝을 저울에 올렸을 때 바로 가짜 동전을 발견할 수 있다.최악의 경우는 가짜 동전이 포함된 동전 짝을 가장 마지막으로 저울에 올렸을 때인데, 이 때 n/2번의 저울을 재야 한다. 셋 째, 동전들을 2개의 그룹으로 나눈 뒤 저울 양편에 각각 놓는다.그렇다면 2개의 그룹 중 가짜 동전이 어디 속해 있는지 알 수 있다.가짜 동전이 속해 있는 그룹을 다시 2개의 그룹으로 나누고, 위와 같은 작업을 반복한다.이러한 방법은 운이 좋고 나쁘고가 없다. 왜냐하면 가짜 동전은 어차피 마지막에 가서야 발견할 수 있기 때문이다.항상 log2n 횟수를 시행하여야 한다.그러나 동전의 갯수가 매우 많다면, 가장 효율적인 방법이다. 7. 독이 든 술단지 임금의 창고에는 매우 많은 술단지가 있는 상황을 가정한다. 그런데, 술단지 중 하나에 독이 들어가게 되었다.눈으로는 독이 들어간 술을 식별할 수 없다. 또한, 독이 든 술의 특징은 조금만 마셔도 정확히 일주일 뒤에 죽는다는 것이다.임금은 독이 든 술단지를 일주일 만에 찾아내라고 신하들에게 명령을 내렸다.어떻게하면 희생되는 신하의 수를 줄일 수 있을 것인가? 이러한 문제 해결의 핵심은 적은 수의 술단지에 대하여 우선 생각해 보는 것이다.술단지의 수를 늘려가면서 일반적인 규칙을 찾는 것이 중요하다. 술단지가 2개 있다고 가정한다.한 명의 신하가 하나의 술단지의 술을 맛보고 일주일 후 살아 있으면 먹지 않은 술단지에 독이 있는 것이고, 죽는다면 맛본 술단지에 독이 들어 있는 것이다. 술단지가 4개 있다고 가정한다.술단지를 두그룹으로 나눈다.신하 2명이 각 그룹의 술단지 2개 중 하나만을 맛본다.그렇다면, 맛보지 않은 술단지가 2개가 되어 일주일 후, 신하 2명이 모두 살아 있을 경우, 독이 든 술단지가 무엇인지 알 수 없게 된다.따라서, 신하 2명이 맛보지 않은 2개의 술단지 중 하나를 또한 동시에 맛보게 한다.이 경우 4개의 결과가 생기게 된다. 아무도 시음하지 않은 단지에 독이 있으면, 일주일 후 두 신하 모두 살아있다. 신하 A가 혼자 시음한 단지에 독이 있으면, 일주일 후 A만 죽는다. 신하 B가 혼자 시음한 단지에 독이 있으면, 일주일 후 B만 죽는다. A,B 둘 다 시음한 단지에 독이 있으면, 일주일 후 둘 다 죽는다. 그렇다면 술 단지 숫자가 많은 경우에는 어떻게 하여야 하는가?술단지에 ‘2진수’를 부여한다. 다음은 술단지가 8개일 때, 2진수 부여 및 술단지를 맛보는 신하들을 설정한 그림이다. 각 술단지의 번호에서 신하 A는 첫 번째 자리, 신하 B는 두 번째 자리, 신하 C는 세 번째 자리를 담당한다.그리고 술을 맛볼 경우 1로 표시, 그렇지 않을 경우 0으로 표시한다.이렇게 하여 단, 3명의 신하만을 이용하여 일주일 만에 독이 든 술단지가 무엇인지를 알 수 있다. 즉, 술단지를 2진수로 표현한 뒤, 각 비트당 한 명의 신하를 할당하는 방법이다.일반적으로 n개의 단지가 있으면, lob2n명의 신하만이 필요하다.일주일 후에 반드시 독이 든 술단지를 찾을 수 있고, 최소 희생자는 0명, 최대는 log2n명이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://dudri63.github.io/tags/알고리즘/"}]}]}