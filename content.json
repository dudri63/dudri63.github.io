{"meta":{"title":"Seo's Blog","subtitle":"Programming & Study","description":null,"author":"Seo Young Ki","url":"http://dudri63.github.io"},"pages":[{"title":"Categories","date":"2019-01-15T12:11:54.000Z","updated":"2019-01-16T10:55:20.481Z","comments":true,"path":"Categories/index.html","permalink":"http://dudri63.github.io/Categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-15T11:23:13.000Z","updated":"2019-01-15T11:38:54.543Z","comments":true,"path":"Tags/index.html","permalink":"http://dudri63.github.io/Tags/index.html","excerpt":"","text":""}],"posts":[{"title":"algo9","slug":"algo9","date":"2019-01-18T12:10:55.000Z","updated":"2019-01-18T12:10:55.201Z","comments":true,"path":"2019/01/18/algo9/","link":"","permalink":"http://dudri63.github.io/2019/01/18/algo9/","excerpt":"","text":"1. 1. Reference*","categories":[],"tags":[]},{"title":"algo8","slug":"algo8","date":"2019-01-18T12:10:52.000Z","updated":"2019-01-18T12:10:52.273Z","comments":true,"path":"2019/01/18/algo8/","link":"","permalink":"http://dudri63.github.io/2019/01/18/algo8/","excerpt":"","text":"1. 1. Reference*","categories":[],"tags":[]},{"title":"[Algorithm] 선택 문제 (분할정복)","slug":"algo7","date":"2019-01-18T12:05:24.000Z","updated":"2019-01-18T13:38:58.811Z","comments":true,"path":"2019/01/18/algo7/","link":"","permalink":"http://dudri63.github.io/2019/01/18/algo7/","excerpt":"","text":"1. 선택문제란2. 선택문제 알고리즘3. 시간 복잡도4. 응용 1. 선택문제란 ‘선택(selection) 문제’는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.선택문제는 Quick-Select 알고리즘이라고도 한다.간단한 방법은 최소 숫자들을 오름차순으로 정렬한 후, k번째 숫자를 찾는 것이다.그러나 이러한 알고리즘은 O(nlogn)의 수행 시간이 걸린다.이보다 효율적인 해결을 위하여 분할 정복 개념을 활용할 수 있다. 선택 문제는 입력이 정렬되어 있지 않으므로, 퀵 정렬과 마찬가지로 피봇을 선택하여 피봇보다 작은 숫자들은 피봇의 왼쪽으로, 큰 숫자들은 피봇의 오른쪽 숫자로 이동시킨다.이렇게 2개로 분할된 그룹들의 크기를 각각 파악하면, k번째로 작은 숫자가 2개의 그룹 중 어디에 속해있는 지를 알 수 있다.이 후, 원하는 숫자가 속해 있지 않은 그룹은 고려하지 않고, 숫자가 속해 있는 그룹에서 위와 같은 작업을 반복하여 k번째로 작은 숫자를 파악한다. (7-&gt;8, 9-&gt;10, ) 선택 문제 알고리즘은 문제가 2개의 부분문제로 분할되나, 그 중에 1개의 부분문제는 고려할 필요 없으며, 부분문제의 크기가 일정하지 않은 크기로 감소하는 형태의 분할 정복 알고리즘이다. 2. 선택문제 알고리즘 다음은 선택 문제를 위한 분할 정복 알고리즘이다. 1234567891011Selection(A, left, right, k)입력: A[left]~A[right]와 k, 단, 1&lt;=k&lt;=|A|, |A|=right-left+1출력: A[left]~A[right]에서 k번째 작은 원소피봇을 A[left]~A[right]에서 랜덤하게 선택,피봇과 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교,피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.S = (p+1)-left // S = small group의 크기if (k &lt;= S) Selection(A, left, p-1, k) // Small group에서 찾기else if (k = S + 1) return A[p] // 피봇이 k번째 숫자인 경우else Selection(A, p+1, right, k-S-1) // Large group에서 찾기 위 알고리즘에서 피봇은 small group에 속한다. 위 이미지에 이 알고리즘을 적용하여 살펴본다. k=10, 피봇은 A[0]인 23을 선택한다. (이 경우, A[left]를 피봇으로 선정하였음, 자리 변경 없음) 퀵 정렬과 마찬가지로 피봇과 원소들을 비교하여 자리를 바꾼 뒤, 피봇을 두 그룹의 가운데로 이동한다.(그림 상 1번 과정까지) p=7, small group의 크기는 8이므로, 10보다 작으니깐 small group은 이제 고려하지 않는다.(그림 상 2번 과정까지) Selection(A, 8, 15, 2)을 실시한다. 피봇은 A[8]인 44를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음) 2번 과정을 다시 수행한다. (그림상 3번 과정까지) p’=11, small group’의 크기는 4, 2&lt;4이므로 찾고자 하는 수는 small group’내에 있다. Selection(A, 8, 10, 10) 1. 1. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Quick Select”, AlgoCoding, 2019. 1. 18, http://www.algocoding.net/design/dc/quickselect.html","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"}]},{"title":"[Algorithm] 퀵 정렬 (분할정복)","slug":"algo6","date":"2019-01-17T10:07:32.000Z","updated":"2019-01-18T12:03:44.210Z","comments":true,"path":"2019/01/17/algo6/","link":"","permalink":"http://dudri63.github.io/2019/01/17/algo6/","excerpt":"","text":"1. 퀵 정렬이란2. 퀵 정렬 알고리즘3. 시간 복잡도4. 응용 1. 퀵 정렬이란 ‘퀵 정렬(Quick Sort)’은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 정복 후 분할하는 알고리즘이다. 퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다. 퀵 정렬의 아이디어는 피봇(pivot)이라 일컫는 배열의 원소를 기준으로 피봇보다 작은 숫자들은 왼편으로, 피봇보다 큰 숫자들은 오른편에 위치하도록 분할하고, 피봇을 그 사이에 놓는 것이다.단, 피봇은 분할된 왼편이나 오른편 부분에 포함되지 않는다. 위 경우는 피봇을 분할된 왼편과 오른편 부분에 가운데에 위치시켰다. 2. 퀵 정렬 알고리즘 다음은 퀵 정렬 알고리즘이다.123456789101112QuickSort(A, left, right)입력: 배열 A[left]~A[right]출력: 정렬된 배열 A[left]~A[right]if(left&lt;right)&#123; // 원소가 1개일 경우에는 정렬하지 않는다. 피봇을 A[left]~A[right] 중에서 선택, 피봇을 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교, 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고, 피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮긴다. 피봇은 A[p]에 놓는다. QuickSort(A, left, p-1) // 피봇보다 작은 그룹 QuickSort(A, p+1, right) // 피봇보다 큰 그룹&#125; 위 이미지를 이 알고리즘에 적용하여 살펴본다.초기상태의 배열에서 left는 0, right 8이다.피봇(A[pivot])을 A[0]인 1으로 선택한다.피봇 A[pivot]를 A[left]과 자리를 바꾼다.(이 경우, 피봇과 A[left]가 일치)피봇과 배열의 각 원소들과 비교를 실시하여 자리를 옮긴 뒤 피봇의 위치를 A[p]로 옮긴다.이 과정은 아래 그림에 잘 나와 있다. A[left+1], A[right]에서 출발하여 각각 오른쪽, 왼쪽으로 이동하면서, 비교를 진행한다.왼쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 작을 경우 정지,오른쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 클 경우 정지한다.양 쪽의 인덱스가 모두 정지하면 교환한다.이 작업 계속 실시하다가 두 인덱스가 엇갈려서 지난 경우, stop한다.이 후, 피봇의 위치를 가운데로 옮긴다. 위 작업을 실시한 후, 왼쪽 부분 리스트와 오른쪽 부분 리스트에 대하여 위 작업을 반복한다. 3. 시간 복잡도 퀵 정렬의 성능은 기본적으로 피봇 선택이 결정한다.항상 1/2씩 분할한다면 최선의 경우가 되지만(O(nlogn)),피봇으로 가장 작은 숫자 또는 가장 큰 숫자가 선택되면, 최악의 경우가 된다.(O(n2)) 최선의 경우 최악의 경우 피봇 선정 방법 퀵 저렬의 불균형한 분할을 완화시키기 위해서, 일반적으로 다음과 같은 피봇 선정 방법이 사용된다. 랜덤하게 선정 세 숫자의 중앙 값으로 선정하는 방법 입력의 크기가 매우 클 때, 퀵 정렬의 성능을 더 향상시키기 위해서, 삽입 정렬이 동시에 사용되기도 한다. 퀵 정렬을 재귀 호출로 수행되어 문제가 크기가 작아지면 중단하고, 삽입 정렬을 사용하면 효율적이다. 4. 응용 퀵 정렬은 커다란 크기의 입력에 대해서 가장 좋은 성능을 보이는 정렬 알고리즘이다. 퀵 정렬은 실질적으로 어느 정렬 알고리즘보다 좋은 성능을 보인다. 생물 정보 공학에서 특정 유전자를 효율적으로 찾는 데 퀵 정렬이 사용되곤 한다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “[알고리즘] 퀵 정렬(quick sort)이란”, Heee’s Development Blog, 2019. 1. 17, https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"}]},{"title":"[Algorithm] 합병 정렬 (분할정복)","slug":"algo5","date":"2019-01-17T07:41:43.000Z","updated":"2019-01-18T11:54:50.179Z","comments":true,"path":"2019/01/17/algo5/","link":"","permalink":"http://dudri63.github.io/2019/01/17/algo5/","excerpt":"","text":"1. 합병 정렬이란?2. 합병 정렬 알고리즘3. 시간 복잡도4. 응용 1. 합병 정렬이란? ‘합병 정렬(Merge Sort)’은 입력이 2개의 부분문제로 분할, 부분 문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다. 합병 과정이 문제를 정복한다는 것이 중요하다.합병(merge)이란 2개의 각각 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것이다. 2. 합병 정렬 알고리즘 다음은 분할 정복에 기반을 둔 합병 정렬 알고리즘이다.123456789MereSort(A,p,q)입력: A[p]~A[q]출력: 정렬된 A[p]~A[q]if(p &gt; q) &#123; // 배열의 원소의 수가 2개 이상이면, k = [(p+q)/2] // (k는 배열을 반으로 나누기 위한 중간 원소의 인덱스이다.) MergeSort(A,p,k) // 앞부분 재귀 호출 MergeSort(A,k+1,q) // 뒷부분 재귀 호출 A[p]~A[q]와 A[k+1]~A[q]를 합병한다.&#125; 분할하여 재귀 호출하는 것은 line 6, 7에서 수행되고, 합병은 line 8에서 수행된다. 위 그림에 이 알고리즘을 적용하여 살펴본다. A를 그림에서 가장 상위에 있는 배열, p를 6, q를 0이라고 한다. 그리하여 k는 3이 되고, 배열 A는 A[0]~A[3], A[4]~A[6] 두 부분으로 나뉜다. 이 작업을 배열의 원소가 한 개씩 남을 때까지 반복한다. 원소가 단, 1개인 배열들을 2개씩 합병한다. 분할된 배열들이 완성된 한 개의 배열이 될 때까지 4번을 반복한다. 3. 시간 복잡도 정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 나타낸다.위 그림에서 알고리즘이 수행한 비교 횟수를 본다.분할하는 부분은 배열의 중간 인덱스 계산과 2번의 재귀 호출을 하는 것이므로 O(1) 시간이 걸린다.이에 반해, 합병의 수행 시간은 입력의 크기에 비례한다.2개의 정렬된 배열 A, B의 크기가 각각 n, m이라면 최대 비교 횟수는 (n+m+-1)이다.마지막에 합병되는 숫자는 비교할 대상이 없으므로, -1을 한다.(그림에서 3,27,38,43 배열과 9,10,82 배열을 합치는 과정을 보면, 3을 9,10,82와 비교(3번), 27을 9,10,82와 비교(3번), 38을 82와 비교(1번), 43을 82와 비교(1번)이다. 총 8번의 비교를 하였다.)즉, 합병의 시간복잡도는 O(n+m)이다. 그러나 비교 횟수를 직접 세보는 것보다 더 쉬운 계산은 층별로 살피는 것이다.합병 과정에서 최종으로 만들어진 하나의 배열을 제외, 원소가 단 하나인 배열들로 구성된 층을 포함하여 총 3개의 층으로 이루어져 있는데, 각 층에서 모든 숫자가 합병에 참여하고 있다. 앞서 알아보았 듯이, 합병은 입력의 크기에 비례하므로 각 층에서 수행된 비교 횟수는 O(n)이다. 그런데, 층이 높아질수록(위로 올라갈수록) 입력의 크기(배열의 크기)가 반씩 줄어든다. 즉, 다음과 같다. 3층 : n/23 = 1 / {38}, {27}, {43}, {3}, {9}, {82}, {10} (n은 7) 2층 : n/22 = 2 / {27,38}, {3,43}, {9,82}, {10} 1층 : n/2 = 4 / {3,27,38,43}, {9,10,82} k번 1/2로 분할하였으면 k개의 층이 생기는 것이고, k=log2n임을 알 수 있다.결과적으로 합병 정렬의 시간복잡도는 (층수)XO(n) = log2nXO(n) = O(nlogn)이다.(각 층마다 모든 입력의 합은 n이다. 헷갈리지 말자. 그림을 보자.) 합병 정렬 알고리즘의 공간 복잡도는 O(n)이다. 왜냐하면 입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요하기 때문이다. 2개의 정렬된 부분을 하나로 합병하는 데 있어서, 합병된 결과를 저장할 곳이 필요하다. 4. 응용 합병 정렬은 외부정렬의 기본이 되는 정렬 알고리즘이다. 연결 리스트에 있는 데이터를 정렬할 때 퀵 정렬이나 힙 정렬보다 훨씬 효율적이다. CPU와 GPU를 이용한 병렬 프로세싱에서도 합병 정렬 알고리즘이 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Merge Sort”, Wikipedia, 2019. 1. 17, https://en.wikipedia.org/wiki/Merge_sort","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"}]},{"title":"[Algorithm] 분할 정복 알고리즘","slug":"algo4","date":"2019-01-16T12:37:50.000Z","updated":"2019-01-18T11:54:26.826Z","comments":true,"path":"2019/01/16/algo4/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo4/","excerpt":"","text":"1. 분할 정복 알고리즘이란?2. 분할 정복 알고리즘의 분류 1. 분할 정복 알고리즘이란? ‘분할 정복(Divide-and-Conquer) 알고리즘’이란 주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다.분할된 입력에 대하여 동일한 알고리즘을 적용 및 계산하고 결과들을 취합하여 원래 문제의 결과를 얻는다.분할된 입력에 대한 문제를 부분문제(subproblem)라고 하고, 부분문제의 해를 부분해라고 한다. 부분문제는 더이상 분할할 수 없을 때까지 계속 분할한다. 위 이미지는 분할 정복의 예이다. 그렇다면 입력 크기가 n일 때 총 몇 번 분할하여야 더 이상 분할할 수 없는 크기인 1이 될까? 답을 계산하기 위해 분할한 총 횟수를 k라고 하고, 1번 분할할 때마다 각각의 입력 크기가 절반씩 줄어든다고 가정한다. 이 때, k번 분할하였으면, 입력의 크기는 n/2k이고, 입력 크기가 n/2k=1일 때 더 이상 분할할 수 없으므로, k = log2n이다. 2. 분할 정복 알고리즘의 분류 분할 정복 알고리즘은 분할되는 부분문제의 수와 부분문제의 크기에 따라서 다음과 같이 분류할 수 있다. 입력이 2개의 부분문제로 분할, 부분문제의 크기가 1/2로 감소하는 알고리즘-&gt; 합병 정렬(Merge Sort) 입력이 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘-&gt; 퀵 정렬(Quick Sort) 입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없는 알고리즘-&gt; 이진 탐색(Binary Search) 입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘-&gt; 선택 문제(Selection) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Divide-and-conquer algorithm”, Wikipedia, 2019. 1. 16, https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"분할 정복","slug":"분할-정복","permalink":"http://dudri63.github.io/tags/분할-정복/"}]},{"title":"[Algorithm] 알고리즘을 배우기 위한 준비(2)","slug":"algo3","date":"2019-01-16T09:41:23.000Z","updated":"2019-01-16T12:35:00.418Z","comments":true,"path":"2019/01/16/algo3/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo3/","excerpt":"","text":"4. 알고리즘의 분류5. 알고리즘의 효율성 표현6. 복잡도의 점근적 표기7. 왜 효율적인 알고리즘이 필요한가? 4. 알고리즘의 분류 알고리즘은 문제의 해결 방식에 따라 다음과 같이 분류된다. 분할 정복 알고리즘(Divide-and-Conquer) 그리디 알고리즘(Greedy) 동적 계획 알고리즘(Dynamic Programming) 근사 알고리즘(Approximation) 백트래킹 기법(Backtracking) 분기 한정 기법(Branch-and-Bound) 이 외에도 랜덤 알고리즘, 병렬 알고리즘, 분산 알고리즘, 양자 알고리즘, 유전자 알고리즘 등이 있다.문제에 따라 어떤 알고리즘이 더 효율적일지는 다를 것이다.또한, 이름 지어지지 못한 알고리즘들도 다수 존재한다.위와 같이 해결 방식에 따른 알고리즘 분류 외에도 문제에 기반을 두어 알고리즘을 분류하기도 한다.정렬 알고리즘, 그래프 알고리즘, 기하 알고리즘 등이 그 예이다. 5. 알고리즘의 효율성 표현 알고리즘의 효율성은 알고리즘의 ‘수행 시간’ 또는 알고리즘이 수행하는 동안 사용되는 ‘메모리 공간의 크기’로 나타낼 수 있다. 이들을 각각 ‘시간복잡도’, ‘공간복잡도’라고 한다. 일반적으로 알고리즘들을 비교할 때에는 시간복잡도가 주로 사용된다. 알고리즘을 프로그램으로 구현 및 실행 시켜 시간을 측정할 수 있으나, 이러한 방법은 객관적으로 평가하기가 어렵다. 왜냐하면 컴퓨터 환경, 프로그래밍 언어, 프로그래머 실력 등에 의하여 달라질 수 있기 때문이다. 그리하여 시간복잡도는 알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수로 표현한다.예를 들어, n장의 숫자 카드 중에서 최대 숫자를 찾는데, 순차탐색으로 찾을 경우, (n-1)번의 비교를 수행한다. 이 경우, 시간복잡도는 (n-1)이다. 알고리즘의 복잡도를 표현하는 대는 다음과 같은 분석 방법들이 있다. 최악 경우 분석(worst case analysis) 평균 경우 분석(average case analysis) 최선 경우 분석(best case analysis) 일반적으로 ‘최악 경우 분석’으로 알고리즘의 복잡도를 나타낸다. 6. 복잡도의 점근적 표기 시간복잡도, 공간복잡도는 입력 크기에 대한 함수로 표기한다.이 때, 함수는 주로 다항식인데, 이를 단순하게 나타내기 위해 ‘점근적 표기(asymptotic notation)’를 사용한다. 이는 입력 크기 n이 무한대로 커질 때의 복잡도롤 간단하게 표현하기 위함이다. 예를 들어, 3n3-15n2+10n-18을 n3으로, 4n+6을 n으로 단순화시킨다.이 단순화된 식에 상한, 하한, 동일한 증가율과 같은 개념을 적용하여, 다음과 같이 점근적 표기를 사용한다. O(Big-Oh)-표기 Ω(Big-Omega)-표기 θ(Theta)-표기 O-표기는 복잡도의 ‘점근적 상한’, Ω-표기는 복잡도의 ‘점근적 하한’, θ-표기는 복잡도의 ‘상한과 하한이 동시에 적용’되는 경우를 나타낸다. 복잡도가 f(n) = 2n2-8n+3이라면, f(n)의 O-표기는 O(n2)이다. 의미는 다음과 같다.f(n)의 단순화된 표현 n2에 임의의 상수 c를 곱한 cn2이 n이 증가함에 따라 f(n)의 상한이 된다. 단, c&gt;0 위 경우, f(n)의 Ω-표기는 Ω(n2)이다. 단, 의미는 ‘n이 증가함에 따라 2n2-8n+3이 cn2보다 작을 수 없다.’이다. θ-표기는 복잡도의 O-표기와 θ-표기가 같은 경우에 사용한다. 의미는 ‘f(n)은 n이 증가함에 따라 n2과 동일한 증가율을 가진다.’라는 뜻이다. 7. 왜 효율적인 알고리즘이 필요한가? 입력이 커질수록 알고리즘에 따른 수행 시간의 차이가 매우 커지게 된다. 효율적인 알고리즘은 값비싼 하드웨어의 기술 개발보다 훨씬 더 경제적이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"}]},{"title":"[Algorithm] 알고리즘을 배우기 위한 준비(1)","slug":"algo2","date":"2019-01-15T17:08:43.000Z","updated":"2019-01-16T10:46:16.409Z","comments":true,"path":"2019/01/16/algo2/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo2/","excerpt":"","text":"1. 알고리즘이란?2. 최초의 알고리즘3. 알고리즘의 표현 방법 1. 알고리즘이란? 알고리즘은 문제를 해결하는 단계적 절차 또는 방법이다.컴퓨터 분야에서는 컴퓨터를 이용하여 해결할 수 있는 문제여야 한다. 다음은 알고리즘의 일반적인 특성이다.정확성 : 모든 입력에 대하여 원칙적으로 올바른 답을 출력해야 한다.수행성 : 각 단계는 컴퓨터에서 수행이 가능하여야 한다. 애매모호한 표현이 있게 될 경우, 컴퓨터에서 수행할 수 없다.유한성 : 알고리즘은 일정한 시간 내에 종료되어야 한다.효율성 : 알고리즘은 항상 시간적, 공간적인 효율을 갖도록 고안되어야 한다. 2. 최초의 알고리즘 가장 오래된 알고리즘은 기원전 300년경에 만들어진 유클리드의 최대공약수를 찾는 알고리즘이다.유클리드는 2개의 자연수의 최대공약수는 ‘큰 수에서 작은 수를 뺀 수’와 ‘작은 수’와의 최대공약수와 같다는 성질을 이용하였다. 예를 들어, 22와 10의 최대공약수는 12(22-10), 10(작은 수)의 최대 공약수와 같다.이것을 반복하면 다음과 같다.최대 공약수(22, 10)= 최대공약수(22-10, 10) = 최대공약수(12, 10)= 최대공약수(12-10, 10) = 최대공약수(2, 10)= 최대공약수(10-2, 2) = 최대공약수(8, 2)= 최대공약수(8-2, 2) = 최대공약수(6, 2)= 최대공약수(6-2, 2) = 최대공약수(4, 2)= 최대공약수(4-2, 2) = 최대공약수(2, 2)= 최대공약수(2-2, 2) = 최대공약수(0, 2)= 최대공약수(2, 0) = 2(단, 최대공약수(a, 0) = a 라고 한다.) 위 예시를 뺄셈 대신 나눗셈을 사용할 경우 매우 빠르다.12345Euclid(a,b)입력: 정수 a,b; 단, a&gt;=b&gt;=0출력: 최대공약수(a,b)if(b=0) return areturn Euclid(b, a mod b) 이 경우, Euclid(22, 10)에 대하여 위 알고리즘이 수행되는 과정은 다음과 같다.b = 10이므로, Euclid(10, 22 mod 10) = Euclid(10 ,2)이 호출b = 2이므로, Euclid(2, 10 mod 2) = Euclid(2,0)이 호출b = 0이므로, return a, 최종적으로 2를 반환한다. 3. 알고리즘의 표현 방법 알고리즘의 형태는 단계별 절차이므로, 컴퓨터 프로그래밍 언어로만 표현할 필요는 없다.그러나 일반적으로 프로그래밍 언어와 유사한 의사 코드로 표현한다.이전 포스트에서 다룬 ‘최대 숫자 찾기’ 알고리즘은 다음과 같다. 보통 말로 표현한 알고리즘12345첫 카드의 숫자를 읽고 머릿속에 기억해 둔다.다음 카드의 숫자를 읽고, 그 숫자를 머릿속의 숫자와 비교한다.비교 후 큰 숫자를 머릿속에 기억해 둔다.다음에 읽을 카드가 남아 있으면 line 2로 간다.머릿속에 기억된 수자가 최대 숫자이다. 의사 코드로 표현한 알고리즘1234max=A[0]for i = 1 to 9 if(A[i] &gt; max) max = A[i]return max 위 경우는 카드가 10장 있다고 가정한 경우이다. 알고리즘이 매우 간단하면, 보통 말로도 표현할 수 있으나, 복잡하면 표현하기 어렵다.그리하여 많은 경우 알고리즘을 의사코드로 표현한다.‘플로우 차트’형식으로도 알고리즘을 표현하기도 하지만, 매우 제한적인 경우이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"}]},{"title":"[Algorithm] 알고리즘의 첫걸음","slug":"algo1","date":"2019-01-15T12:02:20.000Z","updated":"2019-01-18T11:53:52.792Z","comments":true,"path":"2019/01/15/algo1/","link":"","permalink":"http://dudri63.github.io/2019/01/15/algo1/","excerpt":"","text":"1. 최대 숫자 찾기2. 임의의 숫자 찾기3. 동전 거스름돈4. 한붓 그리기5. 미로 찾기6. 가짜 동전 찾기7. 독이 든 술단지 알고리즘이란 문제를 해결하기 위한 단계적인 절차이다.주어진 문제에 대하여 여러 종류의 알고리즘이 있을 수 있지만, 보다 더 효율적인 알고리즘을 고안하는 것이 중요하다. 1. 최대 숫자 찾기 임의의 숫자가 적혀진 카드 10장이 바닥에 놓여있는 상황을 가정한다.가장 큰 숫자가 적힌 카드를 찾는 방법들은 무엇인가? 한 가지 방법은 카드의 숫자를 하나씩 비교, 가장 큰 숫자를 기억해가며 진행하는 방법이다.이러한 방식을 ‘순차탐색(Sequential Search)’이라고 한다. 2. 임의의 숫자 찾기 위와 같은 상황에서 특정한 숫자가 적힌 카드를 찾는 방법들은 무엇인가? 한 가지 방법은 찾으려고 하는 특정 숫자를 머리 속에 기억하고 펼쳐진 카드를 한 장씩 읽으며 해당 숫자를 찾는다.이러한 방식 역시 ‘순차탐색’을 이용한 것이다. 그런데, 10장의 카드가 오름차순으로 미리 정렬되어 있다고 가정한다.이러한 경우에는 순차탐색보다 더 효율적인 방법이 있다. 오름차순으로 정렬된 데이터를 반으로 나누고 나누어진 반을 다시 반으로 나누는 것을 반복하면서 원하는 데이터를 찾는다.이러한 탐색 알고리즘을 ‘이진탐색(Binary Search)’이라고 한다. 3. 동전 거스름돈 물건을 사고 거스름돈을 동전으로 받는 상황을 가정한다.대부분의 사람들은 거스름 돈으로 적은 수의 동전을 받기를 원한다.거스름돈이 700원이라면 500원짜리 1개, 100원짜리 2개를 받기를 원한다.특별한 경우를 제외하고는 100원짜리 7개, 또는 10원짜리 70개를 받기를 원하지 않는다.그렇다면, 적은 수의 동전을 거스름돈으로 받기 위한 일반적인 방법은 무엇인가? 일반적으로 거스름돈에 대하여 가장 큰 액면의 동전부터 차례로 고려한다.남은 거스름돈 액수를 넘지 않는 한도에서 가장 큰 액면의 동전을 계속하여 선택하는 방법이다.즉, 710원이 거스름돈일 경우, 500원짜리부터, 100원, 10원 순서대로 선택한다.(710 - 500X1 = 210, 210 - 100X2 = 10, 10 - 10X1 = 0)이러한 알고리즘을 ‘그리디(Greedy) 알고리즘’이라고 한다. 4. 한붓그리기 종이에서 연필을 떼지 않고 그리는 것을 한붓그리기라고 한다.어느 한 점에서 출발하여 모든 선분을 한 번만 지나서 출발점으로 돌아오되, 그리는 동안 종이에서 연필이 떨어져서는 안 된다. 단, 한 점을 여러 차례 방문하여도 괜찮다.한붓그리기의 경우, 어떻게 해결 방안을 찾을 것인가? 현재 점으로부터 진행하고자 하는 점을 지나서 현재 점으로 돌아오는 ‘사이클(cycle)’을 찾는다. 5. 미로 찾기 복잡한 미로 속에 갇혀있을 때, 미로에서 탈출하는 방법은 무엇인가?일반적인 방법은 현 위치에서 한 방향을 선택하여 이동 후, 길이 막혀 있으면 다시 돌아 나와서 다른 방향으로 시도하는 것을 반복하는 것이다.그러나 이러한 방법은 매우 비효율적이다. 미로에서 나가는 방법 중 하나는 ‘오른속 법칙’을 이용하는 것이다. 벽에 오른손을 댄 뒤, 출구가 나올 때까지 오른속을 벽에서 떼지 않고 걸어간다.이러한 방법은 크레타 섬 미로의 실타래가 없어도, 미로에 특별한 표시를 하지 않아도 항상 출구를 찾게 해준다. 6. 가짜 동전 찾기 아주 많은 동전 더미 속에 1개의 가짜 동전이 섞여 있는 상황을 가정한다.가짜 동전은 눈으로 식별하 수 없으며, 오직 양팔 저울만을 이용해서 찾을 수 있다.(가짜 동전은 가볍다.)가능한 저울에 동전을 다는 횟수를 줄일 수 있는 방법들은 무엇인가? 첫 째, 임의의 동전 1개를 저울 왼편에 올리고, 나머지 동전을 하나씩 오른편에 올려서 가짜 동전을 찾는다.이 경우, 운이 좋다면 1번만에 가짜 동전을 찾을 수 있다.그러나 최악의 경우, 가짜 동전을 마지막으로 선택한다면, (n-1)번 저울을 재야 한다. 둘 째, 동전을 2개씩 짝을 지어, n/2 짝을 각각 저울에 달아서 가짜 동전을 찾는다.이 경우에도 마찬가지로, 운이 좋으면 첫 번째 짝을 저울에 올렸을 때 바로 가짜 동전을 발견할 수 있다.최악의 경우는 가짜 동전이 포함된 동전 짝을 가장 마지막으로 저울에 올렸을 때인데, 이 때 n/2번의 저울을 재야 한다. 셋 째, 동전들을 2개의 그룹으로 나눈 뒤 저울 양편에 각각 놓는다.그렇다면 2개의 그룹 중 가짜 동전이 어디 속해 있는지 알 수 있다.가짜 동전이 속해 있는 그룹을 다시 2개의 그룹으로 나누고, 위와 같은 작업을 반복한다.이러한 방법은 운이 좋고 나쁘고가 없다. 왜냐하면 가짜 동전은 어차피 마지막에 가서야 발견할 수 있기 때문이다.항상 log2n 횟수를 시행하여야 한다.그러나 동전의 갯수가 매우 많다면, 가장 효율적인 방법이다. 7. 독이 든 술단지 임금의 창고에는 매우 많은 술단지가 있는 상황을 가정한다. 그런데, 술단지 중 하나에 독이 들어가게 되었다.눈으로는 독이 들어간 술을 식별할 수 없다. 또한, 독이 든 술의 특징은 조금만 마셔도 정확히 일주일 뒤에 죽는다는 것이다.임금은 독이 든 술단지를 일주일 만에 찾아내라고 신하들에게 명령을 내렸다.어떻게하면 희생되는 신하의 수를 줄일 수 있을 것인가? 이러한 문제 해결의 핵심은 적은 수의 술단지에 대하여 우선 생각해 보는 것이다.술단지의 수를 늘려가면서 일반적인 규칙을 찾는 것이 중요하다. 술단지가 2개 있다고 가정한다.한 명의 신하가 하나의 술단지의 술을 맛보고 일주일 후 살아 있으면 먹지 않은 술단지에 독이 있는 것이고, 죽는다면 맛본 술단지에 독이 들어 있는 것이다. 술단지가 4개 있다고 가정한다.술단지를 두그룹으로 나눈다.신하 2명이 각 그룹의 술단지 2개 중 하나만을 맛본다.그렇다면, 맛보지 않은 술단지가 2개가 되어 일주일 후, 신하 2명이 모두 살아 있을 경우, 독이 든 술단지가 무엇인지 알 수 없게 된다.따라서, 신하 2명이 맛보지 않은 2개의 술단지 중 하나를 또한 동시에 맛보게 한다.이 경우 4개의 결과가 생기게 된다. 아무도 시음하지 않은 단지에 독이 있으면, 일주일 후 두 신하 모두 살아있다. 신하 A가 혼자 시음한 단지에 독이 있으면, 일주일 후 A만 죽는다. 신하 B가 혼자 시음한 단지에 독이 있으면, 일주일 후 B만 죽는다. A,B 둘 다 시음한 단지에 독이 있으면, 일주일 후 둘 다 죽는다. 그렇다면 술 단지 숫자가 많은 경우에는 어떻게 하여야 하는가?술단지에 ‘2진수’를 부여한다. 다음은 술단지가 8개일 때, 2진수 부여 및 술단지를 맛보는 신하들을 설정한 그림이다. 각 술단지의 번호에서 신하 A는 첫 번째 자리, 신하 B는 두 번째 자리, 신하 C는 세 번째 자리를 담당한다.그리고 술을 맛볼 경우 1로 표시, 그렇지 않을 경우 0으로 표시한다.이렇게 하여 단, 3명의 신하만을 이용하여 일주일 만에 독이 든 술단지가 무엇인지를 알 수 있다. 즉, 술단지를 2진수로 표현한 뒤, 각 비트당 한 명의 신하를 할당하는 방법이다.일반적으로 n개의 단지가 있으면, lob2n명의 신하만이 필요하다.일주일 후에 반드시 독이 든 술단지를 찾을 수 있고, 최소 희생자는 0명, 최대는 log2n명이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"}]}]}