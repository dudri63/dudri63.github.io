{"meta":{"title":"NoName, IT blog","subtitle":"Programming & Study","description":null,"author":"Seo Young Ki","url":"http://dudri63.github.io"},"pages":[{"title":"Categories","date":"2019-01-15T12:11:54.000Z","updated":"2019-01-16T10:55:20.481Z","comments":true,"path":"Categories/index.html","permalink":"http://dudri63.github.io/Categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2019-01-15T11:23:13.000Z","updated":"2019-01-15T11:38:54.543Z","comments":true,"path":"Tags/index.html","permalink":"http://dudri63.github.io/Tags/index.html","excerpt":"","text":""}],"posts":[{"title":"[Java] 익명 객체(Anonymous Object)","slug":"java14","date":"2019-03-24T06:34:50.000Z","updated":"2019-03-24T07:13:54.333Z","comments":true,"path":"2019/03/24/java14/","link":"","permalink":"http://dudri63.github.io/2019/03/24/java14/","excerpt":"","text":"익명 클래스 : ‘이름이 없는’ 클래스 123456789public class Test&#123; private int num = 1; public int getNum()&#123; retrun this.num; &#125; public void setNum(int num)&#123; this.num = num; &#125;&#125; 위 코드에서는 Test라는 class가 있다.보통 인스턴스를 사용할 때는 다음과 같다. 1Test t1 = new Test(); 그러나 익명 인스턴스는 다음과 같다. 1234567Test t1 = new Test()&#123; public int num = 10; @Override public int getNum()&#123; return this.num; &#125;&#125;; 위 코드는 기존의 인스턴스 생성 방식과는 조금 다르다.왜냐하면 new Test()라는 코드 옆에 block이 존재하기 때문이다.위 코드는 new Test()라는 코드 때문에 Test 클래스의 인스턴스 t1을 생성하는 것 같지만, 실제로는 그렇지 않다.그 이유는 다음과 같다. getNum() 메소드가 Test 클래스의 멤버 메소드가 아니고, 재정의(Override)된 메소드이다. 변수 num이 값이 1이 아닌 10으로 변경되었다.즉, t1 인스턴스는 Test 클래스의 것이라기보다는, Test 클래스를 상속받은 다른 클래스의 인스턴스라고 보는 것이 더 가깝다. 익명 객체를 생성할 때에는 부모 클래스의 인스턴스를 생성하면서 {} 안에 처리구문을 넣는다.처리 구문은 부모클래스의 메소드를 오버라이드 해주는 것이다. 익명 클래스를 이용하면 아주 간단히 클래스를 생성, 바로 처리할 수 있다는 장점이 있다. Reference “JAVA-익명클래스(Anonymous class)란?”, 개발자로 홀로 서기, 2019. 3. 24, https://mommoo.tistory.com/16","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] Static","slug":"java13","date":"2019-03-24T05:37:35.000Z","updated":"2019-03-24T06:34:43.692Z","comments":true,"path":"2019/03/24/java13/","link":"","permalink":"http://dudri63.github.io/2019/03/24/java13/","excerpt":"","text":"1. static 변수1.1 메모리 효율1.2 공유2. static 메소드 static : 변수나 메소드 앞에 키워드로서 사용 1. static 변수 1.1 메모리 효율 다음과 같은 클래스가 있다.12345678public class HouseSeo &#123; String lastName = &quot;서&quot;; public static void main(String[] args) &#123; HousePark pey = new HouseSeo(); HousePark pes = new HouseSeo(); &#125;&#125; 위 클래스를 이용하여 객체를 생성하면 객체마다 객체변수 lastName을 저장하기 위한 메모리를 별도로 할당한다.그런데, HouseSeo 클래스의 lastName은 어떤 객체인지에 관계없이 모두 “서”이어야 한다.그러므로, 굳이 모든 객체마다 lastName을 저장하기 위한 메모리를 할당할 필요는 없다. 12345678public class HouseSeo &#123; static String lastName = &quot;서&quot;; public static void main(String[] args) &#123; HousePark pey = new HouseSeo(); HousePark pes = new HouseSeo(); &#125;&#125; 위와 같이 lastName 변수에 static 키워드를 붙이면, 자바는 메모리 할당을 딱 한번만 하게 되어, 메모리 사용상에 이점이 생기게 된다. cf. final 만약 static 변수의 값이 변경되지 않기를 원하는 경우가 생길 수도 있다.(위 경우, lastName이 “서”로 고정되기를 원하는 경우)이 때, final 키워드를 static 키워드 뒤에 붙이면 그 값을 변경하지 못하게 된다.ex. static final String lastName = “서”; 1.2 공유 static 변수를 사용하는 또 하나의 이유는 “공유”이다.static으로 변수를 설정할 경우, 같은 메모리 주소를 가리키게 된다.따라서, static 변수의 값을 공유하게 된다. 웹사이트의 방문자 인원 수 체크를 위한 경우 변수를 static으로 선언하면 좋다. 2. static 메소드 1234567891011121314151617public class Counter &#123; static int count = 0; Counter() &#123; this.count++; &#125; public static int getCount() &#123; return count; &#125; public static void main(String[] args) &#123; Counter c1 = new Counter(); Counter c2 = new Counter(); System.out.println(Counter.getCount()); &#125;&#125; 위 코드에서 getCount() 메소드가 static 메소드임을 유의한다.getCount()는 static 메소드임으로 Counter 객체를 따로 생성하지 않아도, Counter.getCount() 형식으로 메소드를 호출할 수 있다.즉, 클래스의 인스턴스 없이 호출이 가능하며, 인스턴스에서는 호출할 수 없다. Reference “07-3 정적 변수와 메소드”, 점프 투 자바, 2019. 3. 24, https://wikidocs.net/228","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Android] LOCATIONS","slug":"android12","date":"2019-03-21T10:43:15.000Z","updated":"2019-03-22T08:04:02.387Z","comments":true,"path":"2019/03/21/android12/","link":"","permalink":"http://dudri63.github.io/2019/03/21/android12/","excerpt":"","text":"Location Google Play 서비스의 location API를 사용하면 어플리케이션에서 사용자 디바이스의 최근 위치를 요청 가능 안드로이드에서는 두 가지 위치 permission을 제공, ACCESS_COARSE_LOCATION, ACCESS_FINE_LOCATION 선택한 permission에 따라서 API에 의해 받을 수 있는 위치 정확도가 결정됨 Location Services Client FusedLocationProviderClient 객체를 생성 onCreate() 함수에서 LocationServices 클래스의 getFusedLocationProviderClient 멤버 메소드를 호출한 뒤 그 주소값을 생성한 FusedLocationProviderClient타입의 객체에 저장 -&gt; location client 생성 Reference*","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] SENSORS","slug":"android11","date":"2019-03-21T09:32:41.000Z","updated":"2019-03-21T10:43:07.779Z","comments":true,"path":"2019/03/21/android11/","link":"","permalink":"http://dudri63.github.io/2019/03/21/android11/","excerpt":"","text":"Sensors 대부분의 안드로이드 장비는 모션, 방향 및 다양한 환경 상태를 측정하는 센서가 장착되어 있음 센서들은 정밀하고 정확한 raw 데이터를 제공 안드로이드 센서 플랫폼은 다음과 같이 분류할 수 있다. Motion sensors Environmental sensors Position sensors Sensor Framework : 센서에 접근, 센서데이터를 수집 센서 관련 작업을 수행하기 위한 클래스와 인터페이스를 제공 센서 프레임워크를 사용하면 다음과 같은 작업이 가능하다. 디바이스에서 사용가능한 센서들을 확인 최대 측정 범위, 제조사, 해상도 등 센서 능력에 대한 정보를 확인 수집하고자 하는 센서 데이터의 최소 수집 주기 설정 및 센서 데이터 수집 센서 변화를 추적하는 센서 이벤트 리스너를 등록하고 해제 SensorManager 센서 서비스 인스턴스를 만드는데 사용 센서 접근, 센서 목록 조회, 센서 이벤트 리스너 등록/해제 등을 위한 다양한 함수를 제공 Sensor 특정 센서의 인스턴스를 생성하기 위해 사용 센서 성능 등의 정보를 확인하기 위한 함수 제공 SensorEvent 센서 이벤트와 관련된 정보를 제공하기 위해서 시스템에서 SensorEvent 클래스를 사용 SensorEventListener 센서값 및 센서 정확도 변화에 대한 이벤트를 처리하는 두 개의 콜백을 만드는데 사용 일반적인 어플리케이션에서 센서 관련 API를 사용하기 위해서 두 가지 단계를 거친다. 센서와 센서의 성능에 관한 정보를 확인 센서 서비스에 대한 reference 획득 : 디바이스에 장착된 센서들을 확인 getSystemService() 함수를 호출, SensorManager 인스턴스를 생성 센서 이벤트 모니터링 : 센서를 모니터링, 센서 데이터를 수집 SensorEventListener 인터페이스를 이용 두 개의 콜백함수를 구현, onAccuracyChanged(), onSensorChanged() 안드로이드 시스템에서는 아래 상황에서 위 함수들이 호출됨 센서의 정확도가 변하는 경우 : onAccuracyChanged() 센서가 새로운 값을 측정한 경우 : onSensorChanged() Reference*","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] PERMISSIONS","slug":"android10","date":"2019-03-21T07:48:18.000Z","updated":"2019-03-21T09:32:32.617Z","comments":true,"path":"2019/03/21/android10/","link":"","permalink":"http://dudri63.github.io/2019/03/21/android10/","excerpt":"","text":"Permission 안드로이드 사용자의 개인정보를 보호하는 목적을 가짐 안드로이드 어플리케이션은 민감한 사용자 정보(eg.연착처)나 시스템의 특정 기능(eg.카메라)에 접근할 경우 permission을 요청해야 함 permission의 종류에 따라서 시스템에 해당 permission을 자동으로 허가해주거나 사용자에게 허가를 요청함 Permission approval manifest 파일에 &lt;uses-permission&gt; 태그를 이용, 사용하고자 하는 permission을 명시 다음은 어플리케이션에서 SMS를 보내는 권한을 명시하는 방법이다. normal permission : 사용자의 개인정보나 디바이스에 큰 위협을 미치지 않음, 시스템은 해당 permission을 자동으로 승인 dangerous permission : 사용자의 개인정보나 디바이스에 큰 위협 가능, 시스템은 해당 permission을 사용자에게 승인 받음 Dangerous Permission 사용자의 동의를 필요로 함 동의를 받는 방법 : 다운로드 받을 때 or 앱을 실행할 때 (디바이스 버전, sdk버전에 따라 다름) 디바이스의 안드로이드 버전이 6.0 이상, targetSdkVersion이 23 이상인 경우, 인스톨 시점에서 사용자에게 permission에 대한 정보를 제공하지 않고, 실행 중에 사용자에게 요청을 한다.(Runtime 요청) 안드로이드 버전 5.1.1 이하이거나 targetSdkVersion이 22이하일 경우, 시스템 설치 시점에 어플리케이션에서 요청하는 dagerous permission에 대한 권한을 요청(install-time 요청) 어플리케이션 Permission 요청 모든 안드로이드 어플리케이션은 sandbox 안에서 동작 사용자 resource or sandbox 밖에 있는 정보를 요청할 경우, 적절한 permission을 얻어야 함 manifest에 permission들을 추가 Permission 확인 어플리케이션에서 dagnerous permission이 필요한 경우, 해당 permission이 필요한 작업을 수행할 때 마다 permission을 확인해야 함 ContextCompact.checkSelfPermission() 함수를 사용 다음은 activity가 켈린더에 쓰기 권한이 있는지 확인하는 코드 어플리케이션이 permission이 있다면, PERMISSION_GRANTED가 반환, 다음 과정 수행 가능 어플리케이션이 permission이 없다면, PERMISSION_DENIED가 반환, 사용자에게 permission을 요청해야 한다. Permission 요청 특정 상황에서 어플리케이션에서 특정 permission을 요구한 이유를 설명하여 사용자의 이해를 도울 수 있다. 특히, 사용자가 이전에 permission을 거부한 적이 있다면, permission이 필요한 이유를 설명하는 것이 도움이 된다. shouldShowRequestPermissionRationale() 함수를 이용, 사용자가 이전에 permission을 거부한 경우가 있는지 확인할 수 있다. 어플리케이션에서 permission이 없는 경우, requestPermissions() 함수를 호출, 사용자에게 permission을 요청 Permission을 요청할 때 임의의 request code를 requestPermissions() 함수에 전달해야 한다. requestPermissions()은 비동기로 수행, 사용자가 응답을 완료한 후에 activity의 callback 함수로 request code와 함께 결과를 보낸다. Permission 요청 결과 처리 사용자가 permission 요청에 응답한 경우, 시스템은 어플리케이션의 onRequestPermissionsResult() 함수에 결과를 전달 시스템에서 onRequestPermissionResult()를 호출할 때, 어플리케이션에서 requestPermissions() 함수를 호출할 때 사용했던 request code를 넘겨 **t cf. SandBox 외부 접근 및 영향을 차단, 제한된 영역 내에서만 프로그램을 동작시키는 보안 모델 Reference* 줌","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] ListView","slug":"android9","date":"2019-03-19T07:56:09.000Z","updated":"2019-03-19T13:33:53.428Z","comments":true,"path":"2019/03/19/android9/","link":"","permalink":"http://dudri63.github.io/2019/03/19/android9/","excerpt":"","text":"1. 1. ListView ListView : 사용자가 정의한 데이터 목록을 아이템 단위로 구성, 화면에 출력하는 ViewGroup 세로 방향으로 나열 표시될 내용이 ListView의 크기를 넘어서게 되면 스크롤 기능을 사용할 수 있다. Adapter ListView에 데이터를 추가, 화면에 표시하기 위해서 Adapter 필요 사용자가 정의한 데이터를 ListView에 출력하기 위해 사용하는 객체 사용자 데이터와 화면 출력 View로 이루어진 두 개의 부분을 이어주는 객체 Reference*","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Java] instanceof 연산자","slug":"java12","date":"2019-03-18T13:24:38.000Z","updated":"2019-03-19T06:31:31.314Z","comments":true,"path":"2019/03/18/java12/","link":"","permalink":"http://dudri63.github.io/2019/03/18/java12/","excerpt":"","text":"instanceof : 객체 타입을 확인하는데 사용 이항연산자 형변환이 가능하면 true, 불가능하면 false로 리턴 조건문의 순서는 가장 최하위 클래스부터 작성 최상위 클래스를 맨 위에 적으면, 첫 번째 조건문에서 true를 만족, 첫번째 조건만을 수행하기 때문 Reference ‘Java instanceof란’, 신입 개발자, 2019. 3. 18, https://zzdd1558.tistory.com/ ‘JAVA 정리 - instanceof 연산자’, 감성프로그래밍, 2019. 3. 19, https://programmingsummaries.tistory.com/52","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Android] FRAGMENT","slug":"android8","date":"2019-03-18T11:59:29.000Z","updated":"2019-03-19T05:16:57.488Z","comments":true,"path":"2019/03/18/android8/","link":"","permalink":"http://dudri63.github.io/2019/03/18/android8/","excerpt":"","text":"1. Fragment2. Fragment 기본 사용법 1. Fragment Activity 화면에 출력되는 UI 구성의 가장 기본이 되는 요소 TextView, Button 등의 위젯을 화면에 표시하기 위해서는 최소한 하나의 Activity를 가져야 한다. 일반적으로 화면을 가득 채우지만, 화면의 일부에만 표시되도록 만들어 다른 Activity위에 띄울 수도 있다. Fragment Activity 내에 생성되는, UI 구성을 여러 개의 모듈 단위로 작성할 수 있도록 해주는 기능 한번 작성된 Fragment는 여러 Activity에서 재사용이 가능, UI 구성에 소요되는 작업량을 많은 부분 감소시킬 수 있음 자체 수명 주기를 가지고, 자체 입력 이벤트를 받으며, 엑티비티 실행 중에 추가 및 제거가 가능한 액티비티의 모듈식 섹션(= 다른 액티비티에 재사용할 수 있는 ‘하위 액티비티’와 같은 개념) activity와 다르게 몇가지 추가적인 lifecycle을 가지고 있음 onAttach() : fragment가 activity에 연결될 때 호출 onCreateView() : fragment의 view를 생성할 때 호출 onActivityCreated() : Activity의 onCreate()가 완료될 경우 호출 onDestroyView() : fragment의 view가 제거될 때 호출 onDetach() : fragment가 activity로부터 제거될 때 호출 위 그림은 프래그먼트로 정의한 두 가지 UI 모듈이 태블릿 디자인에서는 하나의 액티비티로 조합될 수 있는 반면, 핸드셋 디자인에서는 분리될 수 있다는 것을 보여준다. 2. Fragment 기본 사용법 Fragment에 대한 기본 사용법은 아래 링크를 참조한다. https://recipes4dev.tistory.com/58 Fragment는 재사용 가능한 Modular UI이지만, 각각의 Fragment 인스턴스는 부모 activity와 연결되어야 한다. Activity의 layout XML 파일에 fragment를 정의, activity와 연결 사용자 이벤트에 기반해 하나의 fragment에서 다른 fragment와 통신할 필요가 있는데, 모든 fragment끼리의 통신은 부모 activity를 통해서 하여야 한다. fragment가 activity와 통신하기 위해서는 fragment 클래스에 인터페이스를 정의하여야 하며, activity에서 인터페이스를 구현하여야 한다. cf. 인터페이스 : https://dudri63.github.io/2019/02/13/java3/#3.3 fragment는 onAttach() lifecycle에서 인터페이스를 저장, activity와 통신하기 위해서 저장한 인터페이스를 호출 onAttach() : fragment가 activity에 연결될 때 호출됨(activity 객체가 전달됨) Reference ‘안드로이드 프래그먼트 기본 사용법’, 개발자를 위한 레시피, 2019. 3. 18, https://recipes4dev.tistory.com/58","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] WIDGET","slug":"android7","date":"2019-03-18T09:20:02.000Z","updated":"2019-03-18T12:21:56.865Z","comments":true,"path":"2019/03/18/android7/","link":"","permalink":"http://dudri63.github.io/2019/03/18/android7/","excerpt":"","text":"1. Input Control1.1 Buttons1.2 Checkboxes1.3 Radio buttons1.4 Toggle buttons1.5 Spinners1.6 Pickers1.7 ListView2. Input Events 1. Input Control 입력 컨트롤은 어플리케이션 인터페이스 중 사용작용을 할 수 있는 UI이다.버튼, 텍스트 버튼, 체크박스, 토글 버튼 등이 있다. 1.1 Buttons 텍스트 또는 아이콘으로 구성 사용자가 터치할 때 이벤트를 발생해서 어플리케이션과 상호작용 android:onClick=&quot;&quot; : 버튼에 클릭 이벤트 헨들러를 정의 클릭 이벤트 핸들러는 프로그램에서 선언할 수도 있다. 1.2 Checkboxes 사용자가 목록에서 한 개 이상의 선택을 할 수 있도록 한다. 일반적으로 체크박스 옵션을 수직 리스트로 표시한다. 1.3 Radio buttons 사용자가 리스트에서 한 개를 선택할 수 있음 라디오버튼들은 상호 배타적이기 때문에, RadioGroup을 이용해 하나의 그룹으로 만듬 하나의 그룹으로 만듦으로써 시스템이 한 번에 하나의 라디오 버튼만 선택되도록 함 1.4 Toggle Buttons 사용자가 두 가지 상태 중 한 가지를 선택하도록 한다. 1.5 Spinners 목록에서 하나의 값을 선택하는 기능 제공 기본적으로 현재 표시된 값을 표시함 1.6 Pickers 사용자가 시간이나 날짜를 선택할 수 있는 컨트롤을 제공 시간 또는 날짜의 각 파트를 선택하는 컨트롤 제공 사용자가 유효한 시간/날짜를 선택할 수 있음 1.7 ListView 수직으로 스크롤 가능한 view들을 표시 리스트를 표시하는 유연하고 고성능의 방법은 RecyclerView를 사용하는 것 2. Input Events 어플리케이션에서 사용자의 상호작용 이벤트를 얻는 여러가지 방법이 존재한다. Event Listeners 하나의 콜백 함수를 가지는 View 클래스 내의 interface 이벤트가 발생할 경우, 안드로이드 프레임워크에 의해서 이 함수들이 호출됨 Event Handlers 기본 이벤트 핸들러로 사용될 콜백 함수를 정의할 수 있음 onKeyDown(int, KeyEvent) : 새로운 key 이벤트가 발생할 경우 호출 onKeyUp(int, KeyEvent) : key up 이벤트가 발생할 경우 호출 onTouchEvent(MotionEvent) : 터치 스크린 이벤트가 발생할 경우 호출 onFocusChanged(boolean, int, Rect) : view가 focus를 잃거나 얻을 경우 호출 Dialogs 사용자에게 결정이나 추가 정보를 획득하는 작은 창 일반적으로 사용자에게 다음 작업에 대한 확인을 위해 사용 DialogFragment를 확장, custom 레이아웃을 생성할 수 있음 cf. 콜백 함수(Callback Function) 다른 함수의 인자로써 이용되는 함수 어떤 이벤트에 의해 호출되어지는 함수 https://satisfactoryplace.tistory.com/18 Reference*","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] UI","slug":"android6","date":"2019-03-14T08:11:52.000Z","updated":"2019-03-14T11:26:54.526Z","comments":true,"path":"2019/03/14/android6/","link":"","permalink":"http://dudri63.github.io/2019/03/14/android6/","excerpt":"","text":"1. MANIFEST2. UI3. LAYOUT 1. MANIFEST 모든 어플리케이션은 최상위 디렉토리에 AndroidManifest.xml이라는 이름의 파일이 있다. Manifest 파일 : 시스템에 알려줘야 하는 어플리케이션에 대한 필수 정보를 담고 있음 Java 패키지, activity, service, broadcast recevier, component에 대한 정의 다른 어플리케이션 또는 접근 제한이 있는 API에 접근하기 위한 권한에 대한 정의 어플리케이션이 요구하는 API의 최소레벨에 대한 정의 어플리케이션에서 사용하는 라이브러리 파일에 대한 정의 &lt;application\\&gt; : 어플리케이션을 정의 어플리케이션의 component에 대한 정의 모든 component에 공통적으로 적용되는 속성을 정의 &lt;activity&gt; : activity(어플리케이션의 사용자 상호작용을 담당) 정의 모든 activity는 필드에 정의되어야 한다. 그렇지 않을 경우, 실행할 수 없음 &lt;intent-filter&gt; Activity, service, broadcast recevie가 반응할 수 있는 intent 종류를 정의 이 필드에 정의된 intent 타입만을 component에서 받을 수 있다. &lt;action&gt;, &lt;category&gt;, &lt;data&gt;를 사용해서 정의한다. &lt;uses-permission&gt; 어플리케이션이 시스템으로부터 받아야하는 권한에 대한 정의 퍼미션은 어플리케이션이 실행되는 동안 사용자에 의해 허가됨 2. UI 안드로이드 어플리케이션의 모든 UI element들은 View와 ViewGroup을 사용하여 구성 View : 사용자와 상호작용하는 화면에 어떤 것을 그리는 객체 ViewGroup : 인터페이스의 레이아웃을 정의하기 위해 View 또는 ViewGroup 객체들을 담는 객체 XML : 레이아웃을 정의하기 위해 사용 HTML과 비슷하게 사람이 읽을 수 있는 layout 구조를 제공 ex. &lt;TextView&gt;는 UI에 TextView 위젯을 생성, &lt;LinearLayout&gt;은 LinearLayout view group을 생성 ex. 다음은 간단한 텍스트 View와 Button을 가지고 있는 layout에 대한 xml 코드이다. 3. Layout Layout에 대한 설명은 이전 포스트를 참고한다. https://dudri63.github.io/2019/03/10/android3/ Reference*","categories":[{"name":"Etc.","slug":"Etc","permalink":"http://dudri63.github.io/categories/Etc/"},{"name":"Android","slug":"Etc/Android","permalink":"http://dudri63.github.io/categories/Etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] startActivityForResult, onActivityResult","slug":"android5","date":"2019-03-11T08:22:22.000Z","updated":"2019-03-11T12:44:38.950Z","comments":true,"path":"2019/03/11/android5/","link":"","permalink":"http://dudri63.github.io/2019/03/11/android5/","excerpt":"","text":"1. startActivityForResult2. VoteActivity3. onActivityResult 1. startActivityForResult 이전 포스팅에서는 엑티비티를 단순하게 전환하는 것을 보였다.그러나 후속 엑티비티에서 작업한 결과물을 호출한 엑티비티에서 사용하고 싶은 경우가 있을 수도 있다. 예를 들어, 카카오톡 어플에서 카메라 앱을 호출하고, 그 결과를 다시 카카오톡 어플로 가져오는 경우가 그것이다. 이러한 경우 startActivityForResult 메소드를 사용한다. 예를 들어, MainActivity에서 VOTE 버튼을 누르면, VoteActivity로 이동, VoteActivity에서 Yes, 혹은 No를 입력하면 그 결과를 MainActivity에서 보여주는 애플리케이션 작성을 가정한다.또한, VOTE 버튼을 누르면(OnClick), startView() 메소드가 호출된다. 다음은 startVeiw() 메소드이다. 1234public void startVote(View view) &#123; Intent intent = new Intent(this, VoteActivity.class); startActivityForResult(intent, REQUEST_VOTE);&#125; 주의할 점은 startActivity() 메소드 대신 결과 값을 리턴 받기를 원하기 때문에 startActivityForResult() 메소드를 사용한다는 점이다.startActivityForResult() 메소드는 전달한 인텐트와 requestCode(위 코드에서는, REQUEST_VOTE = 1)를 매개변수로 한다.requestCode를 함께 넘겨주는 이유는 onActivityResult 메소드에서 요청한 코드를 구분하기 위함이다. 2. VoteActivity 다음은 위에서 가정한 VoteActivity 코드 예시이다. 123456789101112131415public class VoteActivity extends AppCompatActivity &#123; public static final String EXTRA_RESULT = &quot;com.example.myfirstapp.vote.RESULT&quot;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_vote); &#125; public void sendYes(View view) &#123; Intent intent = new Intent(); intent.putExtra( EXTRA_RESULT , &quot;YES&quot;); // &quot;YES&quot;라는 데이터를 EXTRA_RESULT라는 이름으로 put setResult( RESULT_OK , intent); // setResult : 현재 엑티비티를 startActivityForResult로 호출한 엑티비티에게 결과 값을 전달함 finish(); &#125;&#125; 위 코드를 보면, 새로운 Intent를 생성, 해당 Intent에 데이터를 put한 뒤, setResult한다.setResult 메소드는 현재 엑티비티를 startActivityForresult로 호출한 엑티비티에게 결과 값을 전달하는 역할을 한다.구체적으로, 생성한 intent를 RESULT_OK라는 이름으로 저장한다.이 후, finish()를 이용하여 현재 엑티비티를 종료한다. 3. onActivityResult onActivityResult 메소드는 전환된 엑티비티(현재 가정에서는, VoteActivity)에서 결과값이 넘어오면 호출된다.onActivityResult 메소드의 매개변수중 하나인 requestActivity는 위에서 얘기한 것과 같은 기능을 수행한다.구체적으로, VoteActivity를 호출하는 엑티비티가 여러개 있을 경우 구분하기 위해 사용한다. 다음은 MainActivity에서 작성한 onActivityResult 예시이다.1234567891011121314private int REQUEST_VOTE = 1;protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == REQUEST_VOTE) &#123; // requestCode가 REQUEST_VOTE와 일치하면, if (resultCode == RESULT_OK) &#123; // resultCode가 RESULT_OK와 일치하면 String result = data.getStringExtra(VoteActivity.EXTRA_RESULT); // EXTRA_RESULT라는 이름을 가진 데이터에서 String 형식의 data를 get한다. TextView textView = findViewById(R.id.textView2); textView.setText(result); // textVeiw2라는 이름의 View의 text를 result가 가리키는 데이터로 설정한다. &#125; else &#123; // RESULT_CANCEL Toast.makeText(MainActivity.this, &quot;Failed&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; Reference “[안드로이드] startActivityForResult ,onActivityResult 사용법”, 키위남, 2019. 3. 11, https://liveonthekeyboard.tistory.com/entry/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-startActivityForResult-onActivityResult-%EC%82%AC%EC%9A%A9%EB%B2%95","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] Intent","slug":"android4","date":"2019-03-10T10:31:28.000Z","updated":"2019-03-11T11:09:45.238Z","comments":true,"path":"2019/03/10/android4/","link":"","permalink":"http://dudri63.github.io/2019/03/10/android4/","excerpt":"","text":"1. Intent2. 명시적 인텐트3. putExtra()4. getIntent(), getExtra()5. 암시적 인텐트 1. Intent Intent의 정의, explicit intent, implicit intent에 대한 설명은 아래 포스트를 참고한다. https://dudri63.github.io/2019/03/09/android2/#3 위 포스트의 내용을 요약하면 다음과 같다. Intent : 어플리케이션 구성요소(컴포넌트) 간 작업 수행을 위한 정보 전달 역할을 수행 ex. Activity간의 화면전환 (한 엑티비티에서 뷰들에게 액션을 취해 다른 엑티비티로 전환) 컴포넌트 A가 컴포넌트 B를 호출할 때 필요한 정보를 담고 있다. 컴포넌트 B의 이름을 명시적으로 표기, 혹은 속성들을 암시적으로 표기한다. cf.인텐트에 포함되어 전달되는 데이터를 엑스트라(extra) 라고 한다. 2. 명시적 인텐트 다음은 Intent 객체를 선언 및 할당하는 코드이다. Intent 객체명 = new Intent(A, B) 파라미터에는 현재 엑티비티와 전환할 엑티비티를 나타낸다. 사용 예시는 다음과 같다. 1Intet i = new Intent(this, SubActivity.class) 이 후, 다음과 같은 코드를 작성하면 전환될 엑티비티로 넘어간다. startActivity(intent) 만약, 현재 엑티비티를 종료하고 싶다면 다음과 같은 코드를 startActivity() 다음에 작성한다. finish() 3. putExtra() View EditText에 입력된 문자열을 넘겨줄 때 Intent 클래스의 putExtra 멤버 메소드를 사용한다.다음은 PutExtra를 사용하여 문자열을 넘기는 예시이다. 12345Intent intent = new Intent(this, subActivity.class); // Intent 생성EditText editText = findViewById(R.id.editText1); // editText1을 id로 하는view를 찾은 후 editText 객체가 그것의 주소를 참조함String message = editText.getText().toString() // getText : 입력한 글자를 얻어옴, toString : 글자를 String 형태로 변경intent.putExtra(&quot;text&quot;, message); // 넘겨줄 데이터의 이름을 &quot;text&quot;로 설정, 넘겨주는 데이터는 messagestartActivity(intent); // Activity 전환 4. getIntent(), getExtra() PutExtra()가 데이터를 전송하는 것이라면,getIntent()는 데이터를 받아오는 것이다.getIntent()는 자신을 호출한 엑티비티로부터 인텐트값을 받아온다.그리고 getExtra()는 해당 인텐트에서 put한 데이터를 받아온다.다음은 getIntent(), getExtra()를 사용하여 데이터를 받아오는 예시이다. 1234Intent intent = getIntent(); // 자신을 호출한 Activity로부터 intent값을 받아옴String message = intent.getStringExtra(MainActivity, &quot;text&quot;) // mainActivity로부터 &quot;text&quot;라는 이름의 데이터를 string형태로 받아온다.TextView textView = findViewByID(R.id.textView); // textView라는 ID를 가진 view를 찾은 후, textView 객체가 그것의 주소를 참조한다.textView.setText(message); // textView 객체의 setText() 메소드를 이용하여 message 데이터가 가리키는 데이터로 text를 설정한다. 5. 암시적 인텐트 암시적 인텐트는 명시적 인텐트와 달리 전환할 Activity를 Intent 객체 생성시에 명확하게 정의하지 않는다.대신에 원하는 기능을 입력하면, 해당 기능을 수행할 수 있는 Activity를 결정한다. 다음은 메세지를 다른 어플리케이션에 “공유”하는 암시적 인텐트 예시이다. 1234567891011public void shareMessageWithIntent(View view) &#123; Intent sendIntent = new Intent(); // 객체 생성시 인자를 입력하지 않고 호출한다. sendIntent.setAction(Intent.ACTION_SEND); // Intent 클래스의 setAction() 메소드 호출 EditText editText = findViewById(R.id.editText); // editText라는 View를 찾은 뒤, editText 객체가 참조하도록 한다. String textMessage = editText.getText().toString(); // editText가 참조하는 값의 데이터를 String 형태로 읽어들인 뒤, textMessage가 해당 주소를 참조한다. sendIntent.putExtra(Intent.EXTRA_TEXT, textMessage); // textMessage 데이터를 put한다. sendIntent.setType(&quot;text/plain&quot;); if (sendIntent.resolveActivity(getPackageManager()) != null) &#123; startActivity(sendIntent); &#125;&#125; 암시적 인텐트는 “공유”하기 기능 이외에도 다른 기능을 수행할 수 있다.다른 기능들은 다음 링크를 참조한다. https://gogorchg.tistory.com/entry/Android%ED%8E%8C%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-Intent-%EC%82%AC%EC%9A%A9%EB%B2%95 Reference “빠르게 배우는 안드로이드 — Intent -3 엑티비티간의 데이터 전송(기본데이터형) -1 + Log”, Medium(@Hyeong Do Yun), 2019. 3. 11, https://medium.com/@henen/%EB%B9%A0%EB%A5%B4%EA%B2%8C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-intent-3-%EC%97%91%ED%8B%B0%EB%B9%84%ED%8B%B0%EA%B0%84%EC%9D%98-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1-log-2561fc07e809 “[Android][펌]안드로이드 Intent 사용법”, 항상 초심으로, 2019. 3. 11, https://gogorchg.tistory.com/entry/Android%ED%8E%8C%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-Intent-%EC%82%AC%EC%9A%A9%EB%B2%95","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] Layout","slug":"android3","date":"2019-03-10T08:00:59.000Z","updated":"2019-03-18T11:58:15.734Z","comments":true,"path":"2019/03/10/android3/","link":"","permalink":"http://dudri63.github.io/2019/03/10/android3/","excerpt":"","text":"1. LAYOUT2. LAYOUT 종류2.1 Linear Layout2.2 Relative Layout2.3 Constraint Layout 1. LAYOUT Layout : activity or app 위젯을 위한 UI의 시각적 구조를 정의 XML 파일에 UI element를 정의 Runtime에 layout element들을 초기화 Attributes 모든 View와 ViewGroup 객체는 고유의 XML attribute를 가진다. 일부 attributes들은 View 객체별로 다르지만, 상속을 받은 View 객체는 부모의 attributes 역시 갖는다. ID 모든 View 객체는 View를 고유하게 식별할 수 있는 상수 ID를 가진다. 어플리케이션이 컴파일될 때, 아이디는 상수로 변환, layout XML에서는 문자열 형태이다. 모든 View 객체는 attribute가 정의되어 있다. XML 태그 내에 ID 문법은 다음과 같다.ex. &lt;Button android:id=&quot;@id/my_button&quot; ... /&gt; Layout Parameters layout_something : XML layout attribute, ViewGroup에 대한 View의 위치에 대해 정의 모든 view group들은 width, height를 가진다. wrap_content : view의 크기를 content의 크기로 설정 match_parent : view의 크기를 부모 view의 크기로 설정 Common Layouts ViewGroup의 하위 클래스들은 내부의 view들을 표시하는 고유의 방식을 제공 안드로이드 플랫폼에서 제공하는 layout 종류 중 가장 많이 이용되는 것들은 다음과 같다. Building Layouts with an Adapter Layout의 content가 가변적일 경우, 실행 중에 AdapterView를 사용해서 view들을 생성할 수 있음 AdapterView의 하위 클래스들은 layout에 데이터를 결합하기 위해 Adapter를 사용 Adapter는 데이터 소스와 AdapterView 사이에서 중간자 역할을 수행 다음은 Adapter를 사용하는 일반적인 layout들이다. 2. LAYOUT 종류 2.1 Linear Layout LinearLayout : 모든 자식 view들을 수평 또는 수직 방향으로 나열하는 view group android:orientation=”” : layout 방향을 설정 android:layout_weight=”” : 화면에서 얼마만큼 차지하는 지를 정의, 높은 weight 값을 가진 view가 부모 view에서 남은 공간을 많이 차지한다. 2.2 Relative Layout RelativeLayout : 자식 뷰들이 상대적 위치를 가지는 view group 각 view의 위치는 이웃 elements or 부모 relativeLayout 영역에 상대적으로 정의 중첩된 LinearLayout은 하나의 RelatvieLayout으로 변환할 수 있다. 다음은 RelativeLayout 내에 view에 적용할 수 있는 속성들이다. android:layout_alignParentTop=”” : if “true”, view의 윗쪽 면을 부모 view의 윗쪽 면에 위치 android:layout_centerVertical=”” : if “true”, view를 부모 view의 수직방향으로 중심이 위치 android:layout_below=”” : view의 윗쪽 면을 주어진 리소스 ID를 가진 view의 아래 위치 android:layout_toRightOf=”” : view의 왼쪽 면을 주어진 리소스 ID를 가진 view의 오른쪽에 위치 ex. 2.3 Constraint Layout ConstraintLayout : 단일 view 계층을 가지고 복잡하고 큰 layout 구성을 가능하게 한다. RelativeLayout과 비슷, 더 유연한 기능을 제공, 더 사용하기 쉽다. view의 위치를 정의하기 위해서는 view에 대해서 적어도 하나 이상의 수직/수평 constraint를 추가해야 한다. Convert a layout : 기존의 layout을 ConstraintLayout으로 변경할 수 있다. create a new ConstraintLayout : Root Tage에 “android.support.constraint.ConstraintLayout”을 입력 constraint를 만들 때의 주의사항은 다음과 같다. 모든 view는 적어도 두 개의 constraint를 가져야 한다 : 하나의 수직/수평 constraint 같은 면끼리 연결시켜야 한다. ex. 옆면은 옆면끼리 한 anchor에는 여러 개의 constraint handle이 올 수 있다. 각 constraint handle은 하나의 constraint를 만든다.(하나씩만 연결할 수 있다.) Alignment Baseline alignment Constraint to a guidline : 수직/수평 가이드 라인을 추가할 수 있고 가이드 라인은 어플리케이션 사용자에게 보이지 않음 Adjust the view size Fixed : 에디터에서 view를 조절하거나 아래의 텍스트 상자에 값을 입력 Wrap Content : contents가 필요한 만큼 view 크기를 확장함 Match Constraints : 각 사이드의 constraint를 만족하는 가장 큰 크기로 확장 Infer Constraints : 모든 view들에 가장 최적의 constraint를 찾음 Autoconnect : view를 추가할 때마다 자동적으로 두 개 또는 그 이상의 constraint를 자동으로 생성하짐나, 부모 view와의 constraint만을 생성 Relative positioning : 주어진 위젯을 다른 위젯에 상대적으로 위치시킴 Margins : 사이드 마진이 설정되면, 타겟과 소스 사이에 마진만큼 공간이 생김 Bias : Bias 속성을 사용하여 한쪽으로 치우치케 설정할 수 있음 Reference “안드로이드 레이아웃”, 개발자를 위한 레시피, 2019. 3. 10, https://recipes4dev.tistory.com/66?category=658689","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] Activity","slug":"android2","date":"2019-03-09T12:50:28.000Z","updated":"2019-03-19T05:15:21.219Z","comments":true,"path":"2019/03/09/android2/","link":"","permalink":"http://dudri63.github.io/2019/03/09/android2/","excerpt":"","text":"1. Activity2. MainActivity3. Intent4. Activity 종료1. Activity 추가 및 실행 1. Activity 일반적으로 안드로이드 시스템에서 앱이 실행되면, 전체 화면에 UI가 표시되고, 사용자가 입력한 화면 터치 등의 이벤트에 따라 앱의 기능이 수행된다.앱의 기능이 수행되는 과정에서, 최초 화면에 표시된 UI의 내용이 일부 변경 혹은 아예 새로운 UI가 화면의 전체 영역에 표시된다. 예를 들어, 다음과 같은 앱 실행 및 동작과정이 일어난다고 가정한다. 앱이 실행, 전체 화면에 앱의 UI를 표시 사용자가 입력한 화면 터치 또는 버튼 터치 등의 이벤트 처리 새로운 UI를 화면의 전체 영역에 표시 세가지 활동(작업, Activity)으로 분류할 수 있다.Activity란 앱에서 위와 같은 역할을 하는 주체이다. 2. MainActivity 안드로이드 Activity는 화면에 표시되는 UI 구성을 위해 가장 기본이 되는 요소이다.안드로이드 앱은 최소 하나 이상의 Activity가 있어야 하고, 앱 실행 시 지정된 Activity가 실행하게 된다. 앱 실행시 시작되는 Activity 정보는 “AndroidManifest.xml” 파일에서 확인할 수 있다.위 경우, MainActivity가 앱 실행시 최초로 보여지는 Activity이다. 단, Activty는 자체적으로 화면에 UI를 그리는 거이 아니며, View 또는 ViewGroup의 다양한 조합을 화면에 배치함으로써, UI를 표시한다. 다음은 MainActivity 클래스의 일부이다. 123456 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; R.layout.activity_main을 UI로 표시하고 있음을 확인할 수 있다. 3. Intent 현재 Activity에서 다른 Activity를 실행하는 방법은 startActivity()라는 함수를 호출하는 것이다.그런데, Activity를 실행할 때, 어떠한 의도(Intent)를 가지고 Activity를 실행하는지를 기술하여야 하는 과정이 필요하다. 다음은 어떤 Activity를 명시적(explicit)으로 실행, 암묵적(implicit)으로 실행하는 각각의 경우이다. A라는 Activity의 이름을 정확하게 안다면, 명시적으로 실행할 수 있다. ‘전화 걸기’라는 Activity는 직접 만든 것이 아니기 때문에, 정확한 이름을 모른다.따라서 위와 같이 암묵적인 방법으로 실행하여야 한다. Intent 클래스의 인스턴스를 생성하여 Activity를 실행하여야 한다. 4. Activity 종료 Activity가 실행된 후, 작업이 완료되어 해당 Activity를 종료할 때는, finish() 함수를 사용한다.혹은 finishActivity() 함수를 호출하여 이전에 실행한 특정 Activity를 종료한다. 5. Activity 추가 및 실행 새로운 Activity를 실행하기 위해 필요한 파일은 두 개이다.하나는 새로운 Activity 클래스 파일(ex. NewActivity.java),다른 하나는 새로운 Activity에 표실된 UI Layout이 정의된 Layout 리소스 XML 파일(ex. /res/layout/activity_new.xml”)이다. 새로운 Activity를 추가하고 실행하는 과정은 다음 링크를 참조한다. https://recipes4dev.tistory.com/69?category=660156 6. Activity Lifecycle 특정 액티비티가 실행되면, onCreate() -&gt; onStart() -&gt; onResume() -&gt; … 순서대로 실행이 된다. onCreate() : Activity가 최초 생성할 때 호출, 초기화 설정 onStart() : Activity가 사용자에게 보여지기 직전에 호출, Activity 화면을 표시 onResume() : Activity가 사용자와 상호작용을 하기 직전에 호출, 스택의 최상위에 위치 어플리케이션 종료 이벤트 발생 -&gt; onPause() 호출 Paused 상태에서 다시 onResume()을 호출하여 Resumed 상태로 돌아온다. onPause() : 다른 Activity가 활성화되었을 때 호출(추후 내용 추가 필요) Reference “안드로이드 액티비티.”, 개발자를 위한 레시피, 2019. 3. 9, https://recipes4dev.tistory.com/67?category=660156","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[Android] 안드로이드 스튜디오","slug":"android1","date":"2019-03-09T11:22:12.000Z","updated":"2019-03-10T07:58:04.793Z","comments":true,"path":"2019/03/09/android1/","link":"","permalink":"http://dudri63.github.io/2019/03/09/android1/","excerpt":"","text":"1. 안드로이드 스튜디오2. 안드로이드 에뮬레이터 1. 안드로이드 스튜디오 안드로이드 스튜디오 란 안드로이드 애플리케이션을 개발할 때 사용하는 통합 개발 환경(IDE) 이다.이클립스 IDE보다 훨씬 강력하고 특화된 기능을 제공하며, 구글 클라우드 플랫폼과 연계시켜 더욱 확장된 기능을 제공한다.이외의 안드로이드 스튜디오의 다른 장점들은 다음과 같다. 유연성이 좋은 그래들(Gradle) 기반의 자동화 프로젝트 빌드 시스템을 사용한다.(이클립스는 Ant 사용) 하나의 프로젝트 코드로 여러 안드로이드 장치용 애플리케이션을 구현할 수 있다. 프로젝트에 필요한 기본적인 코드와 파일들을 자동적으로 생성해준다. 그래픽 레이아웃 편집기의 기능이 강력하며, 사용이 쉬워서 사용자 인터페이스 디자인이 편리하다. 코드의 성능이나 버전 호환성 및 문제점을 잡아내는 Lint 기능이 강화되었다. 구글 클라우드 플랫폼을 자체적으로 지우너하여 구글 클라우드 메시징/앱 엔진과 쉽게 통합할 수 있다. 코드를 사전에 분석, 완성도를 보완해주고 리팩토링(refactoring)을 해주는 각종 분석 도구를 지원한다. 2. 안드로이드 에뮬레이터 안드로이드 개발 환경에서는 실제 하드웨어가 없어도 앱을 개발하고 테스트할 수 있는 안드로이드 에뮬레이터(Emulator) 가 제공된다.안드로이드 에뮬레이터는 안드로이드 스튜디오를 설치하면 같이 설치되는 소프트웨어로서, 단순히 앱을 실행하는 것뿐만 아니라, 개발자가 지정한 안드로이드 시스템을 시뮬레이션 화면에 표시한다. 안드로이드 에뮬레이터는 개발자가 결정한 여러가지 스펙(버전, 화면 크기, 메모리 등)으로 생성된 안드로이드 시스템(AVD, Android Virtual Device)을 실행시킨다. Reference “안드로이드 에뮬레이터 AVD 만들고 실행하기.”, 개발자를 위한 레시피, 2019. 3. 9, https://recipes4dev.tistory.com/145?category=779474","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Android","slug":"etc/Android","permalink":"http://dudri63.github.io/categories/etc/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://dudri63.github.io/tags/Android/"}]},{"title":"[자료구조] Stack (응용 자료구조)","slug":"ds7","date":"2019-03-05T00:49:47.000Z","updated":"2019-03-07T12:25:37.136Z","comments":true,"path":"2019/03/05/ds7/","link":"","permalink":"http://dudri63.github.io/2019/03/05/ds7/","excerpt":"","text":"1. 스택 1. 스택 자료를 구좌하는 가장 기본적인 방법은 자료를 순서대로 나열하여 리스트 를 구성하는 것이다. Array List (순차 자료구조), https://dudri63.github.io/2019/02/19/ds3/ Singly Linked List (연결 자료구조), https://dudri63.github.io/2019/02/21/ds4/ Doubly Linked List (연결 자료구조), https://dudri63.github.io/2019/02/28/ds5/ 몇 가지 규칙을 추가, 리스트를 응용한 자료구조를 만들 수 있다. 스택 은 같은 구조와 크기의 자료를 top이라고 정한 한 곳으로만 쌓을 수 있고, top으로만 접근하도록 제한하여 만든 자료구조이다.삽입되는 새 자료는 top이 가리키고 있는 자료의 위에 쌓여 마지막 자료가 되고, top은 이 새로운 자료를 가리키게 된다.삭제할 때도 top을 통해서만 가능하기 때문에 top이 가리키고 있는 스택의 마지막 자료만을 삭제할 수 있다.다음은 스택의 구조를 논리적으로 표현한 것이다. 따라서 스택은 후입선출(LIFO, Last-In-First_Out)의 구조를 갖는다. 스택에서 top을 통한 삽입 연산을 push,top을 통한 삭제 연산을 pop이라고 한다. 2. 스택의 추상 자료형 다음은 스택에서 가능한 자료형과 연산작업을 추상화한 것이다. 123456789101112131415ADT Stack데이터 : 0개 이상의 원소를 가진 유한 순서 리스트연산 : S ∈ Stack; item ∈ Element; createStack() ::= create an empty Stack // 공백 스택을 생성 isEmpty(S) ::= if (S is empty) then return true else return false; push(S, item) ::= insert item onto the top of S; pop(S) ::= if (isEmpty(S)) then return error else &#123;delete and return the top item of S&#125;; // 스택 S의 top에 있는 item을 삭제 및 반환 delete(S) ::= if (isEmpty(S)) then return error else delete the top item; // 스택 S의 top에 있는 item을 삭제 peek(S) ::= if (isEmpty(S)) then return error else return (the top item of the S); // 스택 S의 top에 있는 item을 반환End Stack 3. 스택의 push, pop 알고리즘 다음은 스택의 push 알고리즘이다. 123456push(S, x) top &lt;- top + 1; if (top &gt; stack_SIZE) then overflow; else S(top) &lt;- x;end push 다음은 스택의 pop 알고리즘이다. 1234567pop(S) if (top = 0) then error; else &#123; return S(top); top &lt;- top-1; &#125;end pop() 4. 스택의 구현 4.1 순차 자료구조 방식의 스택 구현 Stack.java https://github.com/dudri63/dataStructure/blob/master/ArrayStack/Stack.java ArrayStack.javahttps://github.com/dudri63/dataStructure/blob/master/ArrayStack/ArrayStack.java Ex_ArrayStack.java https://github.com/dudri63/dataStructure/blob/master/ArrayStack/Ex_ArrayStack.java 구현 예시 4.2 연결 자료구조 방식의 스택 구현 순차 자료구조를 이용한 스택은 배열을 사용하여 구현하기 용이하다.그러나 물리적으로 크기가 고정, 스택의 크기 변경이 어렵다.또한, 메모리 낭비 가능성이 높다. 연결 자료구조를 이용한 스택은 위와 같은 문제점들을 상당 부분 개선시킨다. Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[자료구조] Polynomial (연결 자료구조)","slug":"ds6","date":"2019-03-04T06:26:03.000Z","updated":"2019-03-04T08:48:54.198Z","comments":true,"path":"2019/03/04/ds6/","link":"","permalink":"http://dudri63.github.io/2019/03/04/ds6/","excerpt":"","text":"1. Polynomial 연결 자료구조 표현2. appendPoly 알고리즘3. addPoly 알고리즘4. 문제점 1. Polynomial 연결 자료구조 표현 이전에 다항식을 순차 자료구조(Array List)를 이용하여 표현하는 방법을 포스팅하였다. 다항식의 순차 자료구조 표현 본 포스팅에서는 단순 연결 리스트(Singly Linked List)를 이용하여 다항식을 표현하는 방법을 다룬다. 기본적으로 다항식의 하나의 항을 하나의 노드로 표현한다.그러나 순차 자료구조로 표현했을 때와는 달리, 각 항의 계수, 지수 모두를 저장해야 하므로 노드의 구조는 다음과 같은 형태도 달라지게 된다. 12345public class Node&#123; float coef; int expo; Node link;&#125; 2. appendTerm 알고리즘 다음은 다항식에 새로운 항(노드)을 추가하는 알고리즘이다. 1234567891011121314appendTerm(PL, coef, expo, last) new &lt;- getNode(); new.expo &lt;- expo; new.coef &lt;- coef; new.link &lt;- null; if (PL = null) then &#123; PL &lt;- new; last &lt;- new; &#125; else &#123; last.link &lt;- new; last &lt;- new; &#125;end appendTerm() 다항식 리스트 PL에 새로운 항(노드)를 추가하려면, 추가하려는 항의 계수, 지수를 알아야 한다.또한, 리스트의 마지막 노드의 위치를 파악안 후, 그 노드에 연결시키도록한다. 3. addPoly 알고리즘 123456789101112131415161718192021222324252627282930addPoly(A, B) // 다항식 A,B를 더하여 새로운 다항식 C를 반환p &lt;- A;q &lt;- B;C &lt;- null;r &lt;- null; // r은 결과 다항식의 마지막 노드를 지시while(p ≠ null and q ≠ null) do &#123; // p, q는 순회용 참조변수 case &#123; p.expo = q.expo : sum &lt;- p.coef + q.coef if (sum ≠ 0) then appendTerm(C, sum, p.expo, r); p &lt;- p.link; q &lt;- q.link; p.expo &lt; q.expo : appendTerm(C, q.coef, q.expo, r); q &lt;- q.link; else : appendTerm(C, p.coef, p.expo, r); p &lt;- p.link; &#125;&#125;while (p ≠ null) do &#123; appendTerm(C, p.coef, p.expo, r); p &lt;- p.link;&#125;while (q ≠ null) do &#123; appendTerm(C, q.coef, q.expo, r); q &lt;- q.link;&#125;return C;end addPoly() 4. 문제점 위 두 알고리즘을 이용하여 다항식 구현, 다항식에 새로운 항을 삽입하는 것을 구현하는 것은 사실 어렵다.왜냐하면, appendPoly 알고리즘은 항을 추가할 때, 반드시 리스트의 마지막 부분에 추가가 되도록 하고 있다.그렇다면, 리스트 순서상 고차항이 저차항의 뒷부분에 들어갈 수도 있게 된다.이 상황에서 addPoly 알고리즘은 각 리스트가 지수를 기준으로 내림차순으로 정렬된 것을 가정하고 각 항을 더해 나간다.그러므로 위 알고리즘을 실질적으로 구현하기 위해서는 새로운 알고리즘을 추가하거나, 다른 알고리즘을 작성하는 것이 옳을 것으로 판단된다. Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[Java] ==, equals의 차이","slug":"java11","date":"2019-02-28T08:19:20.000Z","updated":"2019-02-28T08:39:12.087Z","comments":true,"path":"2019/02/28/java11/","link":"","permalink":"http://dudri63.github.io/2019/02/28/java11/","excerpt":"","text":"== : 연산자 / 대상의 주소값을 비교 equals() : 메소드 / 대상의 내용 자체를 비교 자세한 내용은 아래 사이트를 참고한다. Reference “equals와 ==의 차이점”, O!JAVA, 2019. 2. 28, https://ojava.tistory.com/15","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[자료구조] Doubly Linked List (연결 자료구조)","slug":"ds5","date":"2019-02-28T08:16:04.000Z","updated":"2019-03-04T06:24:03.041Z","comments":true,"path":"2019/02/28/ds5/","link":"","permalink":"http://dudri63.github.io/2019/02/28/ds5/","excerpt":"","text":"1. 이중 연결 리스트2. 삽입, 삭제 연산3. 코드 1. 이중 연결 리스트 단순 연결리스트(Singly Linked List) 는 선행 노드에 접근하기가 어렵다는 단점이 있다.원형 연결리스트(Circular Linked List) 는 단순 연결리스트에 비하여 선행 노드에 접근하기는 쉬우나, 전체 리스트를 한바퀴 순회해야 한다.위 연결리스트들은 모두 리스트의 링크 필드가 한 방향으로만 이어지게 되었기 때문에 선행 노드에 접근하기는 좀처럼 쉽지 않다. 이중 연결 리스트(Doubly Linked List) 는 양쪽 방향으로 각 노드에 접근할 수 있도록 구성한 리스트이다.이중 연결 리스트의 노드 구조는 다음과 같다. 두 개의 링크 필드와 한 개의 데이터 필드로 구성되어 있다. 12345public class DblNode&#123; DblNode llink; String data; DblNode rlink;&#125; 2. 삽입, 삭제 연산 다음은 이중 연결 리스트에서 원소 삽입을 하는 알고리즘이다. 1234567insertNode(Dl, pre, x) new &lt;- getNode(); new.data &lt;- x; new.rlink &lt;- pre.rlink; pre.rlink &lt;- new; new.llink &lt;- pre; new.rlink.llink &lt;- new; 다음은 이중 연결 리스트에서 원소 삭제를 하는 알고리즘이다. 12345deleteNode(Dl, old) old.llink.rlink &lt;- old.rlink; old.rlink.llink &lt;- old.llink; returnNode(old); // 삭제된 old 노드를 자유 공간 리스트에 반환end deleteNode() 3. 코드 DblNode https://github.com/dudri63/dataStructure/blob/master/DoublyLinkedList/DblList.java DblList https://github.com/dudri63/dataStructure/blob/master/DoublyLinkedList/DblList.java Ex_dblList https://github.com/dudri63/dataStructure/blob/master/DoublyLinkedList/DblList.java Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[Java] 콘솔 입출력","slug":"java10","date":"2019-02-27T07:19:58.000Z","updated":"2019-02-27T11:13:23.197Z","comments":true,"path":"2019/02/27/java10/","link":"","permalink":"http://dudri63.github.io/2019/02/27/java10/","excerpt":"","text":"1. 콘솔 입출력2. System 클래스3. 콘솔 입력3.1 InputStream 클래스3.2 InputStreamReader 클래스3.3 BufferedReader 클래스3.4 Scanner 클래스4. 콘솔 출력 1. 콘솔 입출력 프로그램을 실행하였더니 문자열이 출력되었다.이러한 경우, 사용자에게 문자열을 보여주는 것이 콘솔 출력 이다. 또한, 사용자가 해당 프로그램에서 키보드를 이용하여 문자열을 입력한다면,이는 콘솔 입력 이다. 콘솔 이란 환경에 따라 변경될 수 있는 것으로서, 사용자의 입력을 받거나 사용자에게 문자열을 출력해 주는 역할을 하는 것을 통칭하는 말이다.ex.이클립스에서 프로그램을 실행 -&gt; 이클립스 콘솔창이 콘솔도스 명령창에서 프로그램을 실행 -&gt; 도스 명령창이 콘솔 2. System 클래스 Java는 스크린과 키보드를 통한 입출력 방법인 ‘표준 입출력’을 제공한다.표준 입출력을 제공하는 클래스는 java.lang.System인데, 멤버 변수인 in, our, err을 이용하여 표준 입력, 표준 출력, 표준 에러를 제공한다. 3. 콘솔 입력 3.1 InputStream 클래스 자바의 System.in을 이용하면 콘솔 입력을 얻을 수 있다. 123456789101112import java.io.InputStream;public class Ex_Stream &#123; public static void main(String[] args) throws Exception &#123; InputStream in = System.in; int a; a = in.read(); System.out.println(a); &#125;&#125; InputStream은 자바의 내장 클래스이다.(그러나, InputStream은 java.lang 패키지에 속해 있지 않은 클래스이기 때문에 import를 해야 사용할 수 있다. 예를 들어, System이나 String 등의 클래스는 java.lang 패키지에 속해 있기 때문에 별도의 import 과정이 필요 없다.)System.in은 InputStream의 객체이다. 이 후, InpuStream 클래스의 read 멤버 메소드로 1byte의 데이터를 읽을 수 있으며, byte 자료형이 아닌 int 자료형으로 저장된다. (0~255)저장되는 int값은 아스키 코드값이다. 0의 아스키 코드값은 48, a의 아스키 코드값은 97이다. 1byte의 데이터만을 읽어들일 수 있기 때문에, “abc” 3byte는 정상적으로 읽을 수 없다. 스트림(Stream) 이란 이어져 있는 데이터(byte)의 형태이다.프로그래밍에서는 다음과 같은 것들을 스트림이라고 한다. 파일 데이터 HTTP 응답 데이터 키보드 입력 그런데 위와 같이 1byte의 데이터만을 읽어들여서는, 스트림을 정상적으로 읽어들이기 어렵다. 1234567891011121314import java.io.InputStream;public class Ex_Stream &#123; public static void main(String[] args) throws Exception &#123; InputStream in = System.in; byte a[] = new byte[3]; in.read(a); System.out.println(a[0]); System.out.println(a[1]); System.out.println(a[2]); &#125;&#125; 위 코드와 같이, byte형 배열을 선언한 뒤, 콘솔 입력을 받을 수도 있다.그러나, 입력한 문자열을 byte 자료형으로 읽어들인 뒤, 아스키 코드 형태로 출력하기 때문에 여전히 불안정한 방식이다. 3.2 InputStreamReader 클래스 InputStreamReader 객체를 사용하면 byte 배열을 선언하지 않고, char 배열을 대신 사용할 수 있다.그리하여 입력받은 문자열을 다시 문자열 형태로 출력할 수 있다. 12345678910111213import java.io.InputStream;import java.io.InputStreamReader;public class Ex_Stream &#123; public static void main(String[] args) throws Exception &#123; InputStream in = System.in; InputStreamReader reader = new InputStreamReader(in); char[] a = new char[3]; reader.read(a); System.out.println(a); &#125;&#125; InputStream 객체는 바이트 스트림을 읽어들이는 것에 반하여,InputStreamReader 객체는 문자로 입력 스트림을 읽는다. InputStreamReader 객체는 InputStream 객체를 매개변수로 하여 생성된다.이후 InputStreamReader의 멤버 메소드인 read()를 이용, 스트림을 읽는다. 그러나 입력을 받을 때, 고정된 길이로만 스트림을 읽어야 하는 단점이 있다. 3.3 BufferedReader 클래스 BufferedReader 클래스를 사용하면, 가변 길이의 입력 스트림을 읽어들일 수 있다. 1234567891011121314import java.io.InputStream;import java.io.InputStreamReader;import java.io.BufferedReader;public class Ex_Stream &#123; public static void main(String[] args) throws Exception &#123; InputStream in = System.in; InputStreamReader reader = new InputStreamReader(in); BufferedReader br = new BufferedReader(reader); String a = br.readline(); System.out.println(a); &#125;&#125; BufferedReader 객체는 생성할 때, InputStreamReader 객체를 매개변수로 한다.이후 BufferedReader 객체의 readLine() 멤버 메소드를 이용하여 사용자가 엔터키를 누를 때까지 입력한 문자열을 읽을 수 있게 된다. 각 클래스에서 읽어들이는 데이터 타입은 다음과 같다. InputStream : byte InputStreamReader : character BufferedReader : String 3.4 Scanner java.util.Scanner 클래스를 이용하면 콘솔입력을 보다 쉽게 처리할 수 있다. 12345678import java.util.Scanner;public class Ex_Scanner &#123; public static void main(String[] args)&#123; Scanner sc = new Scanner(System.in); System.out.println(sc.next()); &#125;&#125; Scanner 객체의 메소드는 다음과 같다. next : 단어 nextLine : 라인 nextInt : 정수 4. 콘솔 출력 System.out은 PrintStream 클래스의 객체이다. Reference “06-1 콘솔 입출력”, 점프 투 자바, 2019. 2. 27, https://wikidocs.net/226 “[JAVA] System 클래스(표준 입출력) : System.in, System.out, System.err”, 개발이 하고 싶어요, 2019. 2. 27, https://hyeonstorage.tistory.com/235","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[자료구조] Linked List (연결 자료구조)","slug":"ds4","date":"2019-02-21T13:15:45.000Z","updated":"2019-02-28T08:16:57.571Z","comments":true,"path":"2019/02/21/ds4/","link":"","permalink":"http://dudri63.github.io/2019/02/21/ds4/","excerpt":"","text":"1. 연결 자료구조 방식2. 노드3. 단순 연결 리스트3.1 노드 삽입 연산3.2 노드 삭제 연산4. 자유 공간 리스트5. 단순 연결 리스트 알고리즘5.1 삽입 알고리즘5.2 삭제 알고리즘5.3 노드 탐색 알고리즘6. 코드 1. 연결 자료구조 방식 순차 선형 리스트 는 논리적인 순서와 물리적인 순서가 같다.그리하여 원소의 위치를 찾아 접근하기 쉽다는 장점이 있다.그러나, 삽입 연산이나 삭제 연산 후에 연속적인 물리 주소를 유지하기 위해 원소들을 이동시키는 추가적인 작업 및 시간이 요구된다.또한, 배열을 이용하여 구현하기 때문에 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대고 갖게 된다. 순차 자료구조 방식의 시간, 저장 공간 문제를 개선한 자료 표현 방식이 연결 자료구조(Linked Data Structure) 방식이다.연결 자료구조 방식에서는 순차 자료구조 방식처럼 원소의 논리적인 순서와 물리적인 순서 일치를 반드시 할 필요 없다.왜냐하면 각 원소에 저장되어 있는 다음 원소의 주소에 대한 참조에 의해 연결되는 방식이기 때문이다.또한, 순차 자료구조는 고정크기 메모리 공간을 사용하는 것에 반해, 연결 자료구조에서는 크기 변경이 유연하고, 메모리를 더 효율적으로 사용할 수 있다. 연결 리스트 는 리스트를 연결 자료구조 방식으로 표현한 구조로서, 연결하는 방식에 따라 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트 이중 원형 연결 리스트 등으로 나눌 수 있다. 2. 노드 연결 자료구조 방식에서 원소는 연결될 다음 원소에 대한 주소를 저장해야 한다.따라서, &lt;원소, 주소&gt;의 단위로 저장해야 한다.이러한 단위구조를 노드(node) 라고 한다.노드는 원소의 값을 저장하는 데이터 필드, 다른 노드의 주소를 저장하는 링크 필드로 구성된다.노드에 대한 논리적인 구조는 기본적으로 다음과 같다. 리스트 week=(월, 화, 수, 목, 금, 토, 일)을 순차 선형 리스트로 표현한 경우와 노드를 이용하여 연결 리스트로 표현한 경우를 비교하면 다음과 같다. 리스트 week의 순차 선형 리스트 표현 (논리 구조, 물리 구조) 리스트 week의 연결 리스트 표현 (논리 구조, 물리 구조) 연결 구조는 링크 필드에 대한 저장 공간이 추가로 필요하다.그러나, 물리적 순서를 맞추기 위한 오버헤드가 없기 때문에 연결 구조를 더 많이 사용한다. 리스트 이름 week은 연결 리스트의 시작 위치를 가리키는 메모리 참조 변수이다.연결 리스트의 마지막 노드는 다음에 연결할 노드가 없으므로 링크 필드에 null을 저장한다.각 노드의 필드에 저장한 값은 참조 변수의 점 연산자를 사용하여 접근한다. 3. 단순 연결 리스트 ‘단순 연결 리스트(Singly Linked List)’ 는 노드가 하나의 필드에 의해서 다음 노드와 연결되는 구조를 가진 연결 리스트다. 3.1 노드 삽입 연산 위 그림과 같은 단순 연결 리스트 week2=(월,금,일)에서 원소 ‘월’, ‘금’ 사이에 새 원소 ‘수’를 삽입하려면 다음과 같은 단계를 수행한다. (1) 공백 노드를 준비한다. 포인터 변수 new가 해당 노드의 주소를 저장한다. (2) 새 노드의 데이터 필드에 “수”를 저장 (3) 새 노드가 들어갈 위치 바로 앞 노드의 링크 필드 값을 new의 링크 필드에 저장한다. (4) new가 가리키는 새 노드의 주소를 바로 앞 노드의 링크 필드에 저장한다. 3.2 노드 삭제 연산 다음은 week2=(월,수,금,일)에서 원소 “수”를 삭제하는 과정이다. (1) 삭제할 원소의 앞 노드를 찾는다. (2) 삭제할 원소 “수”의 링크 필드 값을 앞 노드의 링크 필드에 저장한 뒤, 해당 노드를 삭제한다. 4. 자유 공간 리스트 연결 리스트에서 삽입 연산을 하려면 먼저 메모리에서 공백 노드를 가져와야 한다.삭제 연산의 경우는 사용하지 않는 노드에 대해서 메모리 공간을 해제해야 한다. 사용하지 않는 메모리 공간이 미리 노드의 구조로 나뉘어져 연결 리스트로 만들어여 있다면, 위 작업이 훨씬 효율적으로 진행될 수 있다.왜냐하면, 삽입 연산의 경우, 미리 만들어진 노드의 일부를 연결 리스트로 연결해 버리고,삭제 연산의 경우, 미리 만들어진 노드로 삭제할 노드를 반환하면 되기 때문이다.이러한 방식으로 메모리 관리를 효율적으로 할 수 있는데, 이렇게 메모리를 사용하기 전에 미리 노드로 나누워서 연결해 놓은 리스트를 자유 공간 리스트(Free Space List) 라고 한다. 메모리 상에 아직 사용하지 않는 자유 공간 리스트 Free가 있다고 가정하면, 그 논리적 구조는 다음과 같다. 자유 공간 리스트를 사용하기 위해서는 자유 공간 리스트로부터 새로운 공백 노드를 할당받고, 그 메모리 주소에 대한 참조값을 반환하는 getNode() 함수가 필요하다.다음은 getNode() 함수의 알고리즘이다. 1234567getNode() if (Free = null) then // 참조 변수 Free는 자유 공간 리스트의 시작을 가리킴 underflow(); // Free가 null인 경우(자유 노드가 없는 경우), 노드 할당 연산 불가능 new &lt;- Free; // 참조변수 new에 Free가 가리키는 노드(자유 리스트의 첫 노드)의 주소 저장 Free &lt;- Free.link; // 참조변수 Free가 자유 리스트의 두번째 노드를 가리키게 한다. return new;end getNode() 다음은 returnNode(old) 함수의 알고리즘이다.returnNode(old) 함수는 사용이 끝난 노드를 자유 공간 리스트에 반환하는 함수이다. 1234returnNode(old) old.link &lt;- Free; // 참조 변수 old가 가리키는 삭제할 노드의 링크에 Free가 가리키는 노드의 주소값을 저장한다. Free &lt;- old; // 참조 변수 Free에 old가 가리키는 노드의 주소를 저장한다.end returnNode(old)l 5. 단순 연결 리스트 알고리즘 5.1 삽입 알고리즘 첫 번째 노드르 삽입 123456insertFirstNode(L, x) new &lt;- getNode(); new.data &lt;- x; new.link &lt;- L; // 참조 변수 L은 기존 리스트의 첫 노드를 가리킨다. L &lt;- new; // 참조 변수 L은 새로운 노드를 가리키게 된다.end insertFirstNode() 중간 노드로 삽입 1234567891011insertMiddleNode(L, pre, x) new &lt;- getNode(); new.data &lt;- x; if (L=null) then &#123; // 기존 리스트 L이 공백 리스트인 경우 L &lt;- new; // new가 가리키는 주소를 L도 가리키게 함 new.link &lt;- null; // 삽입되는 새 노드의 link 필드에 null을 저장 &#125; else &#123; new.link &lt;- pre.link; // 앞 노드의 link 필드 값을 새로운 노드의 link값에 저장 (pre 노드가 가리키는 곳을 새로운 노드도 가리키도록 함) pre.link &lt;- new; // 앞 노드의 link 필드 값을 새로운 노드의 주소로 바꿈 (pre 노드가 새로운 노드를 가리키도록 함) &#125; 마지막 노드로 삽입 12345678910111213insertLastNode(L, x) new &lt;- getNode(); new.data &lt;- x; new.link &lt;- null; if (L = null) then &#123; L &lt;- new; return; // 기존 리스트 L이 공백 노드인 경우, 참조 변수 L이 새 노드를 가리키게 함 &#125; temp &lt;- L; // 참조 변수 temp가 첫 번째 노드를 가리키게 함 while (temp.link ≠ null) do // temp가 가리키는 노드의 링크 필드가 null이 될 때까지 (마지막 노드를 가리킬 때까지) temp가 가리키는 노드를 변경 temp &lt;- temp.link; temp.link &lt;- new; // temp가 가리키는 노드의 링크 필드에 new에 저장된 주소값을 저장end insertLastNode() 5.2 삭제 알고리즘 다음은 삭제 알고리즘 deleteNode(L, pre) 이다.단 pre는 삭제할 노드의 이전 노드, old는 삭제할 노드를 가리키는 참조변수이다. 123456789deleteNode(L, pre) if (L = null) then error; else &#123; old &lt;- pre.link; // pre가 가리키는 노드(삭제할 노드의 바로 앞 노드)의 링크 필드에 있는 주소값을 old에 저장한다. -&gt; 변수 old가 삭제할 노드를 가리키도록 한다. if (old = null) then return; // pre가 가리키는 노드가 마지막 노드라면, pre.link는 null이다. pre.link &lt;- old.link; // old가 가리키는 노드의 링크 필드 값을 pre가 가리키는 노드의 링크 필드에 저장한다. &#125; return Node(old);end deleteNode() 5.3 노드 탐색 알고리즘 연결 리스트에서 원소 값이 x인 노드를 탐색하려면, 리스트의 노드들을 처음부터 하나씩 순회, 각 노드의 데이터 필드값과 x를 비교해야 한다.다음은 노드 탐색 알고리즘이다. 12345678searchNode(L, x) temp &lt;- L; // L이 가리키는 노드(첫 번째 노드)를 temp도 가리키도록 한다. while (temp ≠ null) do &#123; if (temp.data = x) then return temp; // temp가 가리키는 노드의 데이터 필드 값이 x라면, temp의 주소값을 반환한다. temp &lt;- temp.link; // temp가 다음 노드를 가리키도록 한다. &#125; return temp;end searchNode() 6. 코드 ListNode https://github.com/dudri63/dataStructure/blob/master/ListNode.java LinkedList https://github.com/dudri63/dataStructure/blob/master/LinkedList.java Ex_LinkedList https://github.com/dudri63/dataStructure/blob/master/Ex_linkedList.java 실행 예시 Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[AWS] EC2 리눅스 인스턴스","slug":"aws3","date":"2019-02-21T10:57:31.000Z","updated":"2019-02-21T12:39:26.783Z","comments":true,"path":"2019/02/21/aws3/","link":"","permalink":"http://dudri63.github.io/2019/02/21/aws3/","excerpt":"","text":"1. 인스턴스 접속2. 리눅스 서버에 웹서버 사 1. 인스턴스 접속 원격 제어란 기본적으로 어떤 컴퓨터에서 다른 컴퓨터에 인터넷으로 접속하여, 마치 자신의 컴퓨터인 것처럼 제어하는 것이다. 원격 제어를 위해서는 SSH client가 필요하다. 이 때, PuTTY를 다운로드 받거나 터미널을 이용한다.이 후, 터미널에서 다음과 같은 명령어를 입력한다. $ chmod 400 password file name.pem 위 명령어를 입력할 경우, 파일의 소유자만이 그 파일을 읽을 수 있고, 소유자가 아닌 사람은 그 파일의 존재 조차 모르게 된다.(PC의 현재 계정이 아닌 다른 계정은 접근이 불가능하다.)이 후, 해당 터미널 상에서 해당 디렉토리에 $ ls -al 명령어를 입력하면, 비밀번호 파일의 접근 권한이 바뀐 것을 확인할 수 있다. 이 후, 다음과 같은 명령어를 입력한다. $ ssh -i &quot;password file name.pem&quot; ID@인스턴스 ip 혹은 도메인 SSH를 실행한 뒤, 비밀번호를 제출, ID의 인스터의 ip로 접속하는 것이다.ID는 선택한 AMI에 따라서 다르며, ubuntu를 선택하였을 경우, 기본적으로 ‘ubuntu’이다.또한, -i 옵션을 적용함으로써 비밀번호를 제출한다. 이 후, 인스턴스에 해당 계정 ID로 원격 접속한 것을 확인할 수 있다.원격 접속을 끊고, 개인 PC로 돌아오고 싶을때는, $ exit 명령어를 입력한다. 2. 리눅스 서버에 웹서버 사용 접소한 인스턴스에서 다음과 같은 명령어를 입력하여 Apache 를 설치한다. $ sudo apt-get install apache2 Apache : 아파치 소프트웨어 재단에서 관리하는 HTTP 웹 서버. 리눅스, 윈도우 등 기종에서 운용할 수 있다. 현재 세계에서 가장 인기있는 웹 서버 중 하나이다. 현재 거의 모든 리눅스 배포판이 이 아파치를 지원한다. LAMP : Linux 운영체제, Apache 웹 서버, MySQL 데이터베이스, PHP를 이용하여 웹 서버를 운영하는 방식 Apache를 설치하고 인스턴스의 IP 혹은 도메인 주소로 접속하면 다음과 같은 웹 페이지가 나타난다. 즉, 설치한 웹 서버를 통하여 웹 페이지에 접속할 수 있게 된 것이다. /var/www/html(절대 경로)에 들어가면, index.html 파일이 존재한다.이 파일을 지우면, 위 도메인에 접속했을 때, 나오는 화면(위 이미지)이 더 이상 나타나지 않는다. 아파치를 이용하여 웹 서버에 접속하기 위해서는 보안그룹에서 HTTP 80번 포트를 허용하여야 하는 것을 유의한다. Reference “아파치 HTTP 서버”, 위키백과, 2019. 2. 21, https://ko.wikipedia.org/wiki/%EC%95%84%ED%8C%8C%EC%B9%98_HTTP_%EC%84%9C%EB%B2%84 “EC2 소개”, 생활코딩, 2019. 2. 20, https://opentutorials.org/course/2717/11277","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"AWS","slug":"etc/AWS","permalink":"http://dudri63.github.io/categories/etc/AWS/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://dudri63.github.io/tags/AWS/"}]},{"title":"[Java] 생성자","slug":"java9","date":"2019-02-19T19:38:27.000Z","updated":"2019-02-19T20:14:33.384Z","comments":true,"path":"2019/02/20/java9/","link":"","permalink":"http://dudri63.github.io/2019/02/20/java9/","excerpt":"","text":"1. 생성자2. default 생성자3. 생성자 오버로딩 1. 생성자 생성자는 객체가 생성될 때 호출된다.객체가 생성될 때란 new라는 키워드를 이용할 때이다. 다음은 생성자가 없는 경우의 예시이다. 123456789101112class Dog &#123; String name; public void setName(String name)&#123; this.name = name; &#125;&#125;public class Ex_dog &#123; public static void main (String args [])&#123; Dog dog1 = new Dog(); System.out.println(dog1.name); &#125;&#125; 위 경우, dog1 객체 변수에 아무런 값도 설장하지 않았기 때문에 null이 출력된다.이는 생성자가 없기 때문이다.만약 생성자가 있다면, name이라는 객체 변수에 값을 무조건 설정해야만 객체가 생성될 수 있도록 강제할 수 있다. 다음은 생성자가 있는 경우의 예시이다. 123456789101112131415class Dog &#123; String name; public Dog(String name)&#123; this.setName(name); &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;public class Ex_dog &#123; public static void main (String args [])&#123; Dog dog1 = new Dog(&quot;Thunder&quot;); System.out.println(dog1.name); &#125;&#125; 위 경우는 생성자가 있기 때문에 객체를 생성할 때 new 키워드 뒤에 나오는 괄호 안에 반드시 name 인자를 넣어야 한다.그렇지 않을 경우, 만약, 괄호 안에 아무것도 적지 않는다면, 객체 생성 방법이 생성자의 규칙과 맞지 않기 때문에 오류가 발생한다.생성자가 선언된 경우 생성자의 규칙대로만 객체를 생성할 수 있다. 생성자 작성 규칙은 다음과 같다. 클래스명과 메소드명이 동일하다. 리턴타입을 정의하지 않는다. 생성자를 사용했을 때의 얻게되는 이득은 setName과 같은 필수적인 메소드를 객체 생성시에 우선적으로 제어할 수 있다는 점이다. 2. default 생성자 default 생성자란 생성자의 입력 항목이 없고 내부에 아무 내용이 없는 생성자이다.만약 클래스에 생성자가 하나도 없다면 컴파일러는 자동으로 디폴트 생성자를 추가한다.하지만 사용자가 작성한 생성자가 하나라도 구현되어 있다면 컴파일러는 디폴트 생성자를 추가하지 않는다.즉, 디폴트 생성자는 사용자가 직접 정의할 수 있고, 직접 정의하지 않아도 생성자가 하나도 없다면 컴파일러가 자동으로 추가한다. 3. 생성자 오버로딩 하나의 클래스에 여러개의 입력항목이 다른 생성자를 만들 수 있다.만약 생성자가 여러개라면, 객체를 여러가지 방법으로 생성이 가능하다. 다음은 생성자 오버로딩을 적용한 예시이다.12345678910111213141516171819202122232425class Dog &#123; String name; public Dog(String name)&#123; this.setName(name); &#125; public Dog(int type)&#123; if (type==1)&#123; this.setName(&quot;Dark&quot;); &#125; else if(type==2)&#123; this.setName(&quot;White&quot;); &#125; &#125; public void setName(String name)&#123; this.name = name; &#125;&#125;public class Ex_dog &#123; public static void main (String args [])&#123; Dog dog1 = new Dog(&quot;Thunder&quot;); Dog dog2 = new Dog(1); System.out.println(dog1.name); System.out.println(dog2.name); &#125;&#125; Reference “05-5 생성자”, 점프 투 자바, 2019. 2. 20, https://wikidocs.net/281","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[자료구조] Array List, Polynomial (순차 자료구조)","slug":"ds3","date":"2019-02-18T15:36:01.000Z","updated":"2019-03-04T06:27:22.152Z","comments":true,"path":"2019/02/19/ds3/","link":"","permalink":"http://dudri63.github.io/2019/02/19/ds3/","excerpt":"","text":"1. 선형 리스트1.1 선형 리스트, 원소 삽입1.2 선형 리스트, 원소 삭제2. 선형 리스트2.1 1차원 배열의 순차 표현2.2 2차원 배열의 순차 표현2.3 3차원 배열의 순차 표현3. 다항식의 순차 자료구조 표현3.1 ADT Polynomial3.2 addPoly 알고리즘3.3 addPoly 알고리즘 구현 1. 선형 리스트 데이터를 구조화시키는 기본 표현 방식은 다음과 같다. 순차 자료구조 : 논리적인 순서와 물리적인 순서가 같음 연결 자료구조 : 주소를 이용해 접근, 원소의 논리적인 순서와 물리적인 순서가 같을 필요가 없음단, 주소를 저장할 공간이 추가적으로 필요, 데이터와 주소를 ‘노드’ 단위로 저장 본 포스팅에서는 선형 리스트를 순차 자료구조 방식으로 구현하는 것을 다룰 것이다. 리스트 : List, 데이터를 나열하는 것 데이터를 구조화시키는 가장 기본적인 방법 선형 리스트 : Linear List, 나열한 원소들 간에 순서를 가지고 있는 리스트 = 순서 리스트, Ordered List 리스트에서 각 원소들이 번호를 단 꼴이다.선형 리스트의 예 리스트를 표현하는 일반적인 방법은 다음과 같다. 리스트이름 = (원소, 원소2, … , 원소 n)괄호 안에 나열한 원소들을 하나의 리스트로 그룹화, 리스트 이름을 정한다.선형 리스트의 경우, 나열한 순서대로 원소들의 순서가 결정된다.원소가 하나도 없는 리스트는 공백 리스트(empty list)라고 하고, 괄호 내에 원소가 없다.선형 리스트는 원소들 간의 논리적인 순서와 메모리에 저장하는 물리적인 순서가 같은 구조로 되어 있다.이러한 구조를 순차 자료구조 라고 한다.순차 자료구조에서 원소의 순서대로 데이터가 메모리에 연속 저장된다.1.1 선형 리스트, 원소 삽입선형 리스트에 새로운 원소를 삽입하려먼 먼저 삽입할 자리를 만든 후에 그 자리에 원소를 삽입해야 한다.원소를 삽입할 자리를 만들기 위해서는 삽입할 위치 이후에 있는 원소들을 모두 한자리씩 뒤로 밀어내야 한다. 위 경우, 새로운 원소를 2번 자리에 삽입하기 위해 원소들을 4회 이동하였다.(n+1)개의 원소로 이루어진 선형 리스트에 k번 자리에 새로운 원소를 삽입하려면,(n+1-k)개의 원소를 모두 한자리씩 이동시켜야 한다.따라서 빈 자리를 만들기 위한 이동횟수는 (n-k+1) 이다. 1.2 선형 리스트, 원소 삭제 선형 리스트에서 원소를 삭제하면 원소가 있던 자리는 빈자리가 된다.선형 리스트는 논리 순서와 같은 순서대로 메모리들이 연속하여 저장되어야 하는 자료구조이기 때문에 중간에 빈자리가 있어서는 안된다.따라서 삭제된 원소 이후에 있는 원소들을 모두 한자리씩 앞으로 옮겨 빈자리를 채워야 한다. (n+1)개의 원소로 이루어진 선형 리스트에 k번 자리에 있던 원소를 삭제하면,(n+1-(k+1))개의 원소를 모두 한자리씩 이동시켜야 한다.따라서 빈 자리를 채우기 위한 이동횟수는 (n-k) 이다. 2. 선형 리스트 구현 선형 리스트를 순차 구조로 표현하기 위해 배열 을 사용한다.배열은 &lt;인덱스, 원소&gt;의 쌍으로 구성되어 메모리에 연속적으로 할당된다.배열은 이같은 특징을 지니고 있기 때문에, 배열을 그대로 사용하여 선형 리스트를 구현할 수 있다. 2.1 1차원 배열의 순차 표현 1차원 배열 : 인덱스를 하나만 사용하는 배열 아래 코드는 분기별 상품 판매량을 출력하는 코드이다.123456789101112package io.github.dudri63.dataStructure;public class LinearList1 &#123; public static void main(String args[]) &#123; int sale[] = new int[] &#123;100, 120, 130, 110&#125;; for(int i=0; i&lt;4; i++) &#123; System.out.println(&quot;sale [&quot; + (i+1) + &quot;] = &quot; + sale[i]); &#125; &#125;&#125; 2.2 2차원 배열의 순차 표현 분기별 판매량 뿐만 아니라, 연도별 판매량을 나타내고 싶을때는 인덱스가 2개 필요하다.아래는 그것을 2차원 형태인 표로 도식화한 것이다. 이러한 경우 2차원 배열을 사용한다.2차원 배열은 위 표와 같은 형태로 행,열을 구분하여 논리적으로 묘사할 수 있다.그러나 실제로 메모리에 저장될 때에는 1차원의 순서로 저장이 될 것이다.2차원 논리적 순서과 1차원 물리적 순서로 변환되는 방법은 다음과 같다. 행 우선 순서(Row Major Order) 열 우선 순서(Column Major Order)행 우선 순서 방법은 행을 기준으로 1행의 첫번째 열부터 마지막 열까지, 2행의 첫번째 열부터 마지막 열까지, 순서대로 저장하여 마지막 행의 첫번째 열부터 마지막 열까지 저장하는 방법이다.예를 들어, sale[0][0], sale[0][1], sale[0][2], sale[1][0], sale[1][1], sale[1][2]순서대로 저장한다.열 우선 순서 방법은 열을 기준으로 1열의 첫번째 행부터 마지막 행까지, 2열의 첫번째 행부터 마지막 행까지, 순서대로 저장하여 마지막 열의 첫번째 행부터 마지막 행까지 저장하는 방법이다.예를 들어, sale[0][0], sale[1][0], sale[0][1], sale[1][1], sale[0][2], sale[1][2]순서대로 저장한다.논리 순서를 물리 순서로 변환하는 방법은 프로그래밍 언어의 컴파일러에 의해서 결정된다.다음은 2년 동안의 분기별 선형 리스트를 2차원 배열로 구현한 코드이다.12345678910111213141516171819package io.github.dudri63.dataStructure;public class LinearList2 &#123; public static void main(String args[]) &#123; int sale[][] = new int[2][4]; for(int i=0; i&lt;2; i++) &#123; for (int j=0; j&lt;4; j++) &#123; sale[i][j] = 100*i + 20*j; &#125; &#125; for(int i=0; i&lt;2; i++) &#123; for (int j=0; j&lt;4; j++) &#123; System.out.printf(&quot;sale[%d][%d] = %d %n&quot;, i+1, j+1, sale[i][j]); &#125; &#125; &#125;&#125; 2.3 3차원 배열의 순차 표현 2년 동안의 분기별 선형 리스트는 2차원 배열로 표현할 수 있었다.그렇다면, 각 팀별 2년 동안의 분기별 선형 리스트는 3차원 배열로 표현할 수 있다.왜냐하면 이러한 경우에는 인덱스가 3개가 필요하기 때문이다. 3차원 배열의 논리적 구조는 메모리상에는 2차원 배열과 마찬가지로 1차원 선형 구조 형태로 저장된다.3차원 논리 구조를 1차원 물리 구조로 변환하는 방법은 다음과 같다. 면 우선 순서 방법 열 우선 순서 방법 다음은 1팀, 2팀의 2년 동안의 분기별 선형 리스트를 3차원 배열로 구현한 코드이다. 1234567891011121314151617package io.github.dudri63.dataStructure;public class LinearList3 &#123; public static void main(String args[]) &#123; int sale[][][] = new int[][][] &#123;&#123;&#123;100,200,150,180&#125;,&#123;180,190,200,210&#125;&#125;, &#123;&#123;150,180,170,200&#125;,&#123;220,210,150,180&#125;&#125;&#125;; for(int i=0;i&lt;2;i++) &#123; System.out.printf(&quot;%d팀 %n&quot;, i+1); for(int j=0;j&lt;2;j++) &#123; for(int k=0;k&lt;4;k++) &#123; System.out.printf(&quot;sale[%d][%d] = %d %n&quot;, j+1,k+1,sale[i][j][k]); &#125; System.out.printf(&quot;----------------------------%n&quot;); &#125; &#125; &#125;&#125; 순차 자료구조는 원소들의 순서를 따로 표시할 필요없다는 장점이 있다.또한 인덱스를 사용하여 특정 원소를 쉽게 접근할 수 있다.그러나 원소를 삽입하거나 삭제할 경우, 물리적으로 원소들을 밀어내거나 당겨야 하기 때문에 추가적인 오버헤드가 발생한다.삽입, 삭제가 많이 필요한 문제에서 순차 자료구조를 사용하는 것은 비효율적이다. 3. 다항식의 순차 자료구조 표현 순차 자료구조를 사용하여 다항식 표현 및 연산을 수행 가능하다. 3.1 ADT polynomial 다음은 다항식 연산에 필요한 연산을 추상자료형(ADT)으로 정의한 것이다. 1234567891011121314151617ADT polynomial데이터 : &lt;ei,ai&gt;의 집합으로 표현된 다항식 p(x), 단, ei, ai는 각각 지수, 계수연산 : p, p1, p2 ∈ Polynomial; a ∈ Coefficient; e ∈ Exponent; // p,p1,p2는 다항식, a는 계수, e는 지수 zeroP() ::= return polynomial P(x) = 0; // 다항식을 0으로 만드는 연산 isZeroP() ::= if (p) then false else return true; // 다항식 p가 0인지를 검사하는 연산 coef(p,e) ::= if (&lt;e,a&gt; ∈ p) then return a; else return 0; // 다항식 p에서 지수가 e인 항의 계수 a를 구하는 연산 maxExp(p) ::= return max(p.Exponent); // 다항식 p에서 최대 지수를 구하는 연산 addTerm(p,a,e) ::= if (e ∈ p.Exponent) then return error else return p after // 다항식 p에서 지수가 e인 항이 없는 경우, 새로운 항 &lt;e,a&gt;를 추가하는 연산 delTerm(p,e) ::= if (e ∈ p.Exponent) then return p after removing the term &lt;e,a&gt; else return error; // 다항식 p에서 지수가 e인 항 &lt;e,a&gt;를 삭제하는 연산 multiTerm(p,a,e) ::= return (p * ax^e) // 다항식 p의 모든 항에 ax^e하을 곱하는 연산 addPoly(p1,p2) ::= return (p1 + p2); // 두 다항식 p1, p2의 합을 구하는 연산 multiPoly(p1,p2) ::= return (p1 * p2); // 두 다항식 p1과 p2의 곱을 구하는 연산End Polynomial 예를 들어, 위 추상 자료형의 정의에 따른다면, A(x) = 4x3 + 3x2 + 2는 p1 = ((3,4), (2,3), (0,2))와 같이 각 항의 지수와 계수를 한 쌍으로 하는 3개의 항을 선형 리스트 p1의 원소로 정의할 수 있다.차수가 n인 다항식은 (n+1)개의 원소를 가지는 배열을 사용하여 순차 자료구조로 표현할 수 있다.이때 배열의 인덱스 i는 지수가 (n-i)인 항을 가리키고, 해당 항의 계수를 인덱스 i에 대한 배열 요소에 저장한다. n차 다항식 P(x)의 순차 자료구조 표현 다음은 3차 다항식을 순차 자료구조로 표현한 것에 대한 예시이다. 3차 다항식의 순차 자료구조 표현 다항식의 각 항이 계수를 정해진 인덱스의 배열요소에 저장하여 사용하는 방법은 지수를 따로 저장하지 않기 때문에 표현하기가 쉽고 간단하다. 그러나 항의 계수가 ‘0’인 항이 많을 경우 메모리의 낭비가 심해지게 된다.예를 들어 다항식 B(x) = 3x1000 + x + 4의 경우가 그러한 경우이다.이러한 다항식을 ‘희소 다항식’이라고 하는데, 이러한 경우에는 차수에 따라 배열을 생성하기보다는 항의 개수에 따라 배열 크기를 결정하는 것이 메모리 사용면에서 효율적이다.단, 이러한 방법을 차용하기 위해서는 지수를 표현할 수 있도록 인덱스를 하나 더 추가하여 &lt;지수,계수&gt; 쌍을 2차원 배열에 저장한다. 희소 다항식의 순차 자료구조 표현 2차원 배열에서 각 행의 0번 열에 지수, 1번 열에 계수를 저장한다. 3.2 addPoly 알고리즘 추상자료형으로 정의한 다항식 연산 중 두 다항식의 덧셈 연산인 addPloy(p1,p2)에 대한 알고리즘을 정의한 바는 다음과 같다. 12345678910111213141516171819202122addPloy(A, B) // 주어진 두 다항식 A, B를 더하여 결과 다항식 C를 반환하는 알고리즘C &lt;- zeroP(); // 임의의 다항식 C를 0으로 만듬while (not isZeroP(A) and not isZeroP(B)) do &#123; // 다항식 A, B가 0이 아니면, case &#123; maxExp(A) &lt; maxExp(B) : // 다항식 B의 차수가 다항식 A의 차수보다 큰 경우 C &lt;- addTerm(C, coef(B, maxExp(B)), maxExp(B)); // 다항식 C에 다항식 B의 최고차항을 새로운 항으로서 추가 B &lt;- delTerm(B, maxExp(B)); // 다항식 B의 최고차항을 제거 maxExp(A) = MaxExp(B) : // 다항식 B의 차수와 다항식 A의 차수가 같은 경우 sum &lt;- coef(A, maxExp(A)) + coef(B, maxExp(B)); // 다항식 A, B의 최고차항의 계수를 더한 뒤, 변수 sum에 저장 if (sum ≠ 0) then, C &lt;- addTerm(C, sum, maxExp(A)); // sum이 0이 아니라면, 다항식 C에 다항식 A의 최대 지수를 지수로, sum을 계수로 하는 새로운 항을 추가 A &lt;- delTerm(A, maxExp(A)); // 다항식 A의 최고차항을 삭제 B &lt;- delTerm(B, maxExp(B)); // 다항식 B의 최고차항을 삭제 maxExp(A) &gt; maxExp(B) : // 다항식 A의 차수가 다항식 B의 차수보다 큰 경우 C &lt;- addTerm(C, coef(A, maxExp(A)), maxExp(A)); // 다항식 C에 다항식 A의 최고차항을 새로운 항으로서 추가 A &lt;- delTerm(A, maxExp(A)); // 다항식 A의 최고차항을 삭제 &#125; &#125; if (not isZeroP(A)) then A의 나머지 항들을 C에 복사 // A에 항이 남이 있으면 else if (not isZero(B)) then B의 나머지 항들을 C에 복사 // B에 항이 남아 있으면 return C;End addPoly()&#125; 3.3 addPoly 알고리즘 구현 addPoly 알고리즘을 자바 프로그램으로 구현한 결과는 다음과 같다.1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class Polynomial &#123; private int degree; private float coef[] = new float[20]; Polynomial (int degree, float coef[]) &#123; this.degree = degree; this.coef = coef; &#125; Polynomial (int degree) &#123; this.degree = degree; for(int i=0; i&lt;=degree; i++) &#123; this.coef[i] =0; &#125; &#125; public int getDegree() &#123; return this.degree; &#125; public float getCoef(int i) &#123; return this.coef[i]; &#125; public void setCoef(int i, float coef) &#123; this.coef[i] = coef; &#125; public void printPoly() &#123; int temp = this.degree; for(int i=0; i&lt;=this.degree; i++) &#123; System.out.printf(&quot;%3.0fx^%d &quot;, this.coef[i], temp--); &#125; &#125;&#125;public class OperatePoly &#123; private int degree_A=0, degree_B=0, degree_C=0, index_A=0, index_B=0, index_C=0; private int expo_A, expo_B; public Polynomial addPoly(Polynomial A, Polynomial B) &#123; degree_A = A.getDegree(); degree_B = B.getDegree(); expo_A = degree_A; expo_B = degree_B; if(degree_A &gt;= degree_B) degree_C = degree_A; else degree_C = degree_B; Polynomial C = new Polynomial(degree_C); while (index_A &lt;= degree_A &amp;&amp; index_B &lt;= degree_B) &#123; if(expo_A &lt; expo_B) &#123; C.setCoef(index_C++, B.getCoef(index_B++)); expo_B--; &#125; else if(expo_A == expo_B) &#123; C.setCoef(index_C++, A.getCoef(index_A++)+B.getCoef(index_B++)); expo_A--; expo_B--; &#125; else &#123; C.setCoef(index_C++, A.getCoef(index_A++)); expo_A--; &#125; &#125; return C; &#125;&#125;public class Ex_addPoly &#123; public static void main(String args[]) &#123; float a[] = new float[] &#123;1,2,3,4&#125;; float b[] = new float[] &#123;1,2,3,4,5&#125;; Polynomial A = new Polynomial(3, a); Polynomial B = new Polynomial(4, b); OperatePoly optPoly1 = new OperatePoly(); Polynomial C = optPoly1.addPoly(A,B); System.out.printf(&quot;A(x)=&quot;); A.printPoly(); System.out.println(); System.out.printf(&quot;B(x)=&quot;); B.printPoly(); System.out.println(); System.out.printf(&quot;C(x)=&quot;); C.printPoly(); &#125;&#125; Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[AWS] 가용 영역, EC2란, EC2 서비스 시작 순서","slug":"aws2","date":"2019-02-18T14:02:06.000Z","updated":"2019-02-21T10:55:31.647Z","comments":true,"path":"2019/02/18/aws2/","link":"","permalink":"http://dudri63.github.io/2019/02/18/aws2/","excerpt":"","text":"1. 가용 영역2. EC23. EC2 서비스 시작 순서 1. 가용 영역 AWS의 데이터 센터는 가용영역(Availability Zone, AZ) 내에 편성된다.각 가용 영역은 독리된 장애 영역으로 설계되며, 사용자는 시스템이 상주할 가용 영역을 선택해야 한다.여러 가용 영역에 걸쳐 시스템을 확장할 수도 있다. 가용 영역은 다시 리전(Region)으로 그룹화된다. 각 AWS 리전은 2개 이상의 가용 영역을 포함한다.특정 리전에 데이터를 저장할 경우 해당 리전 내에만 데이터가 복제되는 방식이다.사용자는 각 리전이 위치한 국가 및 지역을 선택해야 한다. 2. EC2 EC2 : 아마존 일래스틱 컴퓨트 클라우드(Amazon Elastic Compute Cloud, EC2) AWS의 핵심, 가장 많이 이용되는 가상 서버 서비스 독립적인 컴퓨터 한 대를 통째로 임대해주는 서비스 인스턴스 : ‘컴퓨터 한 대’라고 간주할 수 있다. 3. EC2 서비스 시작 서비스 지역을 설정 한 뒤, EC2 서비스를 선택 단계 1 : Amazon Machine Image(AMI) 선택ex. ubuntu를 선택함 AWS EC2에서는 여러 가지 AMI를 제공한다.AMI(Amazon Machine Image)는 간단하게 말해서 임대한 컴퓨터에 운영체제를 설치하는 것이다.이 때, 선택할 수 있는 운영체제들은 Amazon Linux, Ubuntu Server, Windows Server 등이 있다. 프리 티어(Free Tier)란 신규 가입 고객에게 가입한 날로부터 12개월 동안 무료로 제공하는 일부 서비스를 말한다.프리 티어만으로도 간단한 아키텍처를 구성할 수 있을 정도이다.EC2 프리티어 서비스의 경우, 가입 후 12개월 후에 종료된다.또한 12개월 이내의 경우라도, 허용된 이상을 사용하면 지불해야 할 요금이 발생한다. SQL server가 설치된 경우, 프리 티어 서비스를 제공하지 않는다.왜냐하면 Microsoft의 경우 고가의 정책을 유지하기 때문에 Microsoft의 제품이 포함되면 무료 제공이 쉽지 않다. 단계 2 : 인스턴스 유형 선택ex. cpu 1개짜리, 메모리 1GB를 선택 AMI 선택 이후, 단계2에서는 인스턴스 타입을 설정한다.다시 말하면, 임대한 컴퓨터의 사양을 선택하는 것이다.이 때, 프리티어 서비스인 경우, 표시되어 있어 유의하는 것이 좋다. vCPU column 제공하는 CPU의 갯수를 나타낸다. 이 때, v는 virtual(가상)의 줄임말이다.Memory column은 제공하는 용량(GB)을 나타낸다.Network Peformance column은 문자 그대로 퍼포먼스를 보여준다.유형 column에서는 해당 유형의 이름이 나오는데, 메모리가 우위에 있는 인스턴스는 m, cpu가 우위에 있는 인스턴스는 c가 붙어있는 등의 특징이 있다. 구현하고자 하는 어플리케이션이 무엇인지에 따라서 인스턴스 타입을 적절하게 결정하는 것이 좋다. 단계 3 : 인스턴스 세부 정보 구성ex. 인스턴스 개수를 1개로 함 AWS 프리 티어 인스턴스의 경우, 매달750시간 사용이 가능하다. 이는 한 대의 인스턴스를 끄지 않고, 매일 켜놓은 상태여도 1년간 무료라는 뜻이다.저장장치는 최대 30GB, 저장소의 데이터를 읽고 쓰는 것(I/O)을 200만 건 이하로 사용하면, 추가 과금이 발생하지 않는다.인터넷으로 데이터를 전송하는 것은 15GB까지 무료이다. 온 디맨드 인스턴스의 경우, 매달 (온 디맨드란, 켜고 끌 수 있는 컴퓨터)시간당 과금을 하는 방식이다.Linux AMI, t2.micro 인스턴스의 경우, 시간당 0.02$가 과금된다. 예약 인스턴스의 경우, 매달 (예약 인스턴스란, 미리 계약을 하고 컴퓨터를 임대한 형태)t2.nano 인스턴스의 경우, 1년 계약시, 시간당 0.01$가 과금된다. 단계 4 : 스토리지 추가ex. 8GB 저장소를 추가 스토리지 사이즈는 GByte 단위로 지정할 수 있다. 프리 티어의 경우, 30GB까지 무료로 제공된다.volume type은 SSD, magnetic 등을 선택할 수 있다. SSD가 훨씬 빠르다.또한, 저장장치는 임대하는 컴퓨터와는 별도로 분리되어 있다.따라서, 인스턴스가 terminate되면, 저장장치도 함께 폐기될 수 있도록 조치하는 것이 좋다. 단계 5 : 태그 추가ex. Name 키, 해당 키에 값을 ‘웹서버’로 하는 태그를 추가 어떤 인스턴스를 만들면, 어떤 역할을 수행하는지, 누가 관리하는지를 등의 정보를 기록하기 위해 태그를 사용한다. 단계 6 : 보안 그룹 구성ex. HTTP 유형으로 하는 새로운 규칙 추가 인스턴스 접근 권한을 지정한다. SSH : = Secure Shell, 네트워크 상의 다른 컴퓨터에 로그인하거나 원격 시스템에서 명령을 실행, 다른 시스템으로 파일을 복사할 수 있도록 해주는 응용 프로그램. 기본적으로 22번 포트를 사용한다. 유닉스 계열 인스턴스라면, SSH 방식을 이용하여 개인 컴퓨터로 원격 제어를 한다. HTTP : = HyperText Transfer Protocol, WWW 상에서 정보를 주고 받을 수 있는 프로토콜, 주로 HTML 문서를 주고받는데 쓰인다. 기본적으로 80번 포트를 사용한다. RDP : = Remote Desktop Protocol, 다른 컴퓨터에 그래픽 사용자 인터페이스를 제공하는 프로토코이다. 기본적으로 3389번 포트를 사용한다. 윈도우 계열 인스턴스라면, RDP 방시을 이용하여 개인 컴퓨터로 원격 제어를 한다. 윈도우는 리눅스 원격 제어 방식이 다름을 유의한다. Source column : 접근을 제한한다. Anywhere : 모든 SSH or HTTP 접근을 허용, my IP : 지정된 아이피만 지정, HTTP의 경우, My IP로 할 경우, 다른 사람들은 접속을 하지 못하게 되는 경우가 발생한다. 단계 7 : 인스턴스 시작 검토 인스턴스를 시작하기 전에 최종적으로 검토할 수 있는 페이지가 제공된다. 문제가 없을 시, 인스턴스에 네트워크를 통하여 접속할 때, 사용할 비밀번호를 지정하는 화면이 나타난다.서버 자원은 굉장히 중요하기 때문에 매우 복잡한 비밀번호를 사용하여야 한다.사람이 기억할 수 있는 수준이 아니라, 파일로 저장하는 형식의 비밀번호를 발급받는다.Key pair name은 비밀 번호의 이름을 지정하는 것이다. 단, 비밀번호가 파일로 저장되면, 저장되는 위치(ex. PC)는 탈취될 수 있는 가능성이 있다는 단점이 있다. 그러므로, 다운로드 받은 비밀번호 파일을 안전하게 보관해야 한다. 또한, 다운로드 받은 비밀번호 파일은 아마존에서 다시는 재발급해주지 않는다. 그러므로 소중하게 관리해야 한다. 새 키 페어를 선택, 키 페어 이름을 awspwd 입력하면, 비밀번호를 담고 있는 파일을 다운로드할 수 있다. 이 키를 이용하여 나중에 인스턴스에 접근할 수 있게 된다. 이 후, 생성된 인스턴스에 원격으로 접속하여 웹서버를 설치하여 웹서비스를 할 수도 있고, 하둡과 같은 빅데이터 시스템을 설치하여 거대한 데이터를 처리할 수도 있다. 삭제는 우클릭 후, 아래와 같이 선택한다. Reference “EC2 소개”, 생활코딩, 2019. 2. 20, https://opentutorials.org/course/2717/11274, https://opentutorials.org/course/2717/11275, https://opentutorials.org/course/2717/11276","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"AWS","slug":"etc/AWS","permalink":"http://dudri63.github.io/categories/etc/AWS/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://dudri63.github.io/tags/AWS/"}]},{"title":"[AWS] 아마존 웹서비스, 클라우드","slug":"web1","date":"2019-02-17T16:53:04.000Z","updated":"2019-02-18T14:00:24.115Z","comments":true,"path":"2019/02/18/web1/","link":"","permalink":"http://dudri63.github.io/2019/02/18/web1/","excerpt":"","text":"웹 호스팅 : 서버를 대신 구매, 서버 공간을 분할해서 사용자에게 나눠준다. 웹 호스팅 업체들이 대부분 설정과 구축 환경을 관리하기 때문에 사용자는 원하는 소프트웨어를 따로 설치할 수 없다. 서버 호스팅 : 서버 1대를 빌려주는 서비스 클라우드 컴퓨팅 : 중앙 서버가 모든 데이터 처리를 관장하는 방식, 정보처리를 자신의 컴퓨터가 아닌 인터넷으로 연결된 다른 컴퓨터로 처리하는 기술을 의미한다. 과거, 컴퓨터가 매우 비싸던 시절 중앙 컴퓨터에 데이터를 저장, 처리, 다른 단말기로는 입출력만 하는 방식이 클라우드 컴퓨팅의 시초이다. 저렴한 개인용 컴퓨터가 등장하면서 사라졌다가, 인터넷을 통해 처리해야 할 데이터의 양이 증가하면서 다시 활성화 인터넷상의 서버에서 데이터 저장, 처리, 네트워크, 콘텐츠 사용 등 IT 관련 서비스를 필요한만큼 빌려 쓰고 사용 요금을 지급하는 방식 장점 컴퓨터 시스템 유지,보수,관리 비용 절약, 서버 구매 및 설치 비용 절약 자료를 외부 서버에 저장, 자료 손실이 없음, 언제 어디서든 자료를 열람, 수정할 수 있음 단점 및 한계 서버가 해킹당할 경우 정보 유출, 서버 장애가 발생하면 자료 이용이 불가능 중앙 서버에 데이터 과부하로 인한 병목 현상 가능성 소형 서버를 활용하는 엣지 컴퓨팅 은 클라우드 컴퓨팅을 상호 보완하는 기술 아마존 웹 서비스 : 클라우드 서비스를 제공하는 회사 대량의 서버, 스토리지, 네트워크 장비를 구매, 인프라를 대여해준다. 사용자는 각 장비를 사용한 만큼만 비용을 지불 인프라로의 서비스(Infrastructure as a Service, Iaas) 사용자 수에 맞춰 서버를 자동으로 증설한다. Reference ‘아마존 웹서비스와 클라우드’, 생활코딩, 2019. 2. 18, https://opentutorials.org/course/2717/11268 ‘아마존웹서비스(AWS)’, 네이버 지식백과, 2019. 2. 18, https://terms.naver.com/entry.nhn?docId=3580218&amp;cid=59088&amp;categoryId=59096 ‘클라우드 컴퓨팅이란?’, 강원전자주식회사 블로그, 2019. 2. 18, https://blog.naver.com/moxashop/221363510906","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"AWS","slug":"etc/AWS","permalink":"http://dudri63.github.io/categories/etc/AWS/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://dudri63.github.io/tags/AWS/"}]},{"title":"[Java] JVM, JRE, JDK의 차이","slug":"java8","date":"2019-02-17T10:01:28.000Z","updated":"2019-02-17T10:07:03.019Z","comments":true,"path":"2019/02/17/java8/","link":"","permalink":"http://dudri63.github.io/2019/02/17/java8/","excerpt":"","text":"JVM, JRE, JDK의 차이는 아래 링크를 참조한다. Reference “JVM, JRE, JDK의 차이”, 점프 투 자바, 2019.2.17, https://wikidocs.net/257","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] 객체 지향 프로그래밍","slug":"java7","date":"2019-02-17T07:55:13.000Z","updated":"2019-02-17T09:51:27.155Z","comments":true,"path":"2019/02/17/java7/","link":"","permalink":"http://dudri63.github.io/2019/02/17/java7/","excerpt":"","text":"1. 객체 지향 프로그래밍2. 객체 지향 언어 : 자바2.1 자바의 캡슐화 구현2.2 자바의 상속 구현 1. 객체 지향 프로그래밍 객체 지향 프로그래밍 : 수행할 작업과 필요한 데이터들을 묶어서 독립적인 객체를 만들고, 이런 객체들을 인터페이스로 연결하여 전체 프로그램을 구성하는 방식 프로그램이 대형화되면서 발생하는 비용 증가, 생산성 저하의 문제를 해결하기 위한 방법 확장과 재사용이 편리하다. 객체 : 객체 지향 프로그래밍을 구성하는 단위 작업할 메소드와 데이터를 가지고 있는 독립적인 실체 정해진 인터페이스를 통해서만 외부여 연결된다. 특징 캡슐화 : encapsulation, 객체 내부의 메소드와 데이터를 외부에서 사용할 수 없도록 감싸는 것. 객체를 독립적인 실체로 만드는 것이다. 캡슐화된 객체는 지정한 인터페이스를 통해서만 외부와 연결된다.(데이터 은닉) 재사용성 : 캡슐화된 객체는 인터페이스만 맞춰주면 다른 프로그램에서도 사용할 수 있다. 상속 : inheritance, 새로 작성할 객체가 이미 작성해 놓은 객체와 유사한 특성을 갖고 있다면, 기존 객체를 물려받고 추가되는 부분의 코드만 작성하여 새로운 개체를 만들 수 있다. 다형성 : polymorphism, 같은 이름의 메소드가 상황에 따라 다른 연산을 수행한다. 여러 메소드를 같은 이름으로 정의하면 같은 이름으로 호출되어도 상황에 따라 메소드가 구분되서 수행한다. 2. 객체 지향 언어 : 자바 객체 지향의 개념을 프로그램으로 실현하기 위한 여러 가지 프로그래밍 언어가 존재한다. C++ : C 언어에 객체 지향 개념을 추가하여 확장한 언어 Java : 객제 지향 프로그래밍을 고려하여 개발된 언어 2.1 자바의 캡슐화 구현 클래스 : 자바 프로그램은 캡슐화된 클래스들을 조합하여 구성한다. class 키워드를 사용하여 각각의 클래스를 만든다. 객체를 생성하기 위한 기본 틀 자바의 클래스는 독립성을 가지기 때문에 정해진 인터페이스를 사용하지 않으면 외부에서 클래스의 내부를 보거나 수정할 수 없다. 접근 제어자 : 클래스 내부의 멤버들을 캡슐화하기 위함 public : 지정한 멤버는 외부에서도 접근이 가능, 클래스에 대한 인터페이스 역할 private : 같은 클래스의 멤버 메소드만 접근 가능, 클래스 안에서만 사용 가능, 데이터 은닉 protected : 외부에서 접근할 수 없음, 단, 상속받는 자식 클래스에서는 사용할 수 있음 접근 제어자가 없는 경우 1234567891011121314151617181920212223class AccessControl1&#123; int num1, num2, sum; double ave; AccessControl1 (int a, int b)&#123; this.num1 = a; this.num2 = b; &#125; int getSum() &#123; sum = num1 + num2; return sum; &#125; double getAve() &#123; ave = sum/2.0; return ave; &#125;&#125;class Ex_AccessControl1&#123; public static void main(String args[]) &#123; AccessControl1 test = new AccessControl1(10,20); System.out.println(&quot;sum = &quot; + test.getSum()); System.out.println(&quot;average = &quot; + test.getAve()); &#125;&#125; AccessControl1 클래스에는 private 접근 제어자가 없으므로 은닉된 멤버가 없다.Ex_AccessControl1 클래스의 main() 메소드가 AccessControl1 클래스의 모든 멤버들을 접근하여 사용할 수 있다.그리하여 위 결과에서 알 수 있듯이 모두 정상적으로 실행된다.그러나 AccessContorl1 클래스는 캡슐화디어 있지 않으므로 좋은 클래스라고 할 수는 없다. 접근 제어자가 있는 경우1234567891011121314151617181920212223class AccessControl2&#123; private int num1, num2, sum; private double ave; AccessControl2 (int a, int b)&#123; this.num1 = a; this.num2 = b; &#125; public int getSum() &#123; sum = num1 + num2; return sum; &#125; public double getAve() &#123; ave = sum/2.0; return ave; &#125;&#125;class Ex_AccessControl2&#123; public static void main(String args[]) &#123; AccessControl2 test = new AccessControl2(10,20); System.out.println(&quot;sum = &quot; + test.getSum()); System.out.println(&quot;average = &quot; + test.getAve()); &#125;&#125; AccessControl2 클래스의 num1, num2, sum, ave 멤버는 private 접근 제어자를 사용하여 외부에서 사용할 수 없도록 은닉하였다. getSum() 메소드, getAve1() 메소드는 public 접근 제어자를 사용, 은닉되어 있는 데이터를 사용할 수 있는 인터페이스롤 만들었다.따라서, Ex_AccessControl2 클래스의 main() 메소드가 AccessControl2 클래스의 num1, num2, sum, ave 멤버에 직접 접근할 수는 없지만, 인터페이스로 열어놓은 getSum(), getAve() 메소드를 통하여 접근할 수 있으므로 정상 작동한다. private 접근 제어자만 사용한 경우 1234567891011121314151617181920212223class AccessControl3&#123; private int num1, num2, sum; private double ave; AccessControl3 (int a, int b)&#123; this.num1 = a; this.num2 = b; &#125; private int getSum() &#123; sum = num1 + num2; return sum; &#125; private double getAve() &#123; ave = sum/2.0; return ave; &#125;&#125;class Ex_AccessControl2&#123; public static void main(String args[]) &#123; AccessControl3 test = new AccessControl3(10,20); System.out.println(&quot;sum = &quot; + test.getSum()); System.out.println(&quot;average = &quot; + test.getAve()); &#125;&#125; 2.2 자바의 상속 구현 부모 클래스1234567891011121314class StudentInfo&#123; protected String dept, stdNo, name; StudentInfo(String dept, String stdNo, String name)&#123; this.dept = dept; this.stdNo = stdNo; this.name = name; &#125; public void getStdInfo() &#123; System.out.println(&quot;&lt;학생 정보 출력&gt;&quot;); System.out.println(&quot;학과 : &quot; + dept); System.out.println(&quot;학번 : &quot; + stdNo); System.out.println(&quot;이름 : &quot; + name); &#125;&#125; 자식 클래스12345678910111213141516171819202122232425262728293031class StudentScore extends StudentInfo&#123; private int kor, eng, math, sum; private double ave; StudentScore(String dept, String stdNo, String name, int kor, int eng, int math)&#123; super(dept, stdNo, name); this.kor = kor; this.eng = eng; this.math = math; this.sum = 0; this.ave = 0.0; &#125; public int getSum() &#123; sum = kor + eng + math; return sum; &#125; public double getAve() &#123; ave = sum/3.0; return ave; &#125; public void getStdInfo() &#123; super.getStdInfo(); &#125; public void getStdScore() &#123; System.out.println(&quot;&lt;학생 점수 출력&gt;&quot;); System.out.println(&quot;국어 : &quot; + kor); System.out.println(&quot;영어 : &quot; + eng); System.out.println(&quot;수학 : &quot; + math); System.out.println(&quot;총점 : &quot; + getSum()); System.out.println(&quot;평균 : &quot; + getAve()); &#125;&#125; extends : 부모 클래스가 누구인지를 명시한다. super() : super는 부모 클래스를 의미하는 키워드이다. 자식 클래스의 생성자는 부모의 데이터 멤버까지 초기화하여야 한다. super()는 부모 클래스의 생성자를 호출한다. super.method() : 부모 클래스의 메소드를 호출한다. main 메소드가 포함된 클래스12345678class Ex_Student&#123; public static void main(String args[]) &#123; StudentScore a = new StudentScore(&quot;정보통신공학과&quot;, &quot;12122927&quot;, &quot;서영기&quot;, &quot;100&quot;, &quot;95&quot;, &quot;90&quot;); a.getStdInfo(); a.getStdScore(); &#125;&#125; Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] try문","slug":"java6","date":"2019-02-16T14:12:22.000Z","updated":"2019-02-16T14:24:16.475Z","comments":true,"path":"2019/02/16/java6/","link":"","permalink":"http://dudri63.github.io/2019/02/16/java6/","excerpt":"","text":"프로그램 실행 중에 발생하는 에러를 예외(exception) 라고 한다.예를 들어, 10을 0으로 나누라는 명령은 불가능한 연산이다.이런 경우 컴파일 과정에서 에러가 발생하지 않지만, 실행 과정에서 예외가 발생한다. 예외가 발생하는 경우에 대해 처리 방법이나 출력할 메세지를 사요자가 명시하기 위해 try문 을 사용한다. try 키워드 뒤 블록에는 예외가 발생할 가능성이 있는 명령문들을 넣는다.catch 키워드 뒤에는 예외타입을 지정하고, 해당 예외타입의 예외가 발생하면, 실행할 명령문을 뒤에 블록에다가 작성한다.finally 키워드 뒤 블록에는 예외 발생 여부와 상관없이 마지막에 실행할 명령문을 작성하는데, 이는 생략할 수 있다. 123456789101112131415class Ex_try&#123; public static void main(String args[]) &#123; int a=10, b=0, result; try &#123; result = a/b; System.out.println(result); &#125; catch (java.lang.ArithmeticException exp) &#123; System.out.println(&quot;잘못된 산술연산입니다!&quot;); &#125; finally &#123; System.out.println(&quot;실행 끝&quot;); &#125; &#125;&#125; Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] 메소드 호출","slug":"java5","date":"2019-02-16T12:55:19.000Z","updated":"2019-02-16T14:11:16.925Z","comments":true,"path":"2019/02/16/java5/","link":"","permalink":"http://dudri63.github.io/2019/02/16/java5/","excerpt":"","text":"1. 메소드 호출2. 메소드 호출문3. main 메소드 1. 메소드 호출 자바 프로그램 : 클래스들로 구성클래스 : 메소드들로 구성 자바 프로그램을 실행하면 main 메소드가 자동으로 실행을 시작한다. 처리할 작업마다 담당 메소드를 두고, 필요에 따라 메소드들 간에 서로 협력하면서 전체 작업을 수행한다.메소드 호출 : 다른 메소드가 담당한 작업이 필요한 경우, 해당 메소드에게 작업 요청하는 것호출된 메소드의 수행이 끝나면 메소드를 호출했던 위치로 되돌아가서 나머지 명령을 계속 수행. 2. 메소드 호출문 메소드 호출문에 포함된 매개변수(parameter)의 데이터 타입과 개수가 정의된 메소드의 형식과 맞아야 한다. 2.1 리턴 값이 없는 경우 void 타입으로 정의된 메소드는 리턴값이 없는 메소드이다.이러한 메소드를 호출할 때는 매개변수만 지정하여 호출한다. 123456789101112131415161718class Ex_noreturn&#123; public static void main(String args[]) &#123; System.out.println(&quot;- main 메소드 시작&quot;); printCh(&apos;*&apos;,10); System.out.println(&quot;- main 메소드 끝&quot;); &#125; static void printCh(char ch, int num) &#123; System.out.println(&quot;- printCh 메소드 시작&quot;); for(int i=0; i&lt;num; i++) System.out.println(ch); System.out.println(); System.out.println(&quot;- printCh 메소드 끝&quot;); &#125;&#125; 2.2 리턴 값이 있는 경우 void 이외의 리턴타입이 정의된 메소드를 호출할 경우에는 리턴 값을 받아서 대입할 변수를 호출문 좌변에 지정해야 한다.호출된 메소드는 return 명령문을 사용하여 호출한 곳으로 결과 값을 넘긴다. 1234567891011121314151617181920class Ex_return&#123; public static void main(String args[]) &#123; System.out.println(&quot;- main 메소드 시작&quot;); int cnt; cnt = printCh(&apos;*&apos;,10); System.out.println(&quot;문자 &quot; + cnt + &quot;개 출력완료&quot;); System.out.println(&quot;- main 메소드 끝&quot;); &#125; static int printCh(char ch, int num) &#123; System.out.println(&quot;- printCh 메소드 시작&quot;); int i; for(i=0; i&lt;num; i++) System.out.println(ch); System.out.println(); System.out.println(&quot;- printCh 메소드 끝&quot;); return i; &#125;&#125; 3. main 메소드 메소드는 호출이 되어야만 실행이 된다.그러나 main 메소드는 프로그램이 수행되면 자동으로 실행한다.main 메소드는 자바 프로그램을 실행시키는 자바 가상 머신에서 자동으로 호출한다.따라서 main 메소드의 매개변수 String args[]는 main 메소드를 호출하는 자바 가상 머신에서 실행 시작 명령과 함께 념겨주는 값이다. 1234567class Ex_main&#123; public static void main(String args[]) &#123; for (String str : args) System.out.println(str); System.out.println(&quot;main 매개변수 개수 : &quot; + args.length + &quot;개&quot;); &#125;&#125; 매개변수로 월~일을 입력하였더니 args 배열의 상태가 변경된다. Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] 제어문","slug":"java4","date":"2019-02-16T08:12:55.000Z","updated":"2019-02-16T12:53:41.502Z","comments":true,"path":"2019/02/16/java4/","link":"","permalink":"http://dudri63.github.io/2019/02/16/java4/","excerpt":"","text":"1. 조건문1.1 명령문1.2 switch 명령문2. 반복문2.1 for문2.2 while문2.3 do-while문 1. 조건문 = 분기문 주어진 조건의 검사 결과에 따라서 실행할 명령문을 구별하여 처리한다. 1.1 if 명령문 if 다음에 나오는 조건식을 검사, 그 결과 값이 참이면, 그 다음에 나오는 명령문을 수행한다.수행할 명령문이 2개 이상이면 반드시 중괄호를 이용하여 블록을 구분한다.조건식의 결과 값이 겆시이면, 다음에 나오는 명령문을 수행하지 않고 건너뛴다. 또한, 조건식의 결과값이 참이라서 명령문들을 수행하였다면, else 뒤 블록은 건너뛴다.반대로 조건식의 결과값이 거짓이라서 명령문들을 수행하지 않았다면, else 뒤 블록을 수행한다. 12345678910111213class ex_if &#123; public static void main (String args[])&#123; int average = 80; if (average &gt;= 90) System.out.println(&quot;평균 : &quot;+ average +&quot; -&gt; A&quot;); else if (average &gt;= 80) System.out.println(&quot;평균 : &quot;+ average +&quot; -&gt; B&quot;); else if (average &gt;= 70) System.out.println(&quot;평균 : &quot;+ average +&quot; -&gt; C&quot;); else if (average &lt; 70) System.out.println(&quot;평균 : &quot;+ average +&quot; -&gt; F&quot;); &#125;&#125; 1.2 switch 명령문 키워드 swtich 뒤에 있는 식을 계산, 구한 값과 일치하는 case 문을 찾아서 해당 명령문을 수행, break 명령을 만나면 switch 명령문을 빠져나간다.만약 일치하는 case문이 없으면 default 문의 명령을 실행한다. case 뒤에 나오는 값, swithc 문 안의 식은 반드시 정수 타입이어야 한다.정수 타입이 될 수 있는 것들은 다음과 같다. 정수 타입의 변수 정수의 유니코드 값을 갖는 문자 열거 타입의 상수 123456789101112131415161718192021222324252627public class ex_switch &#123; public static void main (String args []) &#123; Week nowWeek = Week.FRI; switch (nowWeek) &#123; case MON: System.out.println(&quot;오늘은 월요일&quot;); break; case TUE: System.out.println(&quot;오늘은 화요일&quot;); break; case WED: System.out.println(&quot;오늘은 수요일&quot;); break; case THU: System.out.println(&quot;오늘은 목요일&quot;); break; case FRI: System.out.println(&quot;오늘은 금요일&quot;); break; case SAT: System.out.println(&quot;오늘은 토요일&quot;); break; default: System.out.println(&quot;오늘늘 일요일&quot;) ; &#125; &#125;&#125; 2. 반복문 같은 명령문을 여러 번 반복 수행하도록 하기 위해서 반복문을 사용한다.자바에서는 for 반복문, while 반복문, do while 반복문이 있다. 2.1 for 문 1234567class Ex_for1&#123; public static void main(String args[]) &#123; for(int i=0; i&lt;10; i++) &#123; System.out.println(i); &#125; &#125;&#125; 1234567891011class Ex_for2&#123; public static void main(String args[]) &#123; int arr[] = new int[5]; for(int i=0; i&lt;arr.length; i++) &#123; arr[i] = i*10; &#125; for(int i=0; i&lt;arr.length; i++) &#123; System.out.println(arr[i]); &#125; &#125;&#125; 자바에서는 배열에 대해 사용할 수 있는 for 반복문의 형식을 추가로 제공한다.형태는 다음과 같다. for (데이터 타입 변수이름 : 배열 이름) { 명령문;} 주의할 점은 위 for문은 기존 배열과 똑같은 데이터 타입의 새로운 변수를 추가로 생성하는 것이다.그리하여 배열의 인덱스 0부터 하나씩 변수에 대입, 명령문을 수행하는 방식이다.따라서 값을 사용할 수만 있고, 변경하는 것은 불가능하다. 1234567891011class Ex_for3&#123; public static void main(String args[]) &#123; int arr[] = new int[5]; for(int i=0; i&lt;arr.length; i++) &#123; arr[i] = i*10; &#125; for(int value : arr) &#123; System.out.println(value); &#125; &#125;&#125; 2.2 while 문 조건식이 참이면 해당 명령을 반복하여 수행한다. 123456789class Ex_while&#123; public static void main(String args[]) &#123; int i = 0; while(i&lt;10) &#123; System.out.println(i); i++; &#125; &#125;&#125; 2.3 do-while 문 do-while문은 while 문과 조건 검사를 수행하는 위치가 다르다.do-while문은 명령문을 먼저 수행한 후에 조건식을 검사한다.그러므로 do-while 반복문은 처음부터 조건식이 거짓이어도 명령문이 최소 1회 수행된다. 123456789class Ex_dowhile&#123; public static void main(String args[]) &#123; int i = 0; do&#123; System.out.println(i); i++; &#125;while(i&lt;10); &#125;&#125; Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] 데이터 타입","slug":"java3","date":"2019-02-13T11:35:06.000Z","updated":"2019-02-16T07:46:18.826Z","comments":true,"path":"2019/02/13/java3/","link":"","permalink":"http://dudri63.github.io/2019/02/13/java3/","excerpt":"","text":"1. 데이터 타입2. 기본 타입3. 참조 타입3.1 배열 타입3.2 클래스 타입3.3 인터페이스 타입3.4 열거 타입 1. 데이터 타입 변수(variable)란 어떤 값을 저장하는 공간이다.변수를 선언할 때 변수에 저장할 수 있는 값의 타입, 즉, 데이터 타입을 함께 선언해야 한다.데이터 타입은 변수의 용도를 정의하기 때문이다. 자바의 데이터 타입은 키워드로 정의되어 있는 기본 타입(Primitive Type), 기본 타입을 기초로 만들어진 참조 타입(Reference Type)이 있다. 2. 기본 타입 자바의 기본 타입은 8개의 키워드로 정의된 것인데, 다음과 같다. byte, short, int, long, char, float, double, boolean 기본 타입을 제외한 나머지 타입은 참조 타입이다. 데이터 타입을 사용하여 변수를 선언하면 해당 타입에 따라 정해진 메모리 크기가 할당되어 메모리값을 저장하고 사용할 수 있는 상태가 된다.자바에서 제공하는 기본 타입별 메모리 할당 크기는 다음과 같다. 3. 참조 타입 참조 타입은 참조 값(Reference Value), 즉, 메모리 주소를 계산할 수 있는 참조 값을 다루기 위한 타입으로, 배열, 클래스, 인터페이스, 열거 타입으로 나뉜다.참조 타입의 변수에는 실제 데이터 값이 저장된 메모리 위치를 찾아갈 때 사용할 값(참조값)이 저장된다.이 후, 저장된 참조 값을 이용해서 필요한 데이터가 있는 실제 메모리 주소를 계산하는 것은 자바 가상 머신에서 담당한다. 3.1 배열 타입 배열(Array)은 같은 데이터 타입을 가진 데이터들을 메모리에 연속적으로 저장하여 만든 데이터들의 그룹이다.변수들을 한데 묶어서 하나의 배열로 만들면, 단 한번만 배열을 선언하면 되고, 각 요소들은 배열의 내부 요소가 되어 다루기가 쉬워진다.배열의 요소를 구별하기 위해 번호를 사용하는데, 이를 인덱스(index)라고 한다.인덱스는 0부터 시작한다.구성 형태에 따라서 1차워 배열, 2차원 배열, 3차원 배열도 가능하다. 1차원 배열의 선언과 생성 및 사용 1차원 배열을 선언하는 방식은 다음과 같다. 데이터타입 배열이름 []; ex. char c[];데이터타입 [] 배열이름; ex. char[] c; 선언한 배열을 생성할 때는 배열 생성 명령을 사용해야 한다.배열에 대한 메모리를 생성하기 위해 new 연산자를 사용한다.배열 생성 명령은 다음과 같다. new 데이터타입 [배열크기]; ex. c = new char[10];, 이 때, 배열 요소 [0]~c[9] 기본 타입의 변수를 선언하는 경우, 데이터 타입에 맞는 크기의 메모리 공간이 자동으로 할당, 데이터를 저장할 변수가 생성된다.그러나 배열과 같은 참조 타입의 변수를 선언하면 데이터를 저장할 수 있는 공간이 할당되는 것이 아니라, 메모리 공간에 대한 참조, 즉 메모리 주소 정보(참조 값)를 저장할 수 있는 공간만 확보된다.이 후, 실제 데이터를 저장할 메모리 공간을 생성하려면 new 연산자의 생성식을 사용한다. 123456789101112class ex_array &#123; public static void main(String args[]) &#123; int i_arr[]; // 배열 i_arr 선언 i_arr = new int[3]; // int형 공간 3개를 메모리에 연속 생성, 시작 주소를 배열변수 i_arr에 대입 i_arr[0] = 10; // i_arr 초기 i_arr[1] = 20; i_arr[2] = 30; System.out.println(&quot;i_arr[0] = &quot; + i_arr[0]); System.out.println(&quot;i_arr[1] = &quot; + i_arr[1]); System.out.println(&quot;i_arr[2] = &quot; + i_arr[2]); &#125;&#125; 배열 선언과 배열 생성 명령을 다음과 같이 하나의 명령문으로 표현할 수도 있다. int i_arr[] = new int[3]; 배열 선언, 배열 생성 명령, 배열 초기화를 다음과 같이 하나의 명령문으로 표현할 수도 있다. i_arr[] = {10, 20, 30}; 위와 같은 방식을 사용할 경우, new 연산자와 배열의 크기 지정을 하지 않아도 된다. 다차원 배열의 선언과 생성 및 사용 2차원 이상의 배열을 다차원 배열이라고 한다.2차원 배열을 선언하는 방식은 다음과 같다. 데이터타입 배열이름 [][]; // int i_arr2[][];데이터타입 [][] 배열이름; // int [][] i_arr2; 2차원 배열을 생성하는 방식은 다음과 같다. new 데이터타입 [배열크기1][배열크기2]; 배열크기 1이 행의 개수, 배열크기 2는 열의 개수이다.배열 요소의 전체 개수는 (배열크기1 * 배열크기2) 이다. 2차원 배열이 메모리상 저장되는 방식은 ‘행 번호 0의 열 번호 0부터 열 번호 n까지’를 시작으로, ‘행 번호 n의 열 번호 0부터 n까지’ 순차적으로 저장된다. 123456789101112131415161718class ex_array2 &#123; public static void main(String args[]) &#123; int i_arr2[][] = new int[2][3]; // 2차원 배열 i_arr2 (2행 3열짜리) 선언 및 생성 i_arr2[0][0] = 10; i_arr2[0][1] = 20; i_arr2[0][2] = 30; i_arr2[1][0] = 100; i_arr2[1][1] = 200; i_arr2[1][2] = 300; System.out.println(&quot;i_arr2[0][0] = &quot; + i_arr2[0][0]); System.out.println(&quot;i_arr2[0][1] = &quot; + i_arr2[0][1]); System.out.println(&quot;i_arr2[0][2] = &quot; + i_arr2[0][2]); System.out.println(&quot;i_arr2[1][0] = &quot; + i_arr2[1][0]); System.out.println(&quot;i_arr2[1][1] = &quot; + i_arr2[1][1]); System.out.println(&quot;i_arr2[1][2] = &quot; + i_arr2[1][2]); &#125;&#125; 배열 선언, 생성 및 초기화 과정은 다음과 같이 하나의 명령문으로 표현할 수도 있다. 1int i_arr2[][] = &#123;&#123;10,20,30&#125;, &#123;100,200,300&#125;&#125;; 중괄호 내에서 첫 번째 중괄호가 첫 번째 행에 대한 초기값, 두 번째 중괄호는 두 번째 행에 대한 초기값이 된다. 3.2 클래스 타입 클래스 타입은 여러 타입의 변수와 메소드를 그룹으로 묶어서 새롭게 정의한 사용자 정의 타입이다.데이터 타입을 정의할 때는 그 데이터를 연산할 수 있는 메소드가 함께 정의되어야 한다.자바에서 제공하는 기본 타입은 그에 대한 메소드가 이미 정의되어 있으므로 메소드 정의 없이 타입에 대한 변수만 선언하고 사용하는 거이다.배열 타입 역시 사용자 정의 타입이기는 하지만, 이미 자바에 의해 해당 타입에 대해서 이미 정의되어 있는 메소드가 있다. 클래스 타입은 완전한 새로운 타입을 정의하는 것이기 때문에 자바에서 정의해 놓은 기본 메소들르 사용할 수가 없다.그러므로 클래스로 정의한 데이터 타입을 연산할 수 있는 메소드까지 클래스 타입에 포함시켜 사용자가 정의하여야 한다. 클래스 타입의 정의와 선언 및 생성 클래스 타입을 정의할 때는 키워드 class 뒤에 클래스이름을 쓰고, 중괄호 사이에 변수 및 상수에 대한 데이터 멤버와 멤버 메소드를 정의한다. 123456789101112131415161718192021222324252627282930313233343536373839class PointXY &#123; int x, y; PointXY(int x, int y) &#123; // 생성자 메소 this.x = x; this.y = y; &#125; void setX(int x) &#123; this.x = x; &#125; void setY(int y) &#123; this.y = y; &#125; void moveXY(int x, int y) &#123; this.x += x; this.y += y; &#125;&#125;class ex_class &#123; public static void main (String args[]) &#123; int i = 10; int j = 20; System.out.println(&quot;i = &quot; + i); System.out.println(&quot;j = &quot; + j); System.out.println(&quot;After PointXY A(i,j)&quot;); PointXY A; A = new PointXY(i,j); System.out.println(&quot;A.x = &quot; + A.x); System.out.println(&quot;A.y = &quot; + A.y); System.out.println(&quot;After A.setX(15)&quot;); A.setX(15); System.out.println(&quot;A.x = &quot; + A.x); System.out.println(&quot;A.y = &quot; + A.y); System.out.println(&quot;After A.moveXY(3,3)&quot;); A.moveXY(3,3); System.out.println(&quot;A.x = &quot; + A.x); System.out.println(&quot;A.y = &quot; + A.y); &#125;&#125; 메소드 중에서 클래스 이름과 같은 이름의 메소드를 생성자(Constructor) 메소드라고 한다.클래스 타입의 변수를 생성할 때마다 자동으로 실행, 데이터 멤버들을 초기화한다. 클래스 타입도 배열과 마찬가지로 참조 타입이기 때문에 new 명령어를 사용하여 변수에 대한 메모리를 생성하고 그 참조값을 클래스 타입의 변수에 대입해야 한다. 클래스 타입을 정의한 파일을 컴파일하면 각 클래스마다 별도의 클래스 파일이 생성된다. 그리고 자바 가상 머신이 프로그램을 실행할 때 필요한 클래스 파일들을 자동으로 읽어서 사용한다. 3.3 인터페이스 타입 인터페이스 타입은 여러 클래스 타입에서 공통으로 사용하는 상수와 메소드를 따로 분리하여 추상화시킨 타입이다.클래스 타입과 유사하지만, 데이터 멤버에 상수만 사용할 수 있고, 멤버 메소드를 내용 없이 선언만 한다는 점에서 차이가 있다. 인터페이스 타입 정의 키워드 interface 뒤에 인터페이스 이름을 쓰고, 중괄호 사이에 필요한 상수와 메소드들을 선언한다.이 때, 중괄호 내에 있는 메소드는 이름만 있고 실제 내용은 정의하지 않은 추상 메소드(Abstract Method)이다. 예를 들어 서로 다른 도형에 대해 클래스 타입들이 있을 때 도형의 형태에 따라서 넓이를 구하는 방법이 다르므로, 넓이를 구하는 메소드 getArea()를 추상화하여 인터페이스 타입으로 따로 선언할 수 있다. 123interface Shape&#123; void getArea();&#125; 위 코드를 Shape.java로 저장, 컴파일하면 Shape.class라는 클래스 파일이 생성된다.자바 컴파일러는 인터페이스 타입을 클래스 파일로 처리한다. 인터페이스 타입에 대한 구현 클래스 정의 인터페이스 타입은 추상화된 타입이기 메소드에 대한 내용이 정의되어 있지 않다.따라서 인터페이스 타입의 추상 메소드의 내용을 정의하여 구현(implement)하는 클래스 타입이 필요하다.인터페이스 타입을 구현하는 클래스 타입을 정의할 때는 클래스 이름 뒤에 키워드 implements와 구현할 인터페이스 이름을 추가, 구현하는 멤버 메소드 앞에 키워드 public을 붙인다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Triangle implements Shape &#123; int x, y; double area; Triangle(int x, int y) &#123; this.x = x; this.y = y; &#125; public void getArea() &#123; this.area = this.x * this.y / 2; &#125;&#125;class Rectangle implements Shape &#123; int x, y; double area; Rectangle(int x, int y) &#123; this.x = x; this.y = y; &#125; public void getArea() &#123; this.area = this.x * this.y; &#125;&#125;class ex_interface &#123; public static void main(String args[])&#123; int i = 10; int j = 20; System.out.println(&quot;i = &quot; + i); System.out.println(&quot;j = &quot; + j); System.out.println(&quot;After Triangle A; &amp; A = new Triangle(i,j)&quot;); Triangle A; A = new Triangle(i,j); System.out.println(&quot;After A.getArea()&quot;); A.getArea(); System.out.println(&quot;A.area = &quot; + A.area); System.out.println(&quot;After Rectangle B; &amp; B = new Triangle(i,j)&quot;); Rectangle B; B = new Rectangle(i,j); System.out.println(&quot;After B.getArea()&quot;); B.getArea(); System.out.println(&quot;B.area = &quot; + B.area); &#125;&#125; 인터페이스 타입도 참조 타입이므로 new 명령어를 사용하여 생성 작업을 해주어야 할 것이다.그러나 인터페이스 타입은 그 내부에 추상 메소드가 내용이 없기 때문에 필요한 메모리 크기를 알 수 없다.그리하여 인터페이스 타입의 변수를 생성할 때 인터페이스를 구현한 클래스 타입을 사용한다. 이에 대한 설명은 아래 예제 코드를 참고한다.1234Shape shape1;shape1 = new Triangle(10,20); // 클래스 타입을 사용하여 변수 생성Shape shape2;shape2 = new Rectangle(20,30); // 클래스 타입을 사용하여 변수 생성 3.4 열거 타입 표현할 데이터가 정해진 수의 값만을 가지고 있는 경우가 있다.예를 들어, “요일”을 표현하는 값은 오직 ‘월’, ‘화’, ‘수’, ‘목’, ‘금’, ‘토’, ‘일’이다.7개의 값을 7개의 상수로 선언할 수도 있지만,7개의 상수만을 값으로 사용하는 하나의 타입으로 정의하여 사용할 수 있다.이런 타입을 열거(enumerate) 타입이라고 한다. 열거 타입 정의 키워드 enum 뒤에 열거 타입의 이름을 쓰고, 중괄호 사이에 선언할 상수들을 콤마로 구분하여 나열한다. 123enum Week&#123; MON, TUE, WED, THU, FRI, SAT, SUN&#125; Week.java로 저장한뒤 컴파일하면 Week.class라는 클래스 파일이 생성된다.자바 컴파일러는 열거 타입을 인터페이스 타입과 마찬가지로 클래스 파일로 처리한다. 열거 타입 변수의 선언과 사용 12345678class ex_week&#123; public static void main(String args[])&#123; Week myWeek = Week.FRI; Week yourWeek = Week.SAT; System.out.printf(&quot;MY special day : (%s) %n&quot;, myWeek); System.out.printf(&quot;Your special day : (%s) %n&quot;, yourWeek); &#125;&#125; 열거 타입은 힙 영역에 열거한 상수만큼 저장한다.월, 화, 수, 목, 금, 토, 일을 힙 영역에 저장하였다.그러므로 따로 변수를 생성하지 않고, 힙 영역에 생성된 상수를 참조하면 되기 때문에 new 연산자를 사용하지 않는다.또한, 열거 타입의 변수는 그 타입에 속하는 상수 값만을 대입하여 사용할 수 있다. Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] 자바 식별자","slug":"java2","date":"2019-02-12T14:14:31.000Z","updated":"2019-02-16T07:46:04.901Z","comments":true,"path":"2019/02/12/java2/","link":"","permalink":"http://dudri63.github.io/2019/02/12/java2/","excerpt":"","text":"자바에서 사용하는 단어의 종류는 다음과 같다. 키워드(Keyword) : 미리 정해둔 의미로만 사용하는 50개의 단어 상수 값을 표현하는 단어 3개 : true, false, null 식별자(identifier) : 클래스, 메소드, 변수 등의 이름으로 사용하는 단어 ▲ 자바 키워드 식별자 생성 규칙 하나 이상의 문자로 이루어져야 한다. 첫 번째 문자는 영문자 또는 ‘$’ 또는 ‘_’이어야 한다. ‘$’, ‘_’ 이외의 특수문자를 사용할 수 없다. 문자 길이의 제한이 없다. 키워드나 상수 값을 표현하는 단어는 식별자로 사용할 수 없다. 여러 개의 식별자를 사용할 때는 식별자 사이를 점으로 연결한다.다음은 명령문 예시이다. System.out.println System은 클래스 이름, out은 System 클래스 내부 변수의 이름, println은 out 변수에 속하는 메소드 이름이다. Reference “CH05 변수, 연산자, 수식”, 냉유’s Log, 2019.2.12, https://keep-cool.tistory.com/5 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[Java] 자바의 기초","slug":"java1","date":"2019-02-12T09:55:38.000Z","updated":"2019-02-16T07:46:10.581Z","comments":true,"path":"2019/02/12/java1/","link":"","permalink":"http://dudri63.github.io/2019/02/12/java1/","excerpt":"","text":"1. 자바의 구성2. Hello Java3. 자바 프로그램의 구조4. 자바 실행 과정 1. 자바의 구성 ‘자바 플랫폼(Java Platform)’은 자바 프로그램을 실행할 수 있게 하는 ‘하드웨어적 프로그램’이다.자바 플랫폼은 자바 API(Application Programming Interface)와 자바 가상 머신으로 구성되어 있다. JAVA API 자바 API는 자바 응용프로그램을 만드는 데 필요한 유용한 클래스들과 사용 방법을 문서화하여 제공한다. JAVA 가상 머신 자바 가상 머신은 물리적인 기계 장치가 아니라 추상적인 장치이며, 클래스 파일을 실행할 수 있는 기계어 파일로 번역해 준다. 클래스 영역 실행에 필요한 클래스들을 로드, 저장하는 공간.로드된 클래스의 멤버 메소드들은 메소드 영역에 저장, 상수들은 상수 영역에 저장된다.사용자가 작성한 클래스 코드들도 또한 이 곳에 저장된다. 자바 스택 영역 자바 프로그램을 수행하면서 발생하는 메소드 호출과 복귀에 대한 정보를 생성, 저장, 관리하는 공간이다. 힙 영역 객체를 생성할 때 동적으로 공간을 할당, 객체를 저장하는 공간이다. 네이티브 메소드 스택 영역 자바에는 하드웨어를 직접 제어하는 기능이 없다.그래서 하드웨어를 제어해야 할 경우, C 언어와 같은 다른 언어의 기능을 잠시 빌려서 사용한다.이 때 사용하는 기술이 JNI(Java Native Interface)이다.네이티브 메소드들이 바이트 코드로 변환되면서 사용되고 기록하는 영역이 네이티브 메소드 스택 영역이다. 2. Hello, Java 위 코드를 HelloJava.java 이름을 저장한다. $ javac : 자바 소스 파일을 컴파일 한다.자바 컴파일러는 소스 파일을 클래스 파일(*.class, HelloJava.class)로 번역한다. $ java : 자바 가상 머신을 동작시킨다. 앞서 컴파일한 클래스 파일을 기계어 코드로 번역 및 실행한다. 3. 자바 프로그램의 구조 클래스(class) 자바 프로그램을 구성하는 단위.자바 프로그램은 내부적으로 한 개 이상의 클래스로 구성되어 있다. 위 자바 프로그램에서는 하나의 클래스로 구성이 되어 있다.클래스 이름은 JavaStructure, 중괄호로 묶인 부분이 클래스 본체이다. 메소드(method) 클래스 본체는 한 개 이상의 메소드가 있다.메소드는 수행할 명령문들의 묶음이다. 위 JavaStructure 클래스에서는 두 개의 메소드로 구성이 되어 있다.메소드 이름은 각각 sum, main이며, 중괄호로 묶인 부분이 메소드 본체이다. 메소드 이름은 개발자가 임의로 정할 수 있지만, main이라는 이름의 메소드가 반드시 한 개 있어야 한다.자바 프로그램의 실행 시작 지점이 main 메소드로 지정되어 있기 때문이다. 4. 프로그램 실행 과정 컴퓨터는 오직 이진수만을 처리한다.따라서 작성한 프로그램(소스코드)를 이진수의 조합, 즉, 기계어로 번역해야 한다.이 때 필요한 도구가 컴파일러(compiler)이다. C 프로그램(*.c)은 C 컴파일러,C++ 프로그램(*.cpp)은 C++ 컴파일러를통해 기계어로 번역, 실행 가능한 실행파일(*.exe)을 만든다. 위 컴파일러를 통해 생성된 실행파일은 컴파일러가 동작하는 운영체제에서만 실행할 수 있다.예를 들어 윈도우즈 운영체제에서 컴파일되어 생성된 실행파일은 오직 윈도우즈 운영체제에서만 실행 가능하고, 리눅스 등의 다른 운영체제 시스템에서는 실행되지 않는다.작성한 프로그램을 다른 시스템에서 실행시키려면 다른 시스템의 운영체제에서 다시 컴파일하여 실행 파일을 생성해야 한다. 이에 반해, 자바로 구현한 프로그램은 어떤 운영체제에서든지 수정하지 않고 사용할 수 있다.왜냐하면 JDK에 포함되어 있는 자바 가상머신(JVM, Java Virtual Machine) 때문이다.C나 C++ 컴파일러는 사용할 하드웨어와 운영체제에 꼭 맞춘 기계어 코드 파일을 만들어내는 반면,자바 컴파일러는 클래스 파일이라고 하는 가상 기계어로 된 코드 파일을 생성,자바 가상 머신이 클래스 파일을 진짜 기계어로 번역하여 실행하게 한다. Reference “[Java 04] 자바 프로그램의 구조”, 냉유’s Log, 2019.2.12, https://keep-cool.tistory.com/7 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Java","slug":"Language/Java","permalink":"http://dudri63.github.io/categories/Language/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://dudri63.github.io/tags/Java/"}]},{"title":"[자료구조] 소프트웨어와 자료구조","slug":"ds2","date":"2019-02-11T11:25:50.000Z","updated":"2019-02-16T07:45:44.368Z","comments":true,"path":"2019/02/11/ds2/","link":"","permalink":"http://dudri63.github.io/2019/02/11/ds2/","excerpt":"","text":"1. 소프트웨어 생명주기2. 추상 데이터 타입 1. 소프트웨어 생명주기 소프트웨어 : 프로그램의 개발과 운영 및 유지, 보수에 관련된 모든 정보와 작업을 포함하는 개념이다.정확하고 효율적인 소프트웨어를 개발하기 위해서는 개발할 소프트웨어를 정확히 이해하고, 사용할 자료와 자료간의 연산관계를 분석, 자료구조를 정의, 이에 대한 가장 효율적인 구조를 고안하여 개발해야 한다. 소프트웨어 생명주기 : Software Life Cycle = 소프트웨어 개발주기(Software Development Cycle)소프트웨어를 체계적으로 개발, 관리하기 위해 소프트웨어 개발 과정을 몇 단계로 구분한 것 필요한 단계로 피드백을 반복 수행, 완성도를 높임 요구 분석 단계 : Requirement Analysis 소프트웨어 개발의 첫단계 개발할 소프트웨어의 기능과 제약조건, 목표 등을 소프트웨어 사용자와 함께 정의하는 단계 개발 방법, 필요한 자원, 예산을 예측 요구 명세서를 작성, 요구 명세서는 소프트웨어 개발 완료 여부를 결정짓는 근거 시스템 명세 단계 : System Specification 시스템이 무엇을 수행해야 하는가를 정의. 시스템 기능 명세서를 작성. 입력 데이터 정의, 입력 데이터로 처리하는 내용, 출력 정의 / 가능한 정확하게 작성해야 한다. 설계 단계 : Design 2단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정 시스템 구조 설계 : 시스템을 구성하는 내부 프로그램, 모듈 간의 관계와 구조를 설계 프로그램 설계 : 프로그램 내의 각 모듈에서의 처리 절차나 알고리즘을 설계 사용자 인터페이스 설계 : 사용자에게 보이는 부분에 대한 설계 하향식 설계 방법무엇을 수행할 것인지 정의 -&gt; 어떻게 수행할 것인지 정의 -&gt; 점점 구체적으로 세부 문제 정의최하위 단계로 분할(divide)된 작은 단위의 문제들을 각각 처리, 전체 문제를 해결(conquer)분할 정복(Divide and Conquer) 상향식 설계 방법최하위 단계에 있는 작은 단위를 먼저 결정, 해결, 이를 이용하여 좀더 큰 단위인 상위 단계의 문제를 해결하는 방법 객체지향 설계 방법작은 단위의 문제에 대해 문제 해결을 위한 데이터와 처리 방법을 묶어서 객체 생성, 객체들을 연결하여 재사용하는 방법을 사용한다. 구현 단계 : Implementation 구현 단계에서는 설계 단계에서 논리적으로 결정한 문제해결 방법(알고리즘)을 C, C++, JAVA 등의 특정 프로그래밍 언어를 사용하여 실제 프로그램을 작성한다. 구조화 프로그래밍(Structured Programming)지정문, 조건문, 반복문만을 사용하여 프로그램 작성순차구조, 선택구조, 반복구조의 세 가지 제어구조로 표현하는 기법구조가 간단, 명확, 정확성 검증이 쉽고, 테스트와 유지 보수가 쉽다 모듈러 프로그래밍(Modular Programming)프로그램을 여러 개의 작은 모듈(module)로 나누어서 계층 관계를 갖도록 구성각각의 모듈은 구조화 프로그래밍 기법으로 작성, 하나의 기능만을 수행모듈별로 개발, 테스트, 유지 보수가 가능하고, 재사용이 가능하다 효과적인 프로그래밍을 위해 프로그램을 명확하게 작성, 임시변수는 되도록 사용하지 않는다.또한 변수명은 일관, 이해하기 쉬운 이름, 같은 문장 최소화, 주석을 사용한다 테스트 단계 : Test 개발한 시스템이 요구사항을 만족하는지, 실행결과가 예상한 결과와 정확하게 맞는지를 검사, 평가, 오류를 찾아내어 시스템의 완성도를 높인다. 단위 테스트(Unit Test)시스템의 최소 구성요소인 모듈들에 대해 개별적으로 시행, 테스트한다. 통합 테스트(Integration Test)단위 테스트를 통과한 모듈을 모아서 전체 시스템을 완성하기 위해 통합적으로 시행하는 테스트.최소의 모듈을 연결, 점진적으로 다른 구성요소를 연결하면서 테스트한다. 하향식 테스트 상향식 테스트 인수 테스트(Acceptance Test)실제 데이터를 사용하여 시스템을 테스트 하는 과정, 실질적으로 사용되기 위해 마지막으로 시행되는 테스트 유지 보수 단계 오류 수정, 디자인 수정, 새로운 요구사항에 대한 기능 추가, 환경 변화에 따른 시스템 교정 등의 활동 소프트웨어 생명주기에서 가장 긴 시간을 차지한다. 수정형 유지 보수 : 사용중 발견한 오류를 수정 적응형 유지 보수 : 환경적 변화에 적응하도록 재조정 완전형 유지 보수 : 성능 향상 예방형 유지 보수 개발된 소프트웨어의 품질은 다음과 같은 기준에 따라서 평가한다. 정확성 유지 보수성 : 요구사하이 변동되었을 때 변경사항 처리 정도 무결성 : 보안성 사용성 : 사용자가 쉽게 사용할 수 있는 정도 2. 추상 데이터 타입 추상화(Abstraction)란 각종 정보들 중에서 필수적이고 중요한 특징만을 골라서 단순화시키는 작업이다.컴퓨터에서 문제를 해결할 때도 추상화 작업을 적용, 복잡한 문제를 단순화시켜 좀더 쉽게 문제를 해결하는 방법을 찾는다. 추상화 : ‘무엇(What)인가’를 논리적으로 정의 구체화 : ‘어떻게(How) 할 것인가’를 실제적으로 표현 자료 추상화(Data Abstraction)는 처리할 자료, 연산, 자료형에 대한 추상화 표현이다. 데이터 : 프로그램의 처리 대상이 되는 모든 것 연산 : 어떤 일을 처리하는 과정, 연산자에 의해 수행 데이터 타입 : 처리할 데이터의 집합 + 수행할 수 있는 연산자의 집합 시스템 정의 데이터 타입 사용자 정의 데이터 타입 추상 자료형(ADT, Abstract Data Type)은 자료와 연산자의 특성을 논리적으로 추상화하여 정의한 자료형이다. Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[자료구조] 자료구조 개요","slug":"ds1","date":"2019-02-10T08:59:24.000Z","updated":"2019-02-21T12:58:46.507Z","comments":true,"path":"2019/02/10/ds1/","link":"","permalink":"http://dudri63.github.io/2019/02/10/ds1/","excerpt":"","text":"1. 자료구조란1.1 자료구조란1.2 자료구조를 배워야 하는 이유2. 자료구조 분류3. 자료의 표현3.1 수치 자료의 표현3.2 문자 자료의 표현3.3 논리 자료의 표현3.4 포인터 자료의 표현3.5 문자열 자료의 표현 1. 자료구조란 1.1 자료구조란 컴퓨터는 자료를 처리하는 장치.컴퓨터를 잘 사용한다는 것은 내가 원하는 대로 자료를 잘 처리한다는 뜻이다.그런데 컴퓨터가 처리하는 자료에는 여러가지 형태가 있고, 그에 따라서 특징이 다르다.자료 구조란 다양한 자료들을 효율적으로 표현,저장,처리하기 위해서 어떻게, 어떤 구조로 구성하고 연산할 것인지를 정의하는 것이다. 1.2 자료구조를 배워야 하는 이유 소프트웨어나 프로그램의 개발 프로젝트에서 원하는 결과물을 얻었다고 해서 프로젝트가 성공했다가 할 수 는 없다.얼마나 효율적으로 개발하였고, 사용 및 관리가 될 수 있는가가 중요하다.그러기 위해서는 개발할 소프트웨어를 정확히 이해,사용할 자료와 자료간의 연산 관계를 분석, 최적의 자료구조를 정의,이에 대한 가장 효율적인 구조를 고안하여 개발해야 한다.따라서 자료구조에 대한 이론적,실제적 내용을 반드시 알아야 한다. 나쁜 자료구조와 좋은 자료구조 2. 자료구조 분류 자료구조를 형태에 따라 분류하면 다음과 같다. 단순 구조 : 데이터 타입에 해당 선형 구조 : 단순구조와 1:1 관계 비선형 구조 : 단순구조와 1:다, 다:다 관계 파일 구조 표현하고자 하는 자료의 특성, 양, 사용 방법, 연산 종류, 구현에 필요한 용량 등을 고려하여 가장 효율적인 자료구조를 선택하여야 한다. 또한, 자료구조를 표현 방시에 따라 분류하면 다음과 같다. 순차 자료구조 연결 자료구조 응용 자료구조 3. 자료의 표현 컴퓨터에서는 자료를 표현하기 위해 1과 0의 조합으로 구성된 이진수 코드를 사용한다.숫자,문자,그림,소리 등의 다양한 형식의 자료는 컴퓨터 내부에서 오직 1,0의 이진수 코드 형태로 표현, 처리, 저장된다. 한 자리의 1 또는 0을 표현하는 단위를 비트(bit)라고 하는데,비트는 디지털 시스템에서 자료를 표현하는 최소 단위이다.8개의 비트 그룹을 바이트(Byte)라고 한다.n개의 비트로 2n개의 상태를 표현할 수 있다. n개의 비트로 2n개의 상태 표현 3.1 수치 자료의 표현 3.1.1 10진수의 표현 10진수의 존(Zone) 형식 표현 10진수 한 자리를 표현하기 위해서 1바이트(8비트)를 사용하는데, 상위 4비트의 존 영역과 하위 4비트의 수치 영역으로 이루어진다. 존 형식의 구조 존 형식은 항상 1111로 표시,각 영역은 4비트의 이진수이기 때문에 십진수 0~15로 표현할 수 있다.(10은 A, 11은 B, 12는 C, 13은 D, 14는 E, 15는 F로 표기한다.) 표현하고자 하는 10진수의 자릿수만큼 존 형식을 연결하여 사용한다.이 때, 부호는 최하위 바이트의 존 영역에 나타내는데, 양수일 경우, 1100=C, 음수일 경우, 1101=D로 표기한다. 다음은 +213, -213의 존 형식이다. 10진수의 팩(Pack) 형식 표현 10진수를 존 형식으로 표현하라 경우, 최하위 바이트에서 부호를 표시하는 존 영역 이외의 다른 존 영역은 항상 1111이 들어가므로 기억 공간을 낭비하고 처리시간을 지연시키게 된다.이에 반해 팩 형식에서는 1바이트에 10진수 두자리를 표현, 최하위 바이트의 하위 4비트에 부호를 표시한다. 3.1.2 2진수의 ‘정수’ 표현 2진수는 일정한 길이의 n비트로 표현, 최상위 비트(MSB, Most Signficant Bit)인 첫 번째 1비트는 부호를 나타내고, 나머지 n-1 비트는 2진수 값을 표현한다. 부호절대값 형식의 표현 부호절대값 형식은 최상위 비트에 부호를 표시, 나머지 비트에 2진수의 절대값을 표기한다.부호가 양수일 경우, 최상위 비트를 0, 음수일 경우, 1로 한다. 다음은 +21, -21의 부호절대값 형식이다.단, 1바이트를 사용하여 2진수를 표현한다고 가정한다. 1의 보수(1’s Complement) 형식의 표현 1의 보수 형식에서 양수의 표현 방법은 부호절대값 형식과 같고,음수의 표현은 2진수를 1의 보수로 변환하여 표현한다. n비트를 사용하여 2진수를 표기할 경우, 1의 보수를 만드는 방법은 전체 n비트를 1로 한 값에서 절대값을 뺀다. 다음은 +21,-21의 1의 보수 형식이다.단, 1바이트를 사용하여 2진수를 표현한다고 가정한다. 2의 보수(2’s Complement) 형식의 표현 2의 보수 형식에서 양수의 ㅍ현 방법은 부호절대값 형식과 같고,음수의 표현은 2진술르 2의 보수로 변환하여 표현한다. 2의 보수를 만드는 방법은 1의 보수에 1을 더해준다. 다음은 +21, -21의 2의 보수 형식이다.단, 1바이트를 사용하여 2진수를 표현한다고 가정한다. 부호절대값 표현 형식, 1의 보수 표현 형식, 2의 보수 표현 형식 모두 양수에 대한 표현 방법은 동이하다.단, 음수를 표현하는 방법이 다르다. 부호절대값 : n-1비트의 절대값으로 표현, 최상위 비트에 음수 부호 표기 1의 보수 : n비트의 1의 보수로 표현 2의 보수 : n비트의 2의 보수로 표현 3.1.3 2진수의 ‘실수’ 표현 실수는 소수점을 가지고 있기 때문에 이에 대한 표현 방법이 필요하다.2진수 실수의 표현 방법은 소수점의 위치가 고정되어 있는 고정 소수점 형식, 고정되어 있지 않은 부동 소수점 형식이 있다. 고정 소수점 형식의 표현 고정소수점 표현 형식은 항상 최상위 비트의 왼쪽 밖에 고정되어 있는 것으로 취급한다. ex. 00010101 -&gt; 0.00010101 부동 소수점 형식의 표현 부동소수점 형식은 고정 소수점 형식에 비해 표현 가능한 값의 범위가 크다.그리하여 아주 작은 값이나 아주 큰 값을 표현하는 것이 가능하다.부호, 지수, 소수부, 총 세 부분으로 구성된다. 다음은 10진수 213에 대한 소수부, 지수에 대한 표현 형식이다. 다음은 2진수의 부동 소수점 형식이다.단, 4바이트를 사용한다고 가정한다. 단, 부호 비트는 양수면 0, 음수면 1을 사용한다.**3.2 문자 자료의 표현컴퓨터 내부에서 문자 자료 역시 1과 0의 2진수 조합으로 표현한다.문자에 대한 2진 코드를 정의해놓은 문자 코드들이 있다.BCD 코드, EBCDIC 코드, ASCII 코드, 유니코드 등이 그 예이다.C를 비롯한 대부분의 프로그래밍 언어는 ASCII 코드를 사용, 자바는 유니코드를 사용한다.3.2.1 BCD 코드BCD 코드는 6비트를 사용, 상위 2비트는 존 비트, 하위 4비트는 숫자 비트이다.다음은 BCD 코드표이다. 10진 숫자, 영어 대문자를 표현할 수 있다. 존비트 00 : 1~9, 0 존비트 01 : A~I 존비트 10 : J~R 존비트 11 : S~Z영문자 A에 대한 BCD 코드는 010001이다. 3.2.2 EBCDIC 코드 EBCDIC 코드는 8비트를 사용, 상위 4비트는 존 비트, 하위 4비트는 숫자 비트이다. 다음은 EBCDIC 코드의 구성이다. 다음은 EBCDIC 코드표이다. 10진수 숫자, 영어 대문자와, 소문자, 특수문자를 나타낼 수 있다. 존비트 AB = 00 : 여분 존비트 AB = 01 : 특수 문자 존비트 AB = 10 : 영어 소문자 존비트 CD = 00 : a~i 존비트 CD = 01 : j~r 존비트 CD = 10 : s~z 존비트 AB = 11 : 영어 대문자 존비트 CD = 00 : A~I 존비트 CD = 01 : J~R 존비트 CD = 10 : S~Z 존비트 CD = 11 : 숫자 0~9 3.2.3 ASCII 코드 ASCII 코드는 7비트를 사용, 상위 3비트는 존 비트, 하위 4비트는 숫자 비트이다. 다음은 ASCII 코드표이다. 10진수 숫자, 영어 대문자, 소문자, 특수문자를 나타낼 수 있다.EBCDIC 코드와 유사하지만 ASCII 코드를 더 많이 사용한다. 데이터 통신용으로 ASCII 코드를 사용할 경우, 패리티 비트를 최상위 비트로 추가하여 8비트 형식으로 사용하기도 한다. 3.3 논리 자료의 표현 논리자료는 논리값을 표현하기 위한 자료 형식이다.논리값이란 참(True)과 거짓(False)의 두 가지 상태 중에서 하나를 표시하기 때문에 1비트로도 표현이 가능하다.그러나 일반적으로 컴퓨터 내부에서는 1바이트를 사용한다.1바이트를 사용하여 논리 자료를 표현하는 경우, 참, 거짓의 논리값을 표현하기 위한 방법들은 다음과 같다. 참 : 00000001, 거짓 : 00000000 참 : 11111111, 거짓 : 00000000 참 : 8비트 중 어느 하나 이상의 비트가 1, 거짓 : 00000000 3.4 포인터(참조) 자료의 표현 포인터 자료는 메모리의 주소를 표현하고 사용하기 위한 자료 형식이다.자료를 저장하고 있는 변수나 특정 위치에 대한 메모리상의 주소를 저장하고 주소 연산에 사용한다.포인터 자료를 사용하면 복잡한 자료구조 연산을 메모리상에서의 주소 연산만으로 처리할 수 있다. 3.5 문자열 자료의 표현 문자열(String) 자료는 하나의 문자만 표현할 수 있는 문자 자료와 달리 여러 문자로 이루어진 문자의 그룹을 하나의 자료로 취급한다.그리하여 메모리상에 연속적으로 저장하는 자료 형식이다. 하나의 문자열 자료에 포함된 부분 문자열을 표현하는 방법들은 다음과 같다. 부분문자열 사이에 ‘구분자’를 두고 연속 저장하는 방법 가장 긴 부분문자열의 길이에 맞추어 ‘고정 길이’로 연속 저장하는 방법 부분문자열을 연속 저장하고 각 부분문자열에 대한 ‘포인터’를 사용하는 방법 Reference 이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"Data Structure","slug":"Basic-CS/Data-Structure","permalink":"http://dudri63.github.io/categories/Basic-CS/Data-Structure/"}],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://dudri63.github.io/tags/Data-Structure/"}]},{"title":"[Algorithm] 백트래킹 기법 (해 탐색)","slug":"algo40","date":"2019-02-09T07:54:41.000Z","updated":"2019-02-16T07:44:09.762Z","comments":true,"path":"2019/02/09/algo40/","link":"","permalink":"http://dudri63.github.io/2019/02/09/algo40/","excerpt":"","text":"1. 백트래킹 기법2. BacktrackTSP 알고리즘3. 시간복잡도 1. 백트래킹 기법 ‘백트래킹(Backtracking) 기법’은 해를 찾는 도중에 ‘막히면’ 되돌아가서 다시 해를 찾아가는 기법이다.백트래킹 기법은 최적화(optimization) 문제와 결정(decision) 문제를 해결할 수 있다.결정 문제란 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes or no로 답하는 문제이다.예시로 미로 찾기, 해밀토니안 사이클, 서양 장기 여왕 말, 부분 집합의 합 문제 등이 있다. 이전 포스팅에서 근사 알고리즘으로 해결한, NP-완전 문제인 여행자 문제 (TSP)를 백 트래킹 기법으로 해결하는 과정을 살펴본다. 2. BacktrackTSP 알고리즘 TSP를 위한 백트래킹 알고리즘은 다음과 같다.단, bestSolution은 현재까지 찾은 가장 우수한 해이며, (tour,tour의 거리)로 나타낸다.이 때, tour는 점의 순서이다. tour = [시작점] // tour는 점의 순서(sequence)bestSolution = (tour, ∞) // tour는 시작점만 가지므로 거리는 가장 큰 상수로 일단 초기화한다.BacktrackTSP(tour)12345678910if (tour가 완전한 해이면) if (tour의 거리 &lt; bestSolution의 거리) // 더 짧은 해를 찾았으면 bestSolution = (tour, tour의 거리)else &#123; for (tour를 확장 가능한 각 점 v에 대해서)&#123; newTour = tour + v // 기존 tour의 뒤에 점 v를 추가한다. if (newTour의 거리 &lt; bestSolution의 거리) BacktrackTSP(newTour) &#125;&#125; 다음의 그림에 대해서 BacktrackTSP 알고리즘이 수행되는 과정을 살펴본다.단, A가 시작점이다. 시작점이 A이므로 tour=[A], bestSolution = ([A], ∞)이다.BacktrackTSP(tour)를 호출한다. line 1 : [A]가 완전한 해가 아니므로, line 5의 for-루프가 수행 line 5 : tour=[A]를 확장할 수 있는 점은 B, C, D, E이다.각 점에 대해서 for-루프가 수행된다. 점 B에 대해서 수행되는 경우를 가정한다.line 6 : newTour = [A,B], newTour의 거리는 2가 된다.line 7~8 : newTour의 거리 2가 bestSolution ∞보다 짧으므로, BacktrackTSP([A,B])를 재귀 호출한다. line 1 : [A,B]가 완전한 해가 아니므로, line 5의 for-루프가 수행 line 5 : tour=[A,B]를 확장할 수 있는 점은 C, D, E이다.각 점에 대해서 for-루프가 수행된다. 점 C에 대해서 수행되는 경우를 가정한다.line 6 : newTour = [A,B,C], newTour의 거리는 5가 된다.line 7~8 : newTour의 거리 5가 bestSolution ∞보다 짧으므로, BackTrackTSP([A,B,C])를 재귀 호출한다.…이와 같이 계속 탐색을 진행하면 다음과 같은 첫 번째 완전한 해를 찾는다.이 때, bestSolution=([A,B,C,D,E,A],30)이다. 첫 번째 완전한 해를 찾은 후에 다음과 같이 수행, 더 짧은 해를 찾으므로 bestSolution=([A,B,C,E,D,A],18)이 된다. 다음은 tour=[A,B]에 대해서 모든 수행을 마친 결과이다.bestSolution=([A,B,E,C,D,A], 16)이 된다. 다음은 tour=[A,C]에 대해서 모든 수행을 마친 결과이다.bestSolution보다 더 우수한 해는 탐색되지 않았다.x 표시는 중간 단계에서 이미 bestSolution보다 짧음이 확정되어 가지치기가 된 것이다. 다음은 tour=[A,D]에 대해서 모든 수행을 마친 결과이다.bestSolution보다 더 우수한 해는 탐색되지 않았다. tour=[A,E]에 대해서 모든 수행을 마치면, bestSolution보다 더 우수한 해는 탐색되지 않는다.(그림 생략) 최종해=[A,B,E,D,D,A]이고, 거리=16이다. 3. 시간 복잡도 백트래킹 알고리즘의 시간 복잡도는 상태 공간 트리(state space tree)의 노드 수와 비례한다.상태 공간 트리란 시작 상태인 [A]로부터 점들 tour에 추가하여 확장시켜 탐색한 모든 상태들로 형성된 트리를 말한다.n개의 점이 있는 입력 그림에 대해서 BacktrackTSP 알고리즘이 탐색하는 최대 크기의 상태 공간 트리는 다음과 같다. 위 트리의 leaf 노드 수만 하여도 (n-1)!이다.이는 모든 경우를 다 검사하여 해를 찾는 완결탐새의 시간복잡도와 같다.그러나 일반적으로 백트래킹 기법은 ‘가지치기’를 하므로 완결탐색보다 훨씬 효율적이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “9장 해 탐색 알고리즘”, 서강대학교 컴퓨터공학과, 2019. 2. 10, https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjntMzW0LDgAhUCUt4KHb9RCkMQFjACegQICBAC&amp;url=http%3A%2F%2Fhompi.sogang.ac.kr%2F%40bb%2Fbboard.asp%3Fdb%3Dscsctrack_lecture2%26mode%3Ddownload%26num%3D28%26filename%3D09_backtracking.pdf&amp;usg=AOvVaw0X7DEzoPSOfKwWg0OUnvC0","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"해 탐색","slug":"해-탐색","permalink":"http://dudri63.github.io/tags/해-탐색/"},{"name":"TSP","slug":"TSP","permalink":"http://dudri63.github.io/tags/TSP/"}]},{"title":"[DataBase] Relational Data model (representational model)","slug":"db5","date":"2019-02-08T12:40:17.000Z","updated":"2019-03-09T08:07:06.524Z","comments":true,"path":"2019/02/08/db5/","link":"","permalink":"http://dudri63.github.io/2019/02/08/db5/","excerpt":"","text":"1. Relational Data model2. r db 용어3. Key attribute4. Integrity 1. Relational Data model Relational data model : 관계형 데이터 모델 representational(logical) model 중 가장 대중적인 모델 데이터를 관계(Relation) 들의 집합으로 표현 My sql, Msl sql : R DBMS, 관계형 데이터 모델을 생성하는 DBMS DBMS 종류에 따라서 ‘표현 데이터 모델’이 달라짐. ex. 관계형, 계층형, 망형 ex. 학생 relation 2. r db 용어 릴레이션(relation) 관계형 데이터베이스에서 정보를 구분하여 저장하는 기본 단위 예를 들어, 학생에 관한 정보를 저장하기 위해서는 STUDENT 릴레이션이 필요 동일한 데이터베이스에 내에서는 같은 이름을 가진 릴레이션이 존재할 수 없다. 속성(attribute) 표현할 개체의 구체적인 정보 항목에 해당하는 것이 속성이다. 현실 세계의 개체가 가진 특징 중 의미있는 것들을 선정, 릴레이션에 포함시킨다. 동일한 릴레이션 내에서는 같은 이름의 속성이 존재할 수 없다. 튜플(tuple) 릴레이션은 현실세계의 어떤 개체를 표현, 튜플은 그 개체에 속한 구성원들 각각의 정보를 표현 예를 들어, ‘학생’ 릴레이션에 ‘서영기’, ‘황희재’, ‘조경호’ 등이 튜플로서 존재 도메인(domain) 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값들의 집합 릴레이션에 저장되는 데이터 값들이 본래 의도했던 값들만을 저장, 관리하도록 하기 위해 필요한 개념 예를 들어, ‘성별’이라는 속성이 있다면, 그 속성의 값을 {남,여}만이 가능하다. 데이터베이스 설계자는 성별의 도메인으로 ‘SEX’를 정의하고, 그 값으로 {남,여}를 지정한 뒤, ‘성별’이라는 속성은 ‘SEX’ 도메인에 있는 값만을 가질 수 있다고 지정해 높으면 된다. 그러면 사용자들이 실수로 남, 여 이외의 값을 입력하는 것을 DBMS가 막을 수 있다. 하나의 도메인을 여러 속성에서 공유할 수 있다. 현실적으로 모든 속성에 대해 부합하는 완벽한 도메인들을 미리 선언할 수는 없다. 기본적으로 데이터 타입과 길이를 미리 지정하여 그에 맞는 값들만 들어오도록 하여 속성 값들을 관리한다. 위 용어들은 파일 시스템 용어와도 다르고, 오늘날 여러 용어가 혼용되어 살고 잇다. 다음은 유사 개념인 용어들을 정리해 놓은 것이다. 3. key attribute Key는 relation 내에 서로 다른 tuple들을 구별할 수 있는 유일한 기준이 되는 attribute. 후보키(Candidate Key) 테이블을 구성하는 속성들 중에서 tuple을 유일하게 식별할 수 있는 속성들의 부분집합 모든 테이블은 반드시 하나 이상의 후보키를 가져야 한다. 테이블에 있는 모든 튜플에 대해서 유일성과 최소성을 만족시켜야 한다. ex. &lt;학생&gt; 테이블에서 ‘학번’이나 ‘주민등록 번호’ attribute는 서로 다른 tuple들을 유일하게 &gt;구별할 수 있다. 그러므로 후보키가 되어 기본키로도 사용할 수 있다. 기본키(Primary Key) 후보키들 중에서 선태한 주키(Main Key) 한 테이블에서 특정 튜플을 유일하게 구별할 수 있는 속성 Null 값을 가질 수 없다. 기본키로 정의된 속성에는 동일한 값이 중복되어 저장할 수 없다. ex. &lt;학생&gt; 테이블에는 ‘학번’이나 ‘주민등록 번호’가 기본키가 될 수 있다. 대체키(Alternate Key) 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 일컫음 ‘보조키’라고도 한다. 슈퍼키(Super Key) 슈퍼키는 한 테이블 내에 있는 속성들의 집합으로 구성된 키, 모든 튜플들은 슈퍼키로 구성된 속성의 집합과 동일한 값을 지니지 않는다. 모든 튜플들에 대하여 유일성은 만족, 그러나 최소성을 만족시키지 못함. ex. &lt;학생&gt; 테이블에서는 ‘학번’, ‘주민등록 번호’, ‘학번’+’주민등록 번호’, ‘학번’+’주민등록 번호’+’성명’ 등으로 슈퍼키를 구성할 수 있다. 이 때, ‘학번’+’주민등록 번호’, ‘학번’+’주민등록 번호’+’성명’ 등이 최소성을 만족하지 못하는 경우이다. 외래키(Foreign Key) 후보키는 하나의 테이블 내에서 튜플이 중복되지 않음을 보증하는 수단이다. 이와 달리 테이블 간의 데이터 일치와 무결성을 보증해주는 수단이 외래키이다. 테이블 A가 테이블 B의 기본키에 해당하는 컬럼을 가지고 있을 때 테이블 A가 테이블 B를 참조한다고 한다. 그리고 테이블 A에 있는 테이블 B의 기본키 컬럼을 외래키라고 부른다. 외래키는 참조하는 테이블과 참조되는 테이블의 연결고리 역할을 한다. 위 경우, 사원 테이블에서 사원이 속한 부서의 이름을 알 수 없다.부서의 이름을 알려면 부서번호(Dno)를 가지고 부서 테이블에 가서 부서번호에 해당하는 부서명을 찾아야 한다.즉, 사원 테이블은 부서에 테이블에서 정보를 찾을 수 있는 키를 가지고 있다.사원 테이블은 부서 테이블을 참조한다고 할 수 있다.이 때, Dno는 FK(Foreign Key)이다. 4. Integrity 데이터의 무결성은 데이터의 정확성, 일관성, 유효성이 유지되는 것을 일컫는다.데이터의 무결성을 유지하는 것이 DBMS의 중요한 기능이며, 주로 데이터에 적용되는 연산에 제한을 두어 데이터의 무결성을 유지한다. 개체 무결성 (Entity integrity)모든 테이블이 기본 키로 선택된 칼럼을 가져야 한다. 기본 키로 선택된 속성은 고유한 값을 가져야 하며, NULL 값을 허용하지 않는다. 참조 무결성 (Referential integrity)참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것을 말한다. 위 경우는 참조 무결성이 깨지는 경우이다. department 테이블에서 id 값이 310인 튜플이 삭제되면, student 테이블의 3번째 레코드는 더 이상 존재하지 않는 데이터를 참조하게 된다.다음은 참조 무결성을 지키기 위한 개념이다. RESTRICTED : 튜플을 변경 또는 삭제할 때, 해당 튜플을 참조하는 개체가 있다면, 변경 또는 삭제 연산을 취소한다. CASCADE : 튜플을 변경 또는 삭제하면, 해당 튜플을 참조하고 있는 개체도 변경 또는 삭제된다. SET NULL : 튜플을 변경 또는 삭제하면, 해당 튜플을 참조하고 있는 개체의 값을 NULL로 설정한다. 도메인 무결성 (Domain integrity)테이블에 존재하는 칼럼의 무결성을 보장하기 위한 것으로서, 타입, NULL값의 허용 등에 대한 사항을 정의한 뒤, 올바른 데이터가 입력되었는지를 확인하는 것이다. 5. View 뷰(View) 는 하나 이상의 테이블에 대하여 특정 사용자나 조직의 관점에서 데이터를 바라볼 수 있도록 해주는 수단이다. 가상 테이블이라고도 부른다. 예를 들어, 각각의 부서에서 각 부서에 속해있는 사원 정보가 필요한 경우를 고려한다.이 때, 존재하는 사원 테이블을 모든 부서에 일괄적으로 주어진다면, 각 부서에서는 불필요가 정보가 포함되어 있어서 불편하다. 또한, 다른 부서에서는 보여서는 안될 정보가 함께 제공되는 문제가 발생할 수도 있다.이를 위해 데이터베이스 관리자는 사원 테이블을 제공하는 대신에, 각 부서의 필요에 맞는 뷰를 생성하여 제공할 수 있다. 사용자 입장에서 보면 뷰와 일반 테이블은 거의 구분이 되지 않는다.일반 테이블과 마찬가지로 뷰에 대해서도 질의가 가능하기 때문이다.일반 테이블과 뷰의 중요한 차이점은 일반 테이블이 실제로 물리적인 데이터를 갖고 있는 반면에 뷰는 물리적인 데이터를 갖지 않고, 뷰가 정의된 일반 테이블로부터 데이터를 가져와 보여준다는 것이다.따라서 뷰는 일반 테이블이 있어야 정의가 가능하다. Reference Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011 오세종, 『데이터베이스 설계 및 구축』, 생능출판사, 2013 “[관계형 데이터베이스]”, Untitled, 2019. 3. 7, https://untitledtblog.tistory.com/123","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"DataBase","slug":"Basic-CS/DataBase","permalink":"http://dudri63.github.io/categories/Basic-CS/DataBase/"}],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"http://dudri63.github.io/tags/DataBase/"}]},{"title":"[Algorithm] 클러스터링 문제 (근사)","slug":"algo39","date":"2019-02-08T03:12:17.000Z","updated":"2019-02-16T07:44:04.262Z","comments":true,"path":"2019/02/08/algo39/","link":"","permalink":"http://dudri63.github.io/2019/02/08/algo39/","excerpt":"","text":"1. 클러스터링 문제2. 알고리즘3. 시간복잡도4. 근사 비율 1. 클러스터링 문제 n개의 점이 2차원 평면에 주어질 때, 점들 간의 거리를 고려하여 k개의 그룹으로 나눈다.‘클러스터링(Clustering)’ 문제는 입력으로 주어진 n개의 점을 k개의 그룹으로 나누고, 각 그룹의 중심이 되는 k개의 점을 선택하는 문제이다.단, 가장 큰 반경을 가진 그룹의 직경이 최소가 되도록 k개의 점이 선택되어야 한다. n개의 점들 중에서 k개의 선택을 선택할 때, 하나씩 선택한다. 다음은 k개의 선택을 하는 예제이다. 첫 번째 센터가 랜덤하게 정해졌다고 가정한다.위 그림에서 두 번째 센터는 어떤 것이 더 적합한가?첫 번째 센터에서 가장 가까운 점, 가장 먼 점이 고려 대상이다.2개의 센터가 서로 가까이 있는 것보다 멀리 떨어져 있는 것이 좋다.세 번째 센터는 첫 번째와 두 번째 센터에서 가장 멀리 떨어진 점을 선택한다.**2. 알고리즘다음은 위 그림과 같이 센터를 정하는 방법에 기반을 둔 근사 알고리즘이다.Approx_k_Clusters입력: 2차 평면상의 n개의 점 xi, i=0,1,…,n-1, 그룹의 수 k&gt;1출력: k개의 클러스터 및 각 클러스터의 센터12345678910C[1]=r, 단, xr은 n개의 점 중에서 랜덤하게 선택된 점이다.for j = 2 to k &#123; for i = 0 to n-1 if (xi≠센터) xi와 각 센터까지의 거리를 계산, xi와 가장 가까운 센터까지의 거리를 D[i]에 저장 &#125; C[j]=i, 단, i는 배열 D의 가장 큰 원소의 인덱스, xi는 센터가 아니다.&#125;센터가 아닌 각 점 xi로부터 앞서 찾은 k개의 센터까지 거리를 각각 계산, 그 중에 가장 짧은 거리의 센터를 찾는다. 이 때 점 xi는 가장 가까운 센터의 클러스터에 속하게 된다return 배열 C와 각 클러스터에 속한 점들의 리스트(클러스터는 일종의 그룹이라고 생각하는 편이 좋을 거 같다.)다음 2차원 평면에 놓인 점들에 대하여 위 알고리즘을 적용한다. 위 그림에서 4개의 센터, 4개의 그룹으로 나눈다. line 1 : 임의의 점 하나를 첫 번째 센터 C1으로 정함line 2 : j=2, 2번째 센터를 찾는다.line 3~5 : C1을 제외한, 각 점 xi에서 C1 까지의 거리 D[i]를 계산 line 6 : C1으로부터 거리가 가장 먼 점을 다음 센터 C2로 정한다. line 2 : j=3, 3번째 센터를 찾는다. line 3~5 : C1, C2를 제외한, 각 점 xi에서 C1, C2 까지의 거리를 계산, 그 중 작은 값을 D[i]에 저장 D[1] = min{18,33} = 18D[2] = min{19,25} = 19D[3] = min{20,30} = 20D[4] = min{22,17} = 17…와 같이 배열 D에 값이 저장된다. line 6 : 배열 D에서 가장 큰 값을 가진 원소의 인덱스가 C3이 된다.즉, D[3]의 값이 가장 큼, C[3] = x3 line 2 : j=4, 4번째 센터를 찾는다.line 3~5 : C1, C2, C3를 제외한, 각 점 xi에서 C1, C2, C3까지의 거리를 계산, 그 중 작은 값을 D[i]에 저장 line 6 : 배열 D에서 가장 큰 값을 가진 원소의 인덱스가 C4가 된다. line 7 : 센터가 아닌 각 점 xi로부터 위에서 찾은 4개의 센터까지의 거리를 각각 계산, 그 중 가장 짧은 거리의 센터를 찾음각 점 xi는 가장 가까운 센터의 그룹에 속하게 된다. line 8 : 4개의 센터와 각 점이 속한 그룹의 센터를 리턴 3. 시간복잡도 line 1 : 임의의 점 선택, O(1) 시간line 3~5 : 각 점에서 각 센터까지의 거리를 계산, O(kn)line 6 : 그 중에서 최댓값을 찾음 O(n)그런데 line 2의 for-루프가 (k-1)회 반복, O(1)+(k-1)*(O(kn)+O(n))이다.line 7 : 각 점으로부터 k개의 센터까지의 거리를 각각 계산, 최솟값을 찾음. O(kn) 시간 소요.따라서 O(1)+(k-1)*(O(kn)+O(n))+O(kn)=O(k2n)이다. 4. 근사 비율 최적해가 만든 클러스터 중 가장 큰 직경을 OPT라고 한다.OPT의 하한을 간접적으로 찾기 위해서, Approx_K_Clusters 알고리즘이 k개의 센터를 모두 찾은 뒤 (k+1)번째 센터를 찾는 상황을 가정한다. C5에서 가장 가까운 센터인 C3까지의 거리를 d라고 한다.위 5개의 센터 점을 4개의 클러스터로 분할해야 한다.따라서 4개의 센터 중에서 2개는 하나의 클러스터에 속해야만 한다.위 그림에서는 C3, C5가 하나의 클러스터에 속한다.그러므로 최적해의 가장 큰 그룹의 직경인 OPT는 d보다 작을 수 없다. Approx_K_Clusters 알고리즘이 계산한 근사해의 가장 큰 그룹의 직경을 OPT’라고 한다.센터가 아닌 어떤 점 중에서 센터와의 거리가 d보다 큰 경우는 없다.따라서 각 클러스터의 중심으로 반경 d 이내에 클러스터에 속하는 모든 점들이 위치한다.OPT’&lt;=2d OPT &gt; d &gt;= OPT’/22OPT &gt; OPT’ 따라서 Apporx_k_Clusters의 알고리즘의 근사비율은 2를 넘지 않는다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Approximation","slug":"Approximation","permalink":"http://dudri63.github.io/tags/Approximation/"}]},{"title":"[Algorithm] 작업 스케줄링 문제 (근사)","slug":"algo38","date":"2019-02-08T02:11:04.000Z","updated":"2019-02-16T07:43:59.054Z","comments":true,"path":"2019/02/08/algo38/","link":"","permalink":"http://dudri63.github.io/2019/02/08/algo38/","excerpt":"","text":"1. 작업 스케줄링 문제2. 알고리즘3. 시간 복잡도4. 근사 비율 1. 작업 스케줄링 문제 ‘작업 스케줄링(Job Scheduling) 문제’는 n개의 작업, 각 작업의 수행 시간 ti, i = 1,2,3,…,n, 그리고 m개의 동일한 기계가 주어질 때, 모든 작업이 가장 빨리 종료되도록 작업을 기계에 배정하는 문제이다. 단, 한 작업은 배정된 기계에서 연속적으로 수행, 기계는 1번에 하나의 작업만을 수행한다. 작업 스케줄링 문제를 해결하기 위한 가장 간단한 방법은 그리디 알고리즘을 이용하는 것이다.즉, 배정된 작업이 가장 빨리 끝나는 기계에 새 작업을 배정하는 것이다. 2. 알고리즘 Approx_JobScheduling입력: n개의 작업, 각 작업 수행 시간 ti, i= 1,2,…,n, 기계 Mj, j = 1,2,…,m출력: 모든 작업이 종료된 시간12345678910111213for j = 1 to m // 초기화 L[j] = 0for i = 1 to n // n개의 작업을 배정 min = 1 for j = 2 to m &#123; if (L[j]&lt;L[min])&#123; min = j &#125; 작업 i를 기계 Mmin에 배정 L[min] = L[min] + ti &#125;&#125;return 가장 늦은 작업 종료 시간 작업의 수행시간이 각각 5, 2, 4, 3, 4, 7, 9, 2, 4, 1이고, 4개의 기계가 있을 때 위 알고리즘을 적용한 결과는 다음과 같다. 가장 늦게 끝나는 작업의 종료 시간인 13을 리턴한다. 3. 시간 복잡도 Approx_JobScheduling 알고리즘은 n개의 작업을 하나씩 가장 빨리 끝나는 기계에 배정한다.이러한 기계를 찾기 위해 for-루프가 (m-1)번 수행된다.따라서 O(m) 시간 동안 기계의 작업 종료 시간을 살핀다.또한, n개의 작업을 배정하고, 마지막 line 10에서 배열을 탐색한다.n*O(m) + O(m) = O(nm) 4. 근사 비율 Approx_JobScheduling 알고리즘의 근사해를 OPT’, 최적해를 OPT라고 한다.OPT’ &lt;= 2*OPT이다.왜냐하면 근사해는 최적해의 2배를 넘지 않는다.그 이유는 다음과 같다. 가장 마지막으로 배정된 작업 i가 T부터 수행, OPT’ = T + ti이다.또한, T’는 작업 i를 제외한 평균 종료 시간이다.따라서 T &lt;= T’이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Approximation","slug":"Approximation","permalink":"http://dudri63.github.io/tags/Approximation/"}]},{"title":"[Algorithm] 통 채우기 (근사)","slug":"algo37","date":"2019-02-08T01:22:16.000Z","updated":"2019-02-16T07:43:53.710Z","comments":true,"path":"2019/02/08/algo37/","link":"","permalink":"http://dudri63.github.io/2019/02/08/algo37/","excerpt":"","text":"1. 통 채우기 문제2. 알고리즘3. 시간 복잡도4. 근사 비율 1. 통 채우기 문제 ‘통 채우기(Bin Packing) 문제’는 n개의 물건이 주어지고, 통(bin)의 용량이 C일 때, 주어진 모든 물건을 가장 적은 수의 통에 채우는 문제이다. 단, 각 물건의 크기는 C보다 크지 않다. 이 문제에 대한 간단한 답은 그리디 알고리즘으로 해결하는 것이다.그리디 방법은 ‘무엇에 욕심을 낼 것인가’에 따라서 4종류로 분류할 수 있다. 최초 접합(First Fit) : 첫 번째 통부터 차례대로 살펴보며, 가장 여유가 있는 통에 새 물건을 넣는다. 다음 적합(Next Fit) : 직전에 물건을 넣은 통에 여유가 있으면 새 물건을 넣는다. 최선 적합(Best Fit) : 기존의 통 중에서 새 물건이 들어가면 남는 부분이 가장 적은 토에 새 물건을 넣는다. 최악 적합(Worst Fit) : 기존의 통 중에서 새 물건이 들어가면 남는 부분이 가장 큰 통에 새 물건을 넣는다. 각 방법으로 새 물건을 기존 통에 넣을 수 없으면, 새로운 통에 새 물건을 넣는다. 다음은 통의 용량 C=10, 물건의 크기가 각각 [7,5,6,4,2,3,7,5]일 때, 최초 적합, 다음 적합, 최선 적합, 최악 적합을 적용하였을 때의 결과이다. 처음 적합 다음 적합 최선 적합 최악 적합 최적 해 상기 4종류의 그리디 알고리즘 이외에도 최후 적합(Last Fit), 감소순 최초 적합(First Fit Decrease), 감소순 최선 적합(Best Fit Decrease) 등의 그리디 방법이 있다. 2. 알고리즘 다음은 각 그리디 방법에 대한 근사 알고리즘이다. Approx_BinPacking입력: n개의 물건의 각각의 크기출력: 모든 물건을 넣는 데 사용된 통의 수123456789B = 0 // 사용된 통의 수for i = 1 to n &#123; if (물건 i를 넣을 여유가 있는 기존의 통) 그리디 방법에 따라 정해진 통에 물건 i를 넣는다. else 새 통에 물건 i를 넣는다. B = B + 1 // 통의 수 1 증가&#125;return B 3. 시간 복잡도 새 물건을 넣을 때마다 기존의 통들을 살펴보아야 한다.이 경우, 통의 수가 n을 넘지 않으므로 수행시간은 O(n2)이다. 단, 다음 적합의 경우, 직전에 사용된 통만 살펴보기 때문에 O(n)이다. 4. 근사 비율 최초 적합, 최선 적합, 최악 적합 모든 물건을 넣는 데 사용된 통의 수는 최적 해에서 사용된 통의 수의 2배를 넘지 않는다.왜냐하면 2개 이상의 통이 1/2 이하로 차 있을 수 없기 때문이다.만일 2개의 통이 각각 1/2 이하로 차 있다면, 각 방법은 새 통을 사용하지 않고, 2개의 통에 있는 물건을 1통으로 합친다.최적해에서 사용된 통의 수를 OPT라고 하면, OPT &gt;= (모든 물건의 크기의 합)/C, C는 통의 크기.각 방법이 사용한 통의 수가 OPT’라면, 다음과 같은 부등식이 성립한다.(OPT’의 통 중 기껏해야 1개의 통이 1/2 이하로 차 있다. 또한, (OPT’-1)개의 통에 각각 1/2 넘게 물건을 채 울 때 그 물건의 크기의 합은 ((OPT’-1)*C/2보다 크다.) (모든 물건의 크기의 합) &gt; (OPT’-1)*C/2-&gt; (모든 물건의 크기의 합)/C &gt; (OPT’-1)/2-&gt; OPT &gt;= (모든 물건의 크기의 합)/C &gt; (OPT’-1)/2-&gt; OPT &gt; (OPT’-1)/2-&gt; 2OPT &gt; OPT’-1-&gt; 2OPT + 1 &gt; OPT’-&gt; 2OPT &gt;= OPT’ 따라서 이 때의 근사 비율은 2이다. 다음 적합 다음 적합은 직전에 사용된 통에 들어 있는 물건의 크기의 합과 새 물건의 크기의 합이 통의 용량보다 클 때만, 새 통에 새 물건을 넣는다.이웃한 두 통의 합은 한 통의 full 용량인 C를 반드시 넘는다.그러므로 다음과 같은 부등식이 성립한다. (모든 물건의 크기의 합) &gt; OPT’/2*C-&gt; (모든 물건의 크기의 합)/C &gt; OPT’/2-&gt; OPT &gt; OPT’/2-&gt; 2OPT &gt; OPT’ 따라서 다음 적합의 근사 비율은 2이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Approximation","slug":"Approximation","permalink":"http://dudri63.github.io/tags/Approximation/"}]},{"title":"[DataBase] ER model(Conceptual data model)","slug":"db4","date":"2019-02-04T08:37:45.000Z","updated":"2019-03-09T08:44:12.389Z","comments":true,"path":"2019/02/04/db4/","link":"","permalink":"http://dudri63.github.io/2019/02/04/db4/","excerpt":"","text":"1. ER model2. Entity, Attribute, Entity type3. Relationship, relationship type4. Weak entity type, Weak relationship type5. Higher-degree relationship 1. ER model ER model : Entity-Relationship data model high-levl(conceptual) data model 중 가장 대중적인 모델 구성요소 : Entity, Attribute, Relationship, Constraint ex. 회사의 ER data model 2. Entity, Attribute, Entity type Entity : 현실세계에서 독립적인 실체로 존재하는 것 Attribute : Entity를 묘사하는 특징들 동그라미로 표현 type composite or simple, composite은 하나의 동그라미에 또다른 동그라미가 달린 형태 single-valued of multivalued(이중타원) stored or derived(테우리가 점선) NULL values Complex attributes Entity type : 같은 attribute를 가지는 entity들의 집합 네모로 표현 보통 entity가 하나로만 구성된 entity type은 만들지 않는다.(예외는 있음) key attribute : entity type 내에 서로 다른 entity들을 구별할 수 있는 유일한 기준이 되는 attribute. ER model에서 밑줄을 그어 표기한다. 3. RelationShip, RelationShip type RelationShip 한 entity type의 attribute가 또다른 entity type을 언급할 때, relationship으로 참조를 나타낸다. 참조하는 attribute를 relationship type으로 변경한다. RleationShip type 마름모로 표현 degree : 참여하는 entity type의 갯수 entity type과 relationship type 사이에 role name 지정 가능. recursive relationship type은 반드시 role name을 지정해야 한다. ex. reculsive relationship type위 경우, SUPERVISION relationship type에 참여하는 entity가 오직 하나, employee인데, 스스로를 referencint하고 있다. 이 때 role name은 각각 Supervisor, Supervisee. Cardinality ratio constraint : entity가 참여할 수 있는 relationship instance의 최대갯수/ 1:1, 1:N, N:M Participation consraint(참여 제약) : total or partial total : 하나 이상의 개체가 참여, 2줄로 표기 partial : 선택적인 참여, 1줄로 표기 ex. 학생, 강의의 Cardinality ratio, 참여 제약학생은 꼭 수강할 필요가 없음 -&gt; partial과목은 항상 수강생이 있어야 함 -&gt; total한 학생은 여러개의 과목을 수강할 수 있음 -&gt; M한 과목을 수강하는 학생은 여러 명이 있을 수 있음 -&gt; N사원은 소속 부서가 있어야 함 -&gt; total사원이 없는 소속 부서는 없음 -&gt; total한 부서에는 여러 명의 사원이 있을 수 있음 -&gt; N한 사원은 오직 한 부서에만 소속됨 -&gt; 1 Attribute of relationship type relationship type에도 attribute가 있을 수 있음 1:1인 경우 어느 한 쪽의 entity type으로 이동할 수 있다. 1:N인 경우 N쪽의 entity type으로 이동할 수 있다. M:N인 경우 이동할 수 없다. 4. Weak Entity type, Weak RelationShip type Weak Entity type entity type의 특별한 한 종류 이중 사각형으로 표기 스스로 key attribute를 가지지 못한다. partial key : weak entity type의 key 점선 밑줄로 표기 부분키라고도 한다. 있을 수도 있고, 없을 수도 있다. 단독으로 존재할 수 없으며, 자신을 소유하고 있는 Owner entity tpye의 key와 합쳐서 entity를 구분할 수 있음 Weak Relationship type weak entity type이 onwer entity type과 연관될 때의 relationship type 이중 마름모로 표기 ex. 사원과 부양가족 관계DEPENDENT entity type은 스스로 내부 entity들을 구별할 수 없다.따라서 Owner entity type인 Employee의 Ssn key와 partial key인 Name을 합쳐서 key로 사용한다. 5. Higher-degree relationship 일부 데이터베이스 디자인 툴에서는 무조건 binary relationship types만을 허용한다. 이 경우, 하나의 relationship type에 세 개 이상의 entity type이 참여하지 못한다. higher-degree relationship은 툴에 따라 변경할 필요가 있다. 툴에 따라 변경할 필요가 있다. ex. tenary relationship type의 변경SUPPLY relationship type을 weak entity tpye으로 변경하였다. cf.개체-관계 모델링을 ERM(Entity-Relationship Modeling)이라고 한다.ERM 프로세스의 산출물은 ERD(개체-관계 다이어그램,Entity-Relationship Diagram)이라고 한다. 해당 포스트에서는 전통적인 다이그램 컨벤션을 이용하여 모델링하는 방법을 나타낸 것이다.크로우즈 풋/크로우즈 핏 노테이션 방법 또한 존재한다. Reference Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"DataBase","slug":"Basic-CS/DataBase","permalink":"http://dudri63.github.io/categories/Basic-CS/DataBase/"}],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"http://dudri63.github.io/tags/DataBase/"}]},{"title":"[DataBase] DB Design","slug":"db3","date":"2019-02-04T07:54:01.000Z","updated":"2019-02-16T07:44:41.666Z","comments":true,"path":"2019/02/04/db3/","link":"","permalink":"http://dudri63.github.io/2019/02/04/db3/","excerpt":"","text":"1. DB Design2. Procedure of DB Design 1. DB Design DB design 데이터베이스 스키마를 결정하는 것 다양한 디자인 방법론들이 존재한다. 본 포스팅에서는 여러 유저들과 애플리케이션에 의해 공유, 조직에 중요한 데이터베이스임을 가정한다. Information System 특정 기관을 위해 데이터를 수집, 조직하여 저장된 정보를 생성하고 분배하는 수단 DBS를 이용하기 위해 조직상황을 제공 DB designer는 제공받은 Information System을 이용하여 Design 오늘날 micro life cycle DB design 목표 한 개 또는 그 이상의 데이터베이스의 logical, physical design 현실 세계의 필요 사항을 정확하게 반영 정확한 평가가 어려움 정확도, 성능, 자연스러움 중요 DB design 절차 요구 수집, 분석 Conceptual DB design DBMS 선택 Logical design Physical design 시스템 구현 및 튜닝 2. Procedure of DB Design Phase 1 : 요구 수집, 분석 정보를 수집한 뒤 분석 요구되는 기술들을 학습 또는 분석 현재의 기능 환경을 이해 ex. 회사 DB design을 위한 요구 수집, 분석 Phase 2 : Conceptual DB design Conceptual 스키마 디자인 (ER dadta mdoel 등을 이용) 접근법 Centralized(one shot) schema design approach (good option) View integration approach (bad option) 전략 Top-dwon Bottom-up ex. 회사 DB design을 위한 Coceptual DB design Phase 3 : DBMS 선택 기술적, 경제적 문제를 고려하여 DBMS를 선택 DBMS마다 지원하는 데이터 타입이 다름, 하드웨어 타입에 따른 DBMS 이식성이 다름을 유의 Phase 4 : Logical design data moel mapping (conceptual data model -&gt; representaion data model) ex. 회사 DB design을 위한 Logical design Phase 5 : Physical design 특정 파일 구조, 데이터베이스 access path를 선정 response time, space utilization, transaction throughput 등이 고려됨 이 과정은 DBMS에 의해 결정됨 Phase 6 : 시스템 구현 및 튜닝 Reference Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"DataBase","slug":"Basic-CS/DataBase","permalink":"http://dudri63.github.io/categories/Basic-CS/DataBase/"}],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"http://dudri63.github.io/tags/DataBase/"}]},{"title":"[Algorithm] 정점 커버 문제 (근사)","slug":"algo36","date":"2019-02-04T06:48:29.000Z","updated":"2019-02-16T07:43:47.170Z","comments":true,"path":"2019/02/04/algo36/","link":"","permalink":"http://dudri63.github.io/2019/02/04/algo36/","excerpt":"","text":"1. 정점 커버 문제2. 알고리즘3. 시간 복잡도4. 근사 비율 1. 정점 커버 문제 ‘정점 커버(Vertex Cover)’ 문제는 주어진 그래프 G=(V,E)에서 각 선분의 양 끝점들 중에서 적어도 하나의 끝점을 포함하는 점들의 집합들 중에서 최소 크기의 집합을 찾는 문제이다.정점 커버를 살펴보면, 그래프의 모든 선분이 정점 커버에 속한 점에 인접해 있다.즉 정점 커버는 점들의 집합인데, 그래프의 모든 선분들이 집합내 점들 중 어느 하나라도 연결이 되있어야 한다. 구체적인 예는 다음과 같다. 그래프 G에서 정점 커버는 다음과 같다.{1,2,3}, {1,2}, {1,3}, {2,3}, {1}{2}, {3}은 정점 커버가 아니다. 왜냐하면 선분(1,3)과 선분(1,2)를 각각 커버하지 못하기 때문이다.정점 커버 문제는 최소 크기의 집합을 찾는 것이므로 해는 {1}이다. 주어진 그래프의 모든 선분을 커버하려면 일단 어떤 점을 선택해야 하는지 고려해야 한다.우선 차수(degree)가 높은 점을 우선 선택하면 많은 수의 선분이 커버될 수 있다.이 전략은 ‘집합 커버문제’의 근사 알고리즘에서 사용된 것이다. 이 때의 근사 비율은 logn이다. 또 다른 방법은 점을 선택하는 대신에 선분을 선택하는 것이다.선분을 선택하면 선택된 선분의 양 끝점에 인접한 선분이 모두 커버된다.이 때 정점 커버는 선택된 각 선분의 양 끝점들로 이루어진 집합이다. 본 포스팅에서는 후자의 방법을 선택하여 정점 커버 문제를 해결한다. 정점 커버를 만들어가는 과정에서, 새로운 선분은 자신의 양 끝점들이 이미 선택된 선분의 양 끝점들의 집합에 포함되지 않을 때에만 중복을 피하기 위해 선택된다. 예를 들어, 위 G 그래프에서 1개의 선분이 임의로 선택되었을 때, 선택된 선분 주변의 6개의 선분(점선으로 표시된 선분)은 정점 커버를 위한 선분으로서 선택되지 않는다. 왜냐하면 이미 선택된 선분(파란색 선분)의 양끝점(파란색 점)들이 점선으로 표시된 선분을 모두 커버하기 때문이다.이러한 방식으로 선분을 선택하다가 더 이상 선분을 추가할 수 없을 때 중단한다.이렇게 선택된 선분의 집합을 ‘극대 매칭(Maximal Matching)’이라고 한다.매칭(matching)이란 각 선분의 양 끝점들이 중복되지 않는 선분의 집합이다.극대 매칭은 이미 선택된 서분에 기반을 두고 새로운 선분을 추가하려 해도 더 이상 추가할 수 없는 매칭이다.**2. 알고리즘다음은 극대 매칭을 이용한 정점 커버를 위한 근사 알고리즘이다.Approx_Matching_VC입력: 그래프 G=(V,E)출력: 정점 커버12입력 그래프에서 극대 매칭 M을 찾는다.return 매칭 M의 선부의 양 끝점들의 집합 위 그림에서는 극대 매칭으로서 선분 a, b, c, d, e, f가 선택되었다.근사해는 선분 a, b, c, d, e, f의 양 끝점들의 집합이다.이 경우 12개의 점이다.오른쪽 그래프는 최적해로서 7개의 점으로 구성되어 있다. 3. 시간 복잡도 Approx_Matching_VC 알고리즘의 시간복잡도는 주어진 그래프에서 극대 매칭을 찾는 과정의 시간복잡도와 같다.극대 매칭을 찾기 위해 하나의 선분 e를 선택한 후 e의 양 끝점들 중 적어도 하나가 이미 선택된 선분의 끝점이라면 e를 그래프에서 제거, 그렇지 않으면 e를 매칭에 추가한다.이 후 e의 양 끝점에 인접한 모든 선분들을 그래프에서 제거해야 한다.따라서 O(n) 시간이 걸린다.입력 그래프의 선분수가 m이면, 각 선분에 대해서 O(n) 시간이 걸리므로, Approx_Matching_VC 알고리즘의 시간복잡도는 O(n)*m = O(nm))이다. 4. 근사 비율 Approx_Matching_VC 알고리즘의 근사 비율을 계산하기 위해 극대 매칭을 ‘간접적인’ 최적해로 사용한다. Approx_Matching_VC 알고리즘은 극대 매칭의 각 선분의 양 끝점들의 집합을 정점 커버의 근사해로서 리턴, 근사해의 값은 극대 매칭의 선분 수의 2배이다.(극대 매칭의 선분의 양 끝점들의 수) / (극대 매칭의 선분 수) = 2 Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Approximation","slug":"Approximation","permalink":"http://dudri63.github.io/tags/Approximation/"}]},{"title":"[Algorithm] 여행자 문제 (근사)","slug":"algo35","date":"2019-02-04T05:52:34.000Z","updated":"2019-02-16T07:43:41.190Z","comments":true,"path":"2019/02/04/algo35/","link":"","permalink":"http://dudri63.github.io/2019/02/04/algo35/","excerpt":"","text":"1. 여행자 문제2. 알고리즘3. 시간 복잡도4. 근사 비율 1. 여행자 문제 ‘여행자 문제(Traveling Salesman Problem, TSP)’는 여행자가 임의의 한 도시에서 출발하여 다른 모든 도시를 1회씩만 방문하고 다시 출발했던 도시로 돌아오는 여행 경로의 거리를 최소하하는 문제이다.여기서 다루는 여행자 문제의 조건은 다음과 같다. 도시 A에서 도시 B로 가는 거리 = 도시 B에서 도시 A로 가는 거리 (대칭성) 도시 A에서 도시 B로 가는 거리 &lt; 도시 A에서 도시 C를 경유하여 도시 B로 가는 거리 (삼각 부등식 특성) TSP를 위한 근사 알고리즘을 고안하려면, 먼저 다항식 시간 알고리즘을 가지면서 유사한 특성을 가진 문제를 찾아서 활용해보는 것이 좋다.이전에 다룬 ‘최소 신장 트리 문제(MST)’가 TSP와 유사한 특정을 가진다.최소 신장 트리는 모든 점을 사이클 없이 연결하는 트리 중에서 트리 선분의 가중치의 합이 최소인 트리이다.따라서 모든 점을 연결하고, 선분의 가중치의 합이 최소인 최소 신장 트리의 특서을 응용, 시작도시를 제외한 다른 모든 도시를 트리 선분을 따라 1번씩 방문하도록 경로를 찾는다. 이러한 과정을 아래의 그림을 이용하여 이해할 수 있다. 그래프 G에서 크러스컬 또는 프림 알고리즘을 이용하여 최소 신장 트리를 찾는다.임의의 도시(그림에서는 1번)에서 출발하여 트리의 선분을 따라서 모든 도시를 방문하고 돌아오는 도시의 방문 순서를 구한다.[1 2 4 3 4 5 4 6 7 6 4 2 1]마지막으로 이 순서를 따라서 도시를 방문하되 중복 방문하는 도시를 순서에서 제거, 여행자 문제의 근사해를 구한다.단, 출발 도시와 도착 도시는 같으므로 중복을 허용한다.[1 2 4 3 5 6 7 1] 중복하여 방문하는 도시를 제거하는 과정이 삼각형 부등식 원리가 적용된다. 2. 알고리즘 다음은 최소 신장 트리에 기반한 여행자 문제의 근사 알고리즘이다. Approx_MST_TSP입력: n개의 도시, 각 도시 간의 거리출력: 출발 도시에서 각 도시를 1번씩만 방문, 출발 도시로 돌아오는 도시 순서123입력에 대해서 최소 신장 트리를 찾는다.최소 신장 트리에서 임의의 도시로부터 출발하여 트리의 선분을 따라서 모든 도시를 방문하고 다시 출발했던 도시로 돌아오는 도시 방문 순서를 찾는다.return 이전 단계에서 찾은 도시 순서에서 중복되어 나타는 도시레르 제거한 도시 순서 3. 시간복잡도 line 1 : 최소 신장 트리를 찾음. 크러스컬이나 프림 알고리즘의 시간 복잡도line 2 : 트리 선분을 따라서 도시 방문 순서를 찾는데 O(n) 시간이 걸림. 왜냐하면 트리의 선분 수가 (n-1)이기 때문이다.(추후 논의 필요)line 3 : line 2에서 찾은 도시 방문 순서를 따라가며, 중복된 도시를 제거 O(n) 시간. 따라서 크러스컬이나 프림 알고리즘의 시간복잡도와 같다. 4. 근사비율 여행자 문제의 최적해를 실질적으로 알 수는 없다.‘간접적인’ 최적해인 최소 신장 트리 선분의 가중치의 합(M)을 최적해의 값으로 활용한다.실제의 최적해의 값은 M보다 항상 크다. line 2 : 최소 신장 트리의 선분을 따라서 도시 방문 순서를 찾을 때 각 선분이 2번 사용된다. 경로의 총 길이는 2Mline 3 : 삼각 부등식의 원리 이용, 새로운 도시 방문 순서를 만듬. 경로의 길이가 짧아짐 알고리즘의 근사비율은 2M/M=2보다 크지 않다.즉, 근사해의 값이 최적해의 값의 2배를 넘지 않는다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Approximation","slug":"Approximation","permalink":"http://dudri63.github.io/tags/Approximation/"}]},{"title":"[Algorithm] 근사 알고리즘","slug":"algo34","date":"2019-02-04T05:45:02.000Z","updated":"2019-02-16T07:43:35.450Z","comments":true,"path":"2019/02/04/algo34/","link":"","permalink":"http://dudri63.github.io/2019/02/04/algo34/","excerpt":"","text":"NP-완전 문제들은 실생활의 광범위한 영역에 활용되지만, 불행히도 이 문제들을 다항식 시간에 해결할 수 있는 알고리즘이 아직 발견되지 않았다.또한 그렇다고 해서 이 문제들을 다항식 시간에 해결할 수 없다고 증명이 되지도 않았다.그러나 대부분의 학자들은 다항식 시간 알고리즘으로 NP-완전 문제를 해결할 수 없을 것이라고 생각한다.NP-완전 문제들을 해결하려면 보통 다음의 세 가지 중 하나를 포기한다. 다항식 시간에 해를 찾는 것 모든 입력에 대해 해를 찾는 것 최적 해를 찾는 것 ‘근사(Approximation) 알고리즘’은 세 번째 것을 포기한다.즉, 최적해에 근사한 해를 찾는 대신 다항식 시간의 복잡도를 가진다.그러나 근사 알고리즘은 최적해를 구하는 것이 아니기 때문에 근사해가 최적해에 얼마나 근사한 것인지를 나타내는 근사 비율(Approximaton ratio)을 알고리즘과 함께 제시하여야 한다. 근사 비율은 근사해의 값과 최적해의 값의 비율로서, 1.0에 가까울수록 정확도가 높은 것이 된다.그런데 근사 비율을 계산하려면 최적해를 알아야 하는 모순이 또한 발생한다.따라서 최적해를 대신할 수 있는 간접적인 최적해를 찾고, 이를 최적해로 삼아서 근사 비율을 계산한다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Approximation","slug":"Approximation","permalink":"http://dudri63.github.io/tags/Approximation/"}]},{"title":"[Algorithm] 계산 복잡도 이론","slug":"algo33","date":"2019-02-04T04:26:34.000Z","updated":"2019-02-16T07:43:29.702Z","comments":true,"path":"2019/02/04/algo33/","link":"","permalink":"http://dudri63.github.io/2019/02/04/algo33/","excerpt":"","text":"1. 쉬운 문제, 어려운 문제2. P 문제, NP 문제3. NP 알고리즘4. 문제의 환원5. NP-하드 문제, NP-완전 문제 1. 쉬운 문제, 어려운 문제 컴퓨터를 사용하여 특정한 계산 문제를 풀기 위해서는, 그 문제에 해당되는 알고리즘을 컴퓨터에게 알려주어야 한다.이 때, 컴퓨터공학자들의 주된 관심사는 그 알고리즘이 문제를 얼마나 빨리 해결할 수 있느냐이다.그리하여 알고리즘의 시간복잡도라는 개념이 출현하였고, 시간복잡도에 따라 알고리즘을 분류할 수 있다. 쉬운(tractable) 문제 : 다항식 시간복잡도를 가진 알고리즘으로 해결 가능 어려운(intractable) 문제 : 다항식보다 큰 시간복잡도를 가진 알고리즘으로 해결 만약 어떤 알고리즘이 개발되었다고 하더라도, 그 알고리즘이 다항식 시간에 동작하지 않는다면 어려운 문제라고 간주한다.왜냐하면 다항식 시간에 동작하지 않는다는 것은 너무나도 비효율적인 알고리즘이기 때문이다.예를 들어 O(25n)의 시간복잡도를 갖는 알고리즘은 n이 커지면, 사실상 해결하기가 어렵다.그리하여 다항식보다 큰 시간복잡도를 갖는다면, 우주가 온 힘을 모아도 풀기 어렵다.물론, 다행히도 수학,과학적으로 중요한 많은 문제들이 다항식 시간 알고리즘을 갖는다. 2. P문제, NP 문제 답이 yes or no로 반환되는 문제를 ‘결정(decsion) 문제’라고 한다.예를 들어, 다음과 같은 질문은 결정 문제라고 한다. 각 도시를 1번씩만 방문하고 시작도시로 돌아오는 경로의 거리가 K보다 짧은 경로가 있는가? P 문제와 NP 문제는 모두 위와 같은 결정 문제의 분류에 해당한다.P문제와 NP 문제에 대한 개념은 다음과 같다. P 문제 : 결정 문제들 중에서 쉽게 풀리는 것들을 모아놓은 집합(Polynomial) NP 문제 : 결정 문제들 중에서 적어도 검산은 쉽게 할 수 있는 것들을 모아놓은 집합(Non-deterministic Polynomial) 어떤 결정 문제가 주어졌을 때, 다항식 시간 이내에 그 문제의 답을 yes or no로 계산해낼 수 있는 알고리즘이 존재한다면, 그 문제는 P문제이다.이에 반해, 어떤 결정 문제의 답이 yes일 때, 그 문제의 답이 yes라는 것을 입증하는 힌트가 주어지면, 그 힌트를 사용해서 문제의 답이 정말로 yes라는 것을 다항식 시간 이내에 확인할 수 있는 문제가 NP문제이다. 예를 들어, {-5,6,1,2,-10,-7,13}과 같이 정수로 이루어진 집합과 다음과 같은 결정 문제가 주어진 상황을 가정한다. ‘이 집합의 부분집합들 중에서 원소의 합이 0이 되는 집합이 존재하는가?’ 위 문제는 아직까지 다항식 시간 알고리즘이 알려져 있지 않다.단순하게 생각해도, 모든 경우의 부분집합을 테스트하지 않는 이상 yes or no로 답하기가 어렵다.그런데, 누군가가 {6,1,-7}이라는 힌트를 제공하면,힌트가 주어진 집합의 부분집합이라는 것을 확인,부분집합의 원소들의 합이 0이라는 것을 확인함으로써,원래 문제의 답을 yes로 답할 수 있게 된다.따라서 위 문제는 NP 문제인 것을 확실시할 수 있다. 만약 어떤 P 문제가 주어지고, 그 문제의 답이 YES라고 하면, 그 문제의 답에 관한 힌트를 받더라도 그냥 무시, 곧바로 그 문제의 답이 YES라는 것을 쉽게 확인할 수 있을 것이다.따라서 모든 P문제는 저절로 NP 문제도 된다.즉, P⊂NP이다. 하지만 그 반대인 NP⊂P에 대해서는 참인지 거짓인지 아직 알려지지 않았다.만약 모든 NP 문제가 P 문제인 경우, 즉, 모든 NP 문제가 다항 시간에 풀 수 있는 알고리즘이 존재함을 증명할 경우, P=NP문제라는 결론이 된다.이는 밀레니엄 문제 중 하나로서, 100만 달러가 걸린 문제이지만 아직 풀리지가 않았다.많은 컴퓨터공학자들은 P=NP일리가 없다고 믿고 있지만, 올바른 증명을 아직 찾아내지 못하였다. 3. NP 알고리즘 NP 알고리즘의 정의는 다음과 같다. NP 알고리즘은 첫 번째 단계에서 주어진 입력에 대해서 하나의 해를 ‘추측’하고, 두 번째 단계에서 그 해를 다항식 시간에 확인, 그 해가 ‘맞다’라고 답한다.즉 해가 맞는지 아닌지를 다항시간 내에 판별할 수 있다. NP 알고리즘은 해를 찾는 알고리즘이 아니라, 해를 다항식 시간에 확인하는 알고리즘이다. P 문제가 NP 문제에 속하는 이유는 NP 알고리즘을 이용하여 설명할 수도 있다.일단, P 문제를 해결한 데 다항식 시간이 걸리는 것은 자명하다.그리고 P 문제를 위한 NP 알고리즘은 해를 추측하는 단계(1)를 생략,해를 확인하는 단계 대신에 해를 직접 다항식 시간에 구하고,확인 결과를 ‘맞다’라고 하면 되기 때문이다. 다음은 NP 알고리즘을 적용하는 예이다.주어진 문제는 다음과 같다. 각 도시를 한 번씩만 방문하고 시작도시로 돌아오는 경로 중 가장 짧은 경로는 무엇인가? 위 문제는 일단 결정 문제가 아니기 때문에 결정 문제로 변형하여야 한다.변형한 문제는 다음과 같다. 각 도시를 한 번씩만 방문하고 시작도시로 돌아오는 경로의 거리가 K보다 짧은 경로가 있는가? 문제의 답은 그러한 경로가 있으면 ‘yes’, 없으면 ‘no’가 된다.8개 도시(A B C D E F G H)에 대한 여행자 문제의 NP-알고리즘은 다음과 같다.단, A가 시작도시이다. 하나의 해를 추측한다. A G D H F E B C를 추측했다고 가정한다. 추측한 해의 값을 계산한다. 해의 값 = (A~G) + (G~D) + … + (B~C) 해의 값이 K보다 작으면 ‘맞다’라고 대답한다. 두 번째 단계에서 계산에 소요되는 시간은 선형 시간임을 알 수 있다.8개 도시 간 거리를 합하는 데 걸리는 시간은 8번의 덧셈 연산, 계산된 해의 값과 K를 비교하는 데 1번의 비교 연산이 걸리기 때문이다. 4. 문제의 환원 문제 A를 해결하기 위해서 문제 B를 해결하는 알고리즘을 이용하려는 경우를 가정한다.이를 위해, 문제 A의 입력을 문제 B의 입력 형태로 변환시키는 것은 문제의 환원(변환)이라고 한다.변환된 입력으로 문제 B를 해결하는 알고리즘을 수행 가능하고, 또한, 수행 결과로서 나온 해를 문제 A의 해로 변환하여 문제 A를 해결할 수 있다. 이에 대한 예제는 다음과 같다.문제 A는 부분 집합의 합을 구하는 문제,문제 B는 동일한 크기로 분할하는 문제이다. 부분 집합의 합 문제: 정수들의 집합 S에 대하여 S의 부분 집합들 중에서 원소의 합이 K가 되는 부분 집합을 찾는 문제 분할 문제 : 정수들의 집합 S에 대하여 S를 분할, 원소들의 합이 같은 2개의 부분 집합을 찾는 문제예를 들어, S={20, 35, 45, 70, 80}이 주어지면, X={20,35,70}, Y={45,80}이 해이다. ‘부분 집합의 합 문제’의 입력인 집합 S를 ‘분할 문제’의 입력으로 변환할 때 t를 집합 S에 추가한다.단, t = s-2K(s는 집합 S의 모든 원소의 합) ‘부분 집합의 합 문제’를 해결하기 위해, 집합 S’= S∪{t}를 입력으로 하는 ‘분할 문제’를 위한 알고리즘을 이용한다.‘분할 문제’의 경우, 알고리즘의 해인 2개의 집합 X, Y는 각 집합에 속한 원소의 합(s-K)이 같다.왜냐하면 집합 S’의 모든 원소의 합은 s+t = s+(s-2K) = 2s-2k이기 때문이다. ‘분할 문제’의 해인 X와 Y 중에서 t를 가진 집합에서 t를 제거한 집합이 ‘부분 집합의 합 문제’의 해가 된다.왜냐하면 만일 X에 t가 속해 있었다면, X에서 t를 제외한 원소의 합 (s-K)-t = (s-K)-(s-2K) = s-K-s+2K = K가 되기 때문이다.그러므로 ‘부분 집합의 합 문제’의 해는 X-{t}이다. 위 경우의 시간복잡도는 다음의 3단계 시간복잡도의 합이다. 문제 A의 입력을 문제 B의 입력으로 변환하는 시간 문제 B를 위한 알고리즘이 수행되는 시간 문제 B의 해를 문제 A의 해로 변환하는 시간 위에서 첫 단계, 세 번째 단계는 단순한 입출력 변환, 다항식 시간에 수행된다.따라서 문제 변환의 시간복잡도는 두 번째 시간복잡도에 따라 결정된다.두 번째 단계가 다항식 시간이 걸리면, 문제 A도 다항식 시간에 해결된다. 5. NP-하드 문제, NP-완전 문제 문제 A와 문제 B 사이에 이러한 관계가 성립하면, 문제 A가 문제 B로 다항식 시간에 변환(polynomial time reduction) 가능하다고 한다. 어느 문제 A에 대해서, 만일 모든 NP 문제가 문제 A로 다항식 변환이 가능하다면, 문제 A는 NP-하드(NP-난해) 문제이다. 간단하게, NP-하드 문제는 위 여행자 문제나 부분집합의 합 문제와 같이 모든 경우의 수를 전부 확인해보는 방법 이외에는 정확한 답을 구할 수 있는 뾰족한 수가 없는 문제들을 뜻하기도 한다. NP-완전 문제에 대한 정의는 다음과 같다. 문제 A가 NP-완전 문제가 되려면, 문제 A는 NP문제이고, 동시에 문제 A는 NP-하드 문제이다. 만약 NP-완전 문제가 P문제라면, ‘모든 NP 문제가 P 문제’라는 것이 증명된다.만약 이것이 증면되면 그 동안의 알고리즘에 대한 연구가 완전히 바뀌게 된다. Reference ‘P-NP 문제’, 나무위키, 2019. 2. 10, https://namu.wiki/w/P-NP%20%EB%AC%B8%EC%A0%9C","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"NP-완전","slug":"NP-완전","permalink":"http://dudri63.github.io/tags/NP-완전/"}]},{"title":"[DataBase] 데이터 모델, DBMS 구조","slug":"db2","date":"2019-02-03T10:23:36.000Z","updated":"2019-02-16T07:44:35.262Z","comments":true,"path":"2019/02/03/db2/","link":"","permalink":"http://dudri63.github.io/2019/02/03/db2/","excerpt":"","text":"1. Data Abstraction2. Data model3. Data Schema, Instance4. 3-level arcitecture, Data independence5. DB language 1. Data Abstraction 데이터 추상화 현실세계의 사물을 개념화, 단순화하고 데이터적인 측면과 기능적인 측면으로 분리 정의 데이터에 대한 조작을 효과적으로 수행할 수 있는 수단을 제공해주는 작업 또는 기능 데이터 필수 특징 강조 프로그램-데이터 독립 허가 DBMS가 제공하는 기능 2. Data model 데이터 모델 데이터베이스의 구조를 묘사하는 개념들의 집합 데이터 추상화가 그 목적 데이터 구조를 결정 연산에 대한 내용도 포함 데이터 모델 목록 High-level (Conceptual Data model) E-R data moel (Entity-Relationship)이 가장 대중적이다. E-R data model : Entity - 현실 세계의 개념이나 사물, Attribute - entitiy의 속성,성질, Relationship - 둘 이상의 entity간의 관계 Low-level (Pyhsical Data Model) data가 어떻게 file로서 저장되는 지를 묘사한다.(데이터 저장 방법) 포맷, 순서, 접근 경로 등을 기술 Representation data model Relational data moel 이 가장 대중적이다. Relational data moel : 대부분의 DBMS에서 사용, 모든 정보를 ‘표’로 표현 hierarchical data moel, network data model 등도 있다. Object-oriented data model conceptual data model에 가까운 새로운 data model 객체 지향 특성을 가진다. 3. Database Schema, Instance 데이터베이스 스키마 데이터베이스의 묘사(meta db에 포함되어 있음) 데이터베이스의 구조, 데이터 타입, 제약 조건 등을 포함 데이터베이스 카탈로그에 저장된다.(meta db는 catalog 형태로 저장됨) DDL을 이용하여 DB designer가 변경 자주 변경되지 않는 편이 좋다. 데이터베이스 인스턴스 특정 순간에 데이터베이스에 있는 데이터들 DML의 update 기능에 의해 자주 변경됨 현실 세계의 변화 반영이 필수적이다. = database state, snapshot 4. 3-level architecture, Data Independence 3-level architecture DBMS의 특징을 지원하게 위해 고안되었다. 프로그램과 데이터 격리 데이터의 다중뷰 지원 데이터를 3단계(internal level, conceptual level, external level)로 관리 이 때 관리를 받는다는 것은 DBMS에 의한 것이다. Internal level : 데이터베이스의 물리적인 저장소 구조를 묘사 Conceptual level : 유저들을 위한 전체 데이터베이스 구조를 묘사 External level : 특정 그룹의 유저들이 관심있는 데이터베이스의 일부분을 묘사 데이터 독립성 Data Independence 3-level arichitecture에 의해 상위 level에 영향을 주지 않고, 해당 level이 바뀔 수 있는 것 Logical data independece : conceptual level의 변화가 external level에 영향을 주지 않음 Physical data independence : physical levle의 변화가 conceptual level에 영향을 주지 않음 cf. Data model : DB Designer에게 필요한 내용, 3-level arichitecture : DBMS에게 필요한 내용 5. DB language DDL (Data Definition Language) Schema를 정의(define)하기 위해 이용된다. 주로 DB designer에 의해 이용 DML (Data Manipulation Language) DB로의 검색, 삽입, 삭제, 업데이트 등을 가능하게 한다. DML Commands는 host language에 내장 가능 Application programmer에 의해 주로 이용된다. Reference Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"DataBase","slug":"Basic-CS/DataBase","permalink":"http://dudri63.github.io/categories/Basic-CS/DataBase/"}],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"http://dudri63.github.io/tags/DataBase/"}]},{"title":"[DataBase] DBS, DB, DBMS, 이용자, DB approach","slug":"db1","date":"2019-02-03T07:19:25.000Z","updated":"2019-03-06T12:59:21.314Z","comments":true,"path":"2019/02/03/db1/","link":"","permalink":"http://dudri63.github.io/2019/02/03/db1/","excerpt":"","text":"1. Database System2. Database3. DBMS4. Database Users5. DB Approach 1. Database System DBS(데이터베이스 시스템) : 자료를 데이터베이스에 저장, 관리하며 필요한 정보를 제공하는 컴퓨터 기반 시스템이다. DBS 구성요소 : Database (DB) Database management system (DBMS) Database users 2. Database 데이터베이스 상호 관련있는 데이터들의 집합 데이터란 의미가 있고, 저장할 수 있는 것이다. 현실 세계의 정보들을 나타낸다. 특정한 목적을 위하여 설계된다. 현실 세계의 정보인 sotred data와 stored data를 위한 데이터인 meta data가 저장된다. 데이터베이스의 예 : University database Company database 3. DBMS DBMS (Database Management System) 데이터베이스를 관리하는 프로그램 데이터베이스 이용자(user)와 데이터베이스간의 Interface DBMS를 이용하여 이용자는 쉽게 데이터베이스를 생성 및 유지할 수 있다. DBMS의 주요 기능 정의 : 데이터에 대한 형식, 구조, 제약조건들을 명세 이 때, 데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.(meta data) 구축 : DBMS가 관리하는 기억 장치에 데이터를 저장 조작 : 특정한 데이터를 검색하기 위한 질의, 데이터 갱신, 보고서 생성 기능 등 공유 : 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능 보호 : 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호 유지보수 : 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능 4. Database Users End Users : application programmer에 의해 개발된 application program을 통해 database에 접근하는 사람들 Application Programmers : 애플리케이션 개발자 시스템 분석에 관한 지식, host language(ex. JSP, ASP)를 알고 있어야 한다. SQL의 DML(Data Manipulation Language)을 알아야 한다. Database designers database를 설계하기 위한 현실 세계의 요구사항들을 파악한다. 저장될 데이터, 적절한 구조를 선정 SQL의 DDL(Data definition Language)을 알아야 한다. DBA (Database Administrators) 데이터베이스 접근 권한을 설정한다. 데이터베이스 운영, 관리를 책임진다. 5. DB Approach 파일 시스템 : 파일에 기초하여 자료나 정보를 처리하는 시스템 개별 응용 프로그램이 직접 파일에 접근, 기록, 갱신, 삭제한다. 파일에 있는 데이터의 올바른 관리여부는 전적으로 응용프로그램에 달림. 데이터 종속성 ex. 만약 파일에 있는 데이터 필드 중 하나의 길이가 변경됨. 그렇다면, 해당 파일을 읽어서 처리하는 모든 응용프로그램을 변경해야 하는 문제가 생긴다. 즉, 프로그램이 데이터에 종속되어 있다. 데이터 무결성 침해 ‘데이터 무결성’이란, 저장된 데이터의 내용이 본래 의도했던 데이터의 형식, 범위를 준수해야 함을 의미한다. ex. ‘나이’ 데이터필드는 양수여야 한다. 파일 시스템은 이러한 데이터 무결성을 지켜야할 책임이 프로그래머에게 있다. 만약 응용 프로그램이 올바르지 않는 데이터가 저장되는 것을 허용하게 된다면, 저장된 데이터에 근거해서 어떤 판단을 내려야 하는 경우 문제가 발생하게 된다. 데이터 중복성 데이터 불일치 중복 저장된 데이터들이 서로 일치하지 않는 경우 데이터 표준화의 어려움 데이터 보안성의 결어 데이터가 저장되어 있는 파일은 text를 비롯한 잘 알려진 형식으로 저장되기 때문에 응용 프로그램이 없어도 쉽게 파일을 열어 볼 수 있다. DB Approach data를 유지하는 저장소는 한 개 있다.(여러 저장소를 사용하지 않는다.) 저장소는 다양한 유저들에 의해 접근될 수 있다. DB Approach 특징 자기기술성(Self-describing nature of a database system) 프로그램과 데이터 격리(Insulation between programs and data) 데이터 추상화(Data abstraction) 데이터의 다중뷰(multiple view) 지원 data 공유 &amp; 멀티유저(multi user) 자기기술성 데이터베이스 시스템은 데이터베이스에 포함된 데이터 + 설명(meta) 파일 시스템과 구별되는 특징 데이터베이스 카탈로그(meta database)는 stored database와 같은 방식으로 접근할 수 있다. DBMS가 데이터의 삽입 및 삭제를 데이터/구조적 종속 없이 가능하게 해준다. 프로그램과 데이터 격리 단일한 응용 프로그램 내에서 데이터를 개별적으로 관리하는 방식은 데이터 구조 등이 변경되면 응용 프로그램도 수정되어야 한다. 하지만 데이터베이스는 저장 구조 등을 수정하는 것이 응용 프로그램에 영향을 미치지 않는다. 데이터 추상화 복잡한 데이터베이스의 구조에 대한 정보를 감추고, 각 사용자에게는 ‘뷰’를 제공한다. 실제로는 복잡한 구조지만 상부 이용자에게는 간단하게 보이도록 한다. 데이터 다중뷰 지원 뷰 : 데이터베이스의 subset 이용자마다 다른 목적을 커버 가능하다. 각 이용자에게 필요한 것만 보이게 함으로써 보안성을 높일 수 있다. 처리 시간이 걸린 다는 단점이 있다. data 공유 &amp; 멀티유저(multi user) DBMS는 다수 유저의 동시 접근을 허가한다. ‘동시성 제어’ cf. 데이터베이스의 추가적인 특징 데이터베이스는 동일한 내용의 데이터가 중복되어 있지 않아야 하고, 다양한 접근 방식이 마련되어 있어야 하며, 검색이나 갱신이 효율적으로 이루어질 수 있도록 해야 한다. RAM, ROM 같은 주기억장치가 아닌 컴퓨터에서 사용할 수 있는 보조기억장치에 저장된다. cf. 파일 시스템 DB Approach의 장점 중복 최소화 권한 없는 접근 제한 storage stucture 제공 및 효율적인 검색 프로세싱 가능(Indexes, Buffering, Caching, etc.) Backup, Recovery 다양한 이용자 interface를 제공 Reference Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011 데이터베이스, 위키피디아, 2019. 2. 3, https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C 데이터베이스, 나무위키, 2019. 2. 3, https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2","categories":[{"name":"Basic CS","slug":"Basic-CS","permalink":"http://dudri63.github.io/categories/Basic-CS/"},{"name":"DataBase","slug":"Basic-CS/DataBase","permalink":"http://dudri63.github.io/categories/Basic-CS/DataBase/"}],"tags":[{"name":"DataBase","slug":"DataBase","permalink":"http://dudri63.github.io/tags/DataBase/"}]},{"title":"[Algorithm] 외부 정렬 (정렬)","slug":"algo32","date":"2019-02-03T06:17:45.000Z","updated":"2019-02-16T07:43:24.125Z","comments":true,"path":"2019/02/03/algo32/","link":"","permalink":"http://dudri63.github.io/2019/02/03/algo32/","excerpt":"","text":"1. 외부 정렬2. 알고리즘3. 시간 복잡도 1. 외부 정렬 ‘외부 정렬(External Sort)’은 입력 크기가 매우 커서 읽고 쓰는 시간이 오래 걸린느 보조 기억 장치에 입력을 저장할 수 밖에 없는 상태에서 수행되는 정렬을 일컫는다.예를 들어, 컴퓨터의 주기억 장치의 용량이 1GB이고, 정렬할 입력의 크기가 100GB이면, 어떤 내부정렬 알고리즘으로도 정렬할 수 없다. 외부 정렬은 입력을 분할, 주기억 장치에서 수용할 만큼의 데이터에 대해서만 내부정렬을 수행, 그 결과를 보조 기억 장치에 저장한다.예를 들어, 100GB의 데이터를 1GB만큼씩 주기억 장치로 읽어 들이고, 퀵 정렬과 같은 내부정렬 알고리즘을 이용하여 정렬, 이 후, 다른 보조 기억 장치에 저장한다.이것을 반복하면 원래의 입력 100GB가 100개씩 정렬된 블록으로 분할되어 보조 기억 장치에 저장된다. 그 다음으로 정렬된 블록들을 하나의 정렬된 거대한 블록(100GB)으로 만들어야 한다.이를 위해 합병(merge)를 반복 수행한다.즉, 블록들을 부분적으로 주기억 장치에 읽어 들여서, 합병을 수행, 부분적으로 보조 기억 장치에 쓰는 과정을 반복한다. 다음은 1GB 블록 2개가 2GB 블록 1개로 합병되는 과정이다. 2개의 블록을 부분적으로 주기억 장치로 읽어들인다. 나머지 98개의 블록에 대해서 위 과정을 49회 추가로 반복하면, 2GB 블록 50개가 만들어진다.그 다음에는 2GB 블록 2개씩 짝을 지워 합병시키는 과정을 25회 반복하여, 4GB 블록 25개가 만들어진다.이러한 방식으로 계속 합병을 진행하면, 블록 크기가 2배씩 커지고, 블록의 수는 1/2씩 줄어들어 결국 100GB 블록 1개만 남는다. 외부정렬 알고리즘은 보조 기억 장치에서의 읽고 쓰기를 최소화하는 것이 중요하다.왜냐하면 보조 기억 장치의 접근시간(access time)이 오래 걸리기 때문이다. 2. 알고리즘 ExternalSort입력: 입력 데이터 저장된 입력 HDD출력: 정렬된 데이터가 저장된 출력 HDD12345입력 HDD에 저장된 입력을 크기가 M만큼씩 주기억 장치에 읽어 들인 후 내부 정렬 알고리즘으로 정렬하여 별도의 HDD에 저장한다. 다음 단계에서는 별도의 HDD는 입렬 HDD로 사용, 입력HDD는 출력 HDd로 사용된다.while (입력 HDD에 저장된 블록 수 &gt; 1) &#123; 입력 HDD에 저장된 블록을 2개씩 선택, 각각의 블록으로부터 데이터를 부분적으로 주기억 장치에 읽어 들여서 합병을 수행한다. 이때 합병된 결과는 출력 HDD에 저장한다. 단, 입력 HDD가 저장된 블록 수가 홀수일 때에는 마지막 블록은 그대로 출력 HDD에 저장한다.&#125;return 출력 HDD 3. 시간 복잡도 외부정렬은 전체 데이터를 몇 번 처리하는가를 가지고 시간복잡도를 측정한다.전체 데이터를 읽고 쓰는 것을 패스(pass)라고 한다. 위 알고리즘의 경우, while-루프를 마치면 1 패스가 수행된 것이다.그러므로 while-루프가 수행된 횟수가 알고리즘의 시간복잡도가 된다. 입력 크기가 N, 메모리 크기가 m이면, line 3이 한번 수행될 때마다 블록 크기가 2M,4M, 2kM으로 증가한다. 만일 마지막에 만들어진 블록 1개의 크기가 2kM이면, 이 블록은 입력 전체가 합병된 결과를 가지고 있다. 즉, 2kM = N이다.따라서 k = log2(N/M)이고, k는 while-루프가 수행된 횟수이다.그러므로 외부정렬의 시간복잡도는 O(log(N/M))이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 기수 정렬 (정렬)","slug":"algo31","date":"2019-02-03T05:53:37.000Z","updated":"2019-02-16T07:43:18.461Z","comments":true,"path":"2019/02/03/algo31/","link":"","permalink":"http://dudri63.github.io/2019/02/03/algo31/","excerpt":"","text":"1. 기수 정렬 1. 기수 정렬 ‘기수 정렬(Radix Sort)’이란 비교정렬이 아니고, 숫자를 부분적으로 비교하는 정렬이다.‘기(Radix)’는 특정 진수를 나타내는 숫자들이다.예를 들어, 10진수의 기는 0,1,2,…,9이고, 2진수의 기는 0,1이다. 기수 정렬은 제한적인 범위 내에 있는 숫자에 대해서 각 자릿수별로 정렬하는 알고리즘이다.기수 정렬의 가장 큰 장점은 어느 비교정렬 알고리즘보다 빠르다는 것이다. 아래의 예제는 5개의 3자리 십진수가 입력으로 들어왔을 때의 기수 정렬이다. 먼저 각 숫자의 1의 자리만 비교하여 작은 수부터 큰 수로 정렬한다.이 후, 10의 자리만을 각각 비교하여 정렬한다.단, 10의 자리 숫자가 같을 경우 1의 자리 숫자가 작은 것이 위로 향하도록 한다. 입력에 중복된 숫자가 있을 때, 정렬된 후에도 중복된 숫자의 순서가 입력에서의 순서와 동일하면 정렬 알고리즘이 ‘안정성(Stability)’을 갖는다.안정한 정렬 알고리즘은 중복된 숫자에 대해 앞서 있던 숫자가 정렬된 후에도 앞서 있고,불안정한 정렬 알고리즘은 정렬 후에 그 순서가 반드시 지켜지지는 않는다. 2. 알고리즘 RadixSort입력: n개의 r진수의 k자리 숫자출력: 정렬된 숫자123for i = 1 to k 각 숫자의 i자리 숫자에 대해 안정한 행렬을 수행한다.return 배열 A 3. 시간 복잡도 for-루프가 k번 반복한다.한 번 루프가 수행될 때 n개의 숫자의 i자릿수를 읽으며, r개로 분류하여 개수를 세고, 그 결과에 따라 숫자가 이동하므로 O(n+r)이 된다.따라서 총 시간복잡도는 O(k(n+r)) = O(n)이다.(통상적으로 k나 r은 n보다 매우 작다.) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 정렬 문제의 하한 (정렬)","slug":"algo30","date":"2019-02-03T03:22:01.000Z","updated":"2019-02-16T07:43:13.253Z","comments":true,"path":"2019/02/03/algo30/","link":"","permalink":"http://dudri63.github.io/2019/02/03/algo30/","excerpt":"","text":"합병 정렬, 퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 힙 정렬의 공통점은 숫자의 비교가 부분적이 아닌 숫자 대 숫자로 이루어진다는 것이다.이러한 정렬을 비교 정렬(Comparison Sort)이라고 한다.비교 정렬의 경우에 한해서 문제를 해결하기 위해 필요한 최소 비교 횟수는 어떻게 알 수 있는가? 어떤 주어진 문제에 대하여 시간복잡도의 하한(Lower Bound)이라 함은 어떠한 알고리즘도 문제의 하한보다 빠르게 해를 구할 수 없음을 의미한다.구체적으로 어떤 문제가 가지고 있는 고유한 특성 때문에 어떠한 알고리즘일지라도 해를 구하려면 적어도 하한의 시간복잡도만큼 필요하다는 뜻이다. n개의 숫자가 저장된 배열에서 최댓값을 찾는 문제의 하한을 고려한다.즉, 최댓값을 찾기 위해 숫자들을 적어도 몇 번 비교해야 하는지 파악하는 것이다. 이 문제는 어떤 알고리즘을 이용하여 탐색하던지 간에 적어도 (n-1)번의 비교가 필요하다.왜냐하면 어떤 방식이라도 각 숫자를 적어도 한 번 비교해야 하기 때문이다. n개의 숫자를 비교정렬하는 데 필요한 최소의 비교 횟수, 즉 정렬 문제의 하한을 고려한다. 예를 들어, 서로 다른 숫자 x,y,z에 대하여 정렬에 필요한 모든 경우의 숫자 대 숫자 비교는 다음 그림과 같다. 비교 결과가 ‘참’이면 왼쪽으로, ‘거짓’이면 오른쪽으로 분기된다.각 leaf 노드에는 루트로부터의 비교 결과에 따른 정렬된 결과가 저장된다.이러한 트리를 ‘결정 트리(Decision Tree)’라고 한다.결정 트리의 특징은 다음과 같다. leaf 노드의 수는 3!=6이다. 결정 트리는 이진트리(Binary Tree)이다. 결정트리에는 정렬을 함에 있어 불필요한 내부 노드가 없다. leaf 노드의 수가 3!인 이유는 서로 다른 숫자 3개가 정렬되는 모든 경우의 수가 3!이기 때문이다.결정트리는 각 내부 노드의 비교가 ‘참’일 때와 ‘거짓’일 때 각각 1개의 자식 노드를 가지기 때문에 이진트리이다.또한, 중복 비교를 하는 노드들이 있으나 모두 필요한 내부 노드이다. 따라서 서로 다른 3개의 숫자들을 비교정렬하기 위해서는 적어도 3번 비교해야 한다.즉, n개의 서로 다른 숫자들을 정렬하기 위해서는 적어도 n번 비교해야 한다.n개의 서로 다른 숫자들을 비교졍렬하는 결정 트리의 높이가 비교 정렬의 하한이 된다.비교 정렬의 하한은 O(nlogn)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 힙 정렬 (정렬)","slug":"algo29","date":"2019-02-01T12:48:55.000Z","updated":"2019-02-16T07:43:08.121Z","comments":true,"path":"2019/02/01/algo29/","link":"","permalink":"http://dudri63.github.io/2019/02/01/algo29/","excerpt":"","text":"1. 힙 정렬2. 알고리즘3. 시간 복잡도 1. 힙 정렬 ‘힙(Heap)’은 힙 조건을 만족하는 완전 이진 트리(Complete Binary Tree)이다. 힙 조건이란 각 노드의 값이 자식 노드의 값보다 커야 한다는 것을 말한다.노드의 값은 ‘우선순위(Priority)’라고 일컫는다.따라서 힙의 루트에는 가장 높은 우선순위(가장 큰 값)가 저장되어 있다.(단, 값이 작을수록 우선순위가 높은 경우도 있다.) 완전 이진트리란 마지막 레벨을 제외하고 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 채워지는 이진 트리이다.n개의 노드를 가진 힙은 완전 이진 트리이므로, 힙의 노드가 log2n이다. 아래 그림은 힙의 노드들이 배열에 저장된 모습을 보여준다. 배열 A에 힙을 저장한다면, A[0]은 비워 두고, A[1]부터 A[n]까지에 힙 노드들을 층별로 왼쪽부터 저장한다.이런 방식으로 저장하면, 트리에서 부모 노드와 자식 노드의 관계를 배열의 인덱스로 쉽게 표현할 수 있다. A[i]의 부모 노드 : A[i/2], ex. A[7]=10의 부모 노드 -&gt; A[7/2]=A[3]=80 A[i]의 왼쪽 자식 노드 : A[2i], ex. A[4]=50의 왼쪽 자식 노드 -&gt; A[4*2]=A[8]=20 A[i]의 오른쪽 자식 노드 : A[2i+1], ex. A[4]=50의 오른쪽 자식 노드 -&gt; A[4*2+1]=A[9]=40 ‘힙 정렬(Heap Sort)’은 힙 자료 구조를 이용하는 정렬 알고리즘이다.오름차순의 정렬을 위해 입력 배열을 큰 숫자가 높은 우선순위를 가지는 최대힙(Maximum heap)을 만든다.루트에 저장된 가장 큰 수를 배열의 가장 끝으로 이동시킨다.그리고 루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하며 힙 조건을 만족시키고, 힙 크기를 1개 줄인다.이 과정을 반복하여 나머지 숫자들을 정렬하는 것이 힙 정렬 알고리즘이다. 2. 알고리즘 HeapSort입력: 입력이 A[1]부터 A[n]까지 저장된 배열 A출력: 정렬된 배열 A1234567배열 A의 숫자에 대해서 힙 자료 구조를 만든다.heapSize = n // 힙의 크기를 조절for i=1 to n-1 A[1] &lt;-&gt; n-1 // 루트와 힙의 마지막 노드를 교환한다. heapSize = heapSize - 1 // 힙의 크기를 1 감소시킨다. DownHeap() // 위배된 힙 조건을 만족시킨다.return 배열 A line 1 : 배열 A를 힙으로 만든다. line 2 : 현재의 힙의 크기를 나타내는 변수인 heapSize를 n으로 초기화시킨다. line 3~6 : for루프가 (n-1)번 수행된다. (n-1)번 수행하는 루프가 종료된 후 루트인 A[1] 홀로 힙을 구성, A[1]에 있는 숫자가 가장 작은 수이므로 루프를 수행할 필요가 없기 때문이다. line 4 : 루트와 힙의 마지막 노드와 교환, 루트에는 힙에서 가장 큰 수가 저장되어 있었음. line 5 : 힙의 크기를 1 줄인다. line 4에서 힙의 마지막 노드와 힙의 루트를 바꾸어 놓았기 때문에 새로이 루트에 저장된 값이 자식 노드의 값보다 작아서 힙 조건이 위배된다. line 6 : DownHeap을 수행, 위배된 힙 조건을 해결한다. 위 과정은 아래 그림으로 설명할 수 있다. 우선 위 그림은 line 4에서 힙의 루트(90)와 마지막 노드(40)를 바꾸고, 힙의 노드 수를 1개 줄이는 과정이다.이 작업이 끝나면 힙 조건이 위배되고, 이를 해결하기 위해 DownHeap을 수행한다.DownHeap 수행 과정은 아래와 같다. 새로이 루트에 저장된 40이 루트의 자식 노드들(60,80)보다 작아서 힙 조건 위배, 자식 노드들 중에서 가장 큰 자식인 80과 루트 40을 교환한다. 40은 또다시 자식 노드들중 하나인 70보다 작기 때문에 힙 조건에 위배, 70과 40을 교환한다. 힙 조건을 만족하므로 DownHeap을 종료한다. 힙의 루트(80)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다. 힙의 루트(70)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다. 힙의 루트(60)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다. 힙의 루트(50)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다. 힙의 루트(40)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다. 힙의 루트(30)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다. 힙의 루트(20)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.힙의 크기가 1이 되었으므로 힙 정렬을 마친다.결과로서 배열이 정렬되었음 확인할 수 있다. for-루프를 반복할 때마다 힙에서 가장 큰 수를 힙의 마지막 노드와 교환한다.선택 정렬에서 최솟값을 찾는 대신에 최댓값을 찾아서 배열의 뒷부분으로부터 정렬하는 것과 같다.또한 선택정렬은 순차탐색으로 최솟값을 찾는 것에 비해 힙 정렬은 힙 자료구조를 이용하여 최댓값을 찾는다. 3. 시간 복잡도 line 1에서 힙을 만드는데 O(n) 시간이 걸린다.line 2는 변수를 초기화, O(1) 시간이 걸린다.line 3~6은 for-루프가 (n-1)번 수행, 루프 내부에서 line 4~5에서 O(1)시간이 걸리고, DownHeap은 O(log2n) 시간이 거린다.(힙의 높이는 log2n을 넘지 않음, 최악의 경우 leaf 노드까지 내려가며 교환한 경우를 가정한다.)힙 정렬의 시간복잡도는 O(n) + (n-1)*O(logn) = O(nlogn)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 쉘 정렬 (정렬)","slug":"algo28","date":"2019-02-01T10:23:40.000Z","updated":"2019-02-16T07:43:00.541Z","comments":true,"path":"2019/02/01/algo28/","link":"","permalink":"http://dudri63.github.io/2019/02/01/algo28/","excerpt":"","text":"1. 쉘 정렬2. 알고리즘3. 시간 복잡도4. 응용 1. 쉘 정렬 버블 정렬이나 삽입 정렬이 수행되는 과정을 살펴보면, 이웃하는 원소의 숫자들끼리의 자리를 이동함으로써 정렬이 이루어진다.그렇기 때문에 위 두 정렬의 경우, 배열되는 과정이 굉장히 느리다.특히 삽입 정렬은 배열의 마지막 원소가 입력에서 가장 작은 숫자라면, 그 숫자가 배열의 맨 앞으로 이동할 때, 다른 모든 숫자들이 1칸씩 오른쪽으로 이동하여야 한다. ‘쉘 정렬(Shell Sort)’은 이러한 단점을 보완하기 위해서 삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자을 앞부분으로 ‘빠르게’ 이동시키고, 동시에 앞부분의 큰 숫자는 뒷부분으로 이동시키며, 가장 마지막에는 삽입 정렬을 수행한다. 다음 예제를 통해 쉘 정렬의 아이디어를 이해한다. 먼저 간격(gap)이 5가 되는 숫자끼리 그룹을 만든다. 만들어지는 그룹은 다음과 같다.[30,80,50], [60,40,30], [90,20,40], [10,10,90], [40,60,80] 각 그룹내에서 정렬된 결과를 1줄에 나열하면 다음과 같다. 완벽하지는 않지만 대체로 큰 수가 뒤로, 작은 수가 앞으로 이동하였음을 확인할 수 있다. 이 후, 간격을 5보다 작게 하여 또 다시 그룹별로 삽입 정렬을 수행한다. 마지막에는 간격(gap)을 1로 하여 수행한다. 이는 삽입 정렬 그 자체이다. 2. 알고리즘 ShellSort입력: 크기가 n인 배열 A출력: 정렬된 배열 A1234567891011for each gap h = [h0 &gt; h1 &gt; ... &gt; hk = 1] // 큰 gap부터 차례로 for i = h to n-1 CurrentElement = A[i]; j = i; while (j&gt;=h) and (A[j-h] &gt; CurrentElement) &#123; A[j] = A[j-h]; j = j - h; &#125; A[j] = CurrentElement;&#125;return 배열 A 앞의 예제에 위 알고리즘을 적용하여 쉘 정렬의 과정을 살핀다. h = 5 (간격이 5일 때) i = 5,6,7,8,9일 때 i = 10,11,12,13,14일 때 h = 3 (간격이 3일 때) 3개의 그룹으로 나뉘어지고, 각 그룹의 원소는 5개씩이다. h = 1 (간격이 1일 때, 삽입 정렬과 동일) 쉘 정렬의 수행 속도는 간격 선정에 따라서 좌우된다.지금까지 알려진 가장 좋은 성능을 보이는 간격은 1, 4, 10, 23, 57, 132, 301, 701이다. 3. 시간 복잡도 쉘 정렬의 최악 경우의 시간 복잡도는 O(n2)이다.히바드(Hibbard) 간격 2k-1을 사용하면 쉘 정렬의 시간복잡도는 O(n1.5)이다.또한 다양한 실험을 통해 쉘 정렬의 시간복잡도는 O(n1.25)까지 줄일 수 있다고 알려져 있다. 4. 응용 쉘 정렬은 입력 크기가 매우 크지 않은 경우에 매우 좋은 성능을 보인다.쉘 정렬은 임베디드(Embedded) 시스템에서 주로 사용되는데, 쉘 정렬의 특징인 간격에 따른 그룹별 정렬 방식이 하드웨어로 정렬 알고리즘을 구현하는 데 매우 적합하기 때문이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 삽입 정렬 (정렬)","slug":"algo27","date":"2019-02-01T09:22:29.000Z","updated":"2019-02-16T07:42:56.029Z","comments":true,"path":"2019/02/01/algo27/","link":"","permalink":"http://dudri63.github.io/2019/02/01/algo27/","excerpt":"","text":"1. 삽입 정렬2. 알고리즘3. 시간 복잡도 1. 삽입 정렬 ‘삽입 정렬(Insertion Sort)’은 배열을 정렬된 부분(앞부분)과 정렬이 안 된 부분(뒷부분)으로 나누고, 정렬이 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬되도록 하는 과정을 반복한다. 정렬이 안 된 부분의 숫자 하나가 정렬된 부분에 ‘삽입’됨으로써, 정렬된 부분의 원소 수가 1개 늘어나고, 정렬이 안 된 부분의 원 소 수는 1개 줄어든다.이를 반복하여 수행, 마지막에는 정렬이 안 된 부분에 원소가 아무것도 남지 않게 된다. 2. 알고리즘 InsertionSort입력: 크기가 n인 배열 A출력: 정렬된 배열 A12345678910for i = 1 to n-1 &#123; // A[0]는 정렬이 된 상태로 본다 CurrentElement = A[i] // 정렬이 안된 부분의 가장 왼쪽 원소 j &lt;- i-1 // 정렬이 된 부분의 가장 오른쪽 원소를 지칭 while (j &gt;=0) and (A[j] &gt; CurrentElement) &#123; // CurrentElement가 더 작으면 A[j+1] = A[j] // 정렬이 된 부분의 가장 오른쪽 원소를 오른쪽으로 한칸 이동 j &lt;- j-1 &#125; A[j+1] &lt;- CurrentElement // 비어있는 부분으로 CurrentElement 이동&#125;return A 다음의 배열에 대해 삽입 정렬이 수행되는 과정을 확인한다. i=1, CurrentElement = A[1] = 10, j = i-1 = 0A[j]= A[0] = 40 &gt; CurrentElement = 10, 한 칸 이동, j &lt;- j-1j=-1, while-문 만족하지 않음A[j+1] = A[0]에 CurrentElement 저장 i=2, CurrentElement = A[2] = 50, j = i-1 = 1A[j] = A[1] = 40 &lt; CurrentElement = 50, while-문 만족하지 않음, 자리 이동 없음 i=3, CurrentElement = A[3] = 90, j = i-1 = 2A[j] = A[2] = 50 &lt; CurrentElement = 90, while-문 만족하지 않음, 자리 이동 없음 i=4, CurrentElement = A[4] = 20, j = i-1 = 3A[j] = A[3] = 90 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1A[j] = A[2] = 50 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1A[j] = A[1] = 40 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1A[j] = A[0] = 10 &lt; CurrentElement = 20, while-문 만족하지 않음A[j+1] = A[1]에 CurrentElement 저장 i=5, CurrentElement = A[5] = 80, i=6, CurrentElement = A[6] = 30, i=7, CurrentElement = A[7] = 60, 3. 시간 복잡도 line 1 : for-루프가 (n-1)번 수행line 4 : while-루프가 i=1일 때, 최대 1회 수행, i=2일 때, 최대 2회 수행, … i=n-1일 때, 최대 n-1회 수행while-루프 내부의 수행시간은 O(1) 따라서, n(n-1)/2 * O(1) = O(n2) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 선택 정렬 (정렬)","slug":"algo26","date":"2019-02-01T08:53:01.000Z","updated":"2019-02-16T07:42:51.277Z","comments":true,"path":"2019/02/01/algo26/","link":"","permalink":"http://dudri63.github.io/2019/02/01/algo26/","excerpt":"","text":"1. 선택 정렬2. 알고리즘3. 시간복잡도 1. 선택 정렬 ‘선택 정렬(Selection Sort)’은 입력 배열 전체에서 최솟값을 ‘선택’하여 배열의 0번 원소와 자리를 바꾸고, 다음에는 0번 원소를 제외한 나머지 원소에서 최솟값을 선택하여 배열의 1번 원소와 자리를 바꾼다. 이러한 방식으로 마지막에 2개의 원소 중에서 작은 값을 선택, 자리를 바꿈으로서 정렬을 마친다. 2. 알고리즘 SelectionSort입력: 크기가 n인 배열 A출력: 정렬된 배열 A123456789for i = 0 to n-2 // 크기가 n인 배열은 n-1번 까지 있음. 마지막 칸은 제외하니 n-2까지 정렬시킨다. min = i for j = i+1 to n-1 &#123; // A[i]보다 작은 값이 A[i+1]~A[n-1]까지 있으면, 그 중 가장 작은 값을 선택 if (A[j] &lt; A[min]) min = j &#125; A[i] &lt;-&gt; A[min] // A[i]와 가장 작은 값을 위치 변경&#125;return 배열 A 다음 배열이 선택 정렬 알고리즘에 의해 정렬되는 과정을 본다. i=0, A[0]~A[7] 중 min=1 i=1, A[1]~A[7] 중 min=4 i=2, A[2]~A[7] 중 min=6 … i=6, A[6]~A[7] 중 min=7 3. 시간 복잡도 line 1의 for-루프는 (n-1)번 수행된다.line 3의 for-루프는 i=1,2,3,…일 때, 각각 (n-2), (n-2), (n-4), …번 수행된다.루프 내부의 if-조건이 ‘참’일 때 자리바꿈 O(1) 시간이 걸린다.따라서 시간복잡도는 n*(n-1)/2 * O(1) = O(n2)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 버블 정렬 (정렬)","slug":"algo25","date":"2019-01-31T16:37:55.000Z","updated":"2019-02-16T07:42:45.669Z","comments":true,"path":"2019/02/01/algo25/","link":"","permalink":"http://dudri63.github.io/2019/02/01/algo25/","excerpt":"","text":"1. 버블 정렬2. 알고리즘3. 시간 복잡도 1. 버블 벙렬 ‘버블 정렬(Bubble Sort)’은 이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘이다.배열을 좌우가 아니라 상하로 그리면 정렬하는 과정에서 작은 수가 ‘거품’처럼 위로 올라가는 것이 연상된다. 2. 알고리즘 BubbleSort입력: 크기가 n인 배열 A출력: 정렬된 배열 A12345for pass = 1 to n - 1 for i = 1 to n - pass if (A[i-1] &gt; A[i]) // 위의 원소가 아래의 원소보다 크면 A[i-1] &lt;-&gt; A[i] // 서로 자리를 바꾼다.return 배열 A 다음의 배열에 대해 버블 정렬이 수행되는 과정을 확인한다. 패스 1 패스 2 패스 3 패스 4 패스 5~7의 결과는 패스 4의 결과와 동일하다. 배열의 가장 아래부터 정렬되는 것을 확인할 수 있다. 3. 시간복잡도 pass = 1이면 (n-1)번 비교, pass = 2이면 (n-2)번 비교, pass = (n-1)이면 1번 비교한다.따라서 총 비교 횟수는 n(n-1)/2이다.그리고 if-조건이 참일 경우 자리바꾸는 시간 O(1)이 걸린다.최악의 경우를 가정하고 시간복잡도를 구하면, O(n2)이 된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[Algorithm] 정렬 알고리즘","slug":"algo24","date":"2019-01-31T15:39:02.000Z","updated":"2019-02-16T07:42:39.701Z","comments":true,"path":"2019/02/01/algo24/","link":"","permalink":"http://dudri63.github.io/2019/02/01/algo24/","excerpt":"","text":"정렬 알고리즘 분류는 다음과 같다. 기본 정렬 알고리즘 : 버블 정렬, 선택 정렬, 삽입 정렬 보다 효율적인 정렬 알고리즘 : 쉘 정렬, 힙 정렬, 합병 정렬, 퀵 정렬, 기수 정렬 특히 기수 정렬은 제한된 크기 이내의 숫자로 구성되어 있을 때 매우 효율적이다. 정렬 알고리즘은 또한 내부정렬(Internal Sort)과 외부 정렬(External Sort)로도 분류할 수 있다. 내부 정렬 : 입력의 크기가 메인 메모리의 공간보다 크지 않은 경우 수행, 앞서 언급한 정렬 알고리즘들은 모두 내부 정렬 알고리즘들이다. 외부 정렬 : 입력의 크기가 메인 메모리의 공간보다 큰 경우 수행, 보조 기억 장치에 있는 입력을 여러 번에 나누어 주기억 장치에 읽어들인 후, 정렬하여 보조 기억 장치에 다시 저장하는 과정을 반복한다. 앞으로 포스팅하는 모든 정렬 알고리즘은 오름차순으로 정렬하겠다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"}]},{"title":"[딥러닝/머신러닝] TensorFlow","slug":"adl2","date":"2019-01-30T13:14:44.000Z","updated":"2019-02-16T07:48:12.180Z","comments":true,"path":"2019/01/30/adl2/","link":"","permalink":"http://dudri63.github.io/2019/01/30/adl2/","excerpt":"","text":"1. TensorFlow2. TensorFlow 예제3. TensorFlow 구조4. placeholder5. Tesnor, Ranks, Shapes, Types 1. TensorFlow 텐서플로우(TensorFlow)는 구글에서 만든 오픈 소스 라이브러리이다.텐서플로우는 데이터 플로우 그래프(Data Flow Graph)를 이용하여 수 계산(Numerical Computation)을 할 수 있다는 특징이 있다.또한, ‘파이썬(Python)’ 언어를 이용하여 텐서플로우를 활용할 수 있다. Data Flow Graph란 다음 그림과 같은 것이다. ‘노드’와 노드간을 연결하는 ‘엣지’로 구성되어 있는 것을 그래프라고 한다.Data Flow Graph에서 노드는 하나의 operation이다.엣지는 데이터(tensor)이다.데이터들은 연속적으로 연산하여 결과를 추출하는 것이 Data Flow Graph의 방식이다. 리눅스 환경에서 텐서플로우를 설치한 후, 파이썬에서 텐서플로우 모듈을 import 및 버전 정보를 확인한 결과는 위와 같다. 2. TensorFlow 예제 “Hello, TensorFlow!”라는 내용의 constant 노드를 만들고, 변수 hello에 이를 할당한다.(computation 그래프 내에 노드 1개가 만들어진 형태이다.)이 후, session을 만든 뒤 실행(run)시켰다.(computation 그래프를 실행하기 위해서는 session을 만들어야 한다.) (b’라는 문자열은 간단하게 byte string이라는 의미이다. 프로그램 동작과는 무관하다) a와 b라는 노드가 있고, ‘+’라는 노드로 연결되는 간단한 그래프를 만든 것이다. node1은 ‘3’이라는 내용, data type은 float32인 constant 노드이다.node2는 ‘4’라는 내용의 constant 노드이다. node2는 암묵적으로 node1과 마찬가지로 data type이 float32임을 유의한다.node3은 node1, node2를 더하는 add 노드이다. 이 후, node1, node2, node3를 print() 함수를 이용하여 출력하면, 각각의 노드들은 Tensor이며, 그 내용들을 확인할 수 있다. 결과값을 확인할 수는 없다. 결과값을 확인하기 위해서 1. session을 만들고, 2. 해당 session에 원하는 노드들을 넣은 뒤 3. run한다. 3. TensorFlow 구조 텐서플로우의 구조는 위와 같은데 기존의 프로그래밍과는 조금 다르다. 먼저 그래프를 빌드한다. session을 만든 뒤 run한다. 결과로 graph내의 값을 업데이트한다. 4. plcaeholder 위에서는 그래프를 만들면서, 각 노드들의 숫자들을 지정하였다.그렇다면, 그래프를 미리 만들어 놓고, 실행시키는 단계에서 값을 던지고 싶다면 어떻게 해야할까? constant 노드가 아니라, placeholder라는 특별한 노드를 사용한다. a, b, adder_node, 총 3개의 placeholder 노드를 만들었다.이 후, session을 생성한 뒤, feed_dict로 a, b 노드에 값을 할당한 뒤 실행시킨다.1개의 값이 아닌 여러개의 값을 넘겨줄 수도 있다. 5. Tensor, Ranks, Shapes, Types 5.1. Tensor TensorFlow 프로그램은 모든 데이터를 tensor 데이터 구조를 사용해서 표현한다.TensorFlow의 tensor는 n-차원 배열 또는 리스트라고 생각할 수 있다.하나의 tesnor는 정적 타입, 동적 차원을 가지고 있다.그리고 Computation 그래프의 노드들은 오직 tensor만을 전달할 수 있다. 5.2. Rank TensorFlow 시스템에서 tensor는 rank라는 차원 단위로 표현된다. 위 표는 rank에 따른 tensor의 형식이다.5.3. ShapeTensorFlow 문서는 tensor 차원을 표현할 때, 세 가지 기호를 사용한다.rank, shape, 차원수가 그것들이다.다시 말하면, tensor의 차원을 알기 위해서 rank, shape, 차원수를 살펴볼 수 있다. 5.4. Data Types Tensor는 차원 말고도 데이터 타입을 갖는다. 아래의 데이터 타입을 tensor에 지정할 수 있다. Reference 랭크, 크기, 타입-텐서플로우 문서 한글 번역본, 텐서플로우, 2019. 1. 30, https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\\_types.html 섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Deep Learning","slug":"etc/Deep-Learning","permalink":"http://dudri63.github.io/categories/etc/Deep-Learning/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://dudri63.github.io/tags/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://dudri63.github.io/tags/Machine-Learning/"}]},{"title":"[딥러닝/머신러닝] 머신러닝이란","slug":"adl1","date":"2019-01-30T10:32:44.000Z","updated":"2019-02-16T07:48:07.604Z","comments":true,"path":"2019/01/30/adl1/","link":"","permalink":"http://dudri63.github.io/2019/01/30/adl1/","excerpt":"","text":"1. 이세돌과 알파고2. 머신러닝이란 1. 이세돌과 알파고 그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의 순간적인 직관이 매우 중요한 것으로 여겨졌다.따라서 바둑이라는 종목에 한해서는 컴퓨터가 인간을 넘어서기 힘들 것으로 꽤 오랜 시간 간주되었다.그러나 이세돌 9단이 알파고에게 4:1로 패배하였다. 인공지능이란 무엇인가에 대하여 많은 이목이 쏠린 역사적인 사건이다.인공지능은 과연 사람처럼 직관적인 의사결정을 할 수 있는 것인가? Dr.Andrew Ng에 의하면 오늘날의 시대를 살기 위해서는 머신러닝 학습이 필수적이라고 이야기한다.또한, 머신러닝을 잘 활용하는 사람이 Super Power를 지닐 수 있다고 한다. 2. 머신러닝이란 머신러닝(Machine Learning)이란 일종의 소프트웨어, 프로그램이다.그러나 기존 프로그래밍 기법과는 차이점이 있다. 기존 explicit programming이란 개발자가 환경에 따라서 프로그램이 어떻게 반응할지를 정의한다.그런데 explicit하게, 즉, 명확하게 프로그래밍하기 어려운 경우가 있다.예를 들어, 스팸 메일을 필터링하는 프로그램을 작성할 때 모든 경우를 고려하여 스팸 or not을 결정하기가 어렵다. 머신러닝의 시작은 상황이 복잡할 때 모든 경우를 일일이 프로그래밍하지 않고, ‘어떤 현상이나 자료에서 자동적으로 배우는 것은 어떨까?’라는 생각이다.즉, 머신러닝은 프로그램인데, 개발자가 모든 경우를 명확하게 프로그래밍 하지 않고, 프로그램이 스스로 학습하여 배운 뒤 처리할 수 있도록 하는 것이라고 할 수 있다. 머신러닝은 학습하는 방법에 따라서 Supervised Learning, Unsupervised Learning으로 구분할 수 있다.Supervised Learning은 정해져있는 데이터(labeled, training set)를 이용하여 학습하는 것이다.예를 들어, 개나 고양이 사진들의 label을 각각 개, 고양이로 달고 학습을 시킬 수 있다. 그런데, 모든 경우 label을 달 수 있는 것은 아니다.Google news는 자동적으로 유사한 뉴스들을 grouping을 한다.또한, 유사한 단어들을 grouping하는 것도 특정한 label을 달기 어렵다.이 경우 Unsupervised Learning(학습)하여야 한다. 머신러닝에서 대부분의 문제들은 Supervised Learning으로 해결할 수 있다.Supervised Learning의 예는 다음과 같다. X: feature, Y: label label이 정해져 있는 feature들을 가지고 학습을 한다.(네모칸 안에 있는 표를 training data set이라고 한다.) 이 후, 내가 모르는 Xtest의 label을 물어보면, ML은 Y=3이라고 대답한다. 알파고의 원리도 위와 다르지 않다.기존 바둑 기사들이 둔 기보를 이용하여 학습한 뒤, 이세돌 9단과 대결할 때, 학습한 것을 바탕으로 각 수를 놓는 것이다. Supervised Learning의 Type은 다음과 같다. 공부한 시간에 따른 시험 성적(0~100) 예상 : regression 공부한 시간에 따른 시험 결과(pass or fail) 예상 : binary classification 공부한 시간에 따른 시험 성적(A,B,C,D,F) 예상 : multi-label classification ML을 이용한 공부한 시간에 따른 시험 성적(0~100) 예상이 어떻게 되는지는 다음과 같다. 왼쪽 표는 training data set이다.regression 모델을 왼쪽 표를 이용하여 training한다. 이 후, x=7(7시간)일 때, y(점수)를 물어보면, 학습한 것을 바탕으로 y=70을 내놓는다. Reference 섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/, https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Deep Learning","slug":"etc/Deep-Learning","permalink":"http://dudri63.github.io/categories/etc/Deep-Learning/"}],"tags":[{"name":"Deep Learning","slug":"Deep-Learning","permalink":"http://dudri63.github.io/tags/Deep-Learning/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://dudri63.github.io/tags/Machine-Learning/"}]},{"title":"[Python] 클래스","slug":"python8","date":"2019-01-29T12:31:58.000Z","updated":"2019-02-16T07:47:20.801Z","comments":true,"path":"2019/01/29/python8/","link":"","permalink":"http://dudri63.github.io/2019/01/29/python8/","excerpt":"","text":"1. 클래스 1. 클래스 C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있다.그러나 프로그램 작성 시 클래스를 사용하면 프로그래머가 얻을 수 있는 이점이 굉장히 많다. 클래스는 ‘과자틀’, 객체는 과자틀에 의해 만들어진 ‘과자’에 비유할 수 있다.클래스란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고, 객체란 클래스에 의해서 만들어진 피조물을 뜻한다. 클래스에 의해서 만들어진 객체는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 동일한 클래스에 의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다. 123456789101112131415161718class Cal: # Cal이라는 새로운 class를 정의 def __init__(self, v1, v2): # 생성자 self.v1 = v1 self.v2 = v2 def add(self): # add 함수 return self.v1+self.v2 def subtract(self): # subtract 함수 return self.v1-self.v2 c1 = Cal(10,10) # 객체 c1 생성 및 변수에 객체 할당print(c1.add()) # 객체의 멤버에 접근print(c1.subtract()) # 객체의 멤버에 접근c2 = Cal(30,20) # 객체 c2 생성 및 변수에 객체 할당print(c2.add()) # 객체의 멤버에 접근print(c2.subtract()) # 객체의 멤버에 접근 __init__ : 생성자객체를 생성할 때, 생성자의 self를 제외한 매개변수 숫자만큼 인자를 채워야 한다.ex. __init(self,v1, v2)__ -&gt; c1 = Cal(v1,v2) self : 객체의 인스턴스 그 자체, 파이썬에서는 클래스의 메소드를 정의할 때 self를 꼭 명시해야 한다. 1234567891011class C(object): def __init__(self, v): self.value = v def show(self): print(self.value) c1 = C(10)print(c1.value) # 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출 c1.value = 20 # 객체 c1의 멤버 변수 value의 값을 변경print(c1.value) # 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출c1.show() # 객체 c1의 멤버 함수 show()를 호출, show() 함수는 value의 값을 인자로 print() 함수 호출 cf. 객체와 인스턴스 클래스에 의해서 만들어진 객체를 인스턴스라고도 한다. 그러나 객체와 인스턴스는 미묘하지만 차이점이 있다. 예를 들어 Cookie라는 클래스가 있다고 가정한다. a = Cookie() 로 만들어진 a는 객체이다. 그리고 a라는 객체는 Cookie의 인스턴스이다. 즉, 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 인스턴스” 보다는 “a는 객체”라는 표현이 어울리며, “a는 Cookie의 객체” 보다는 “a는 Cookie의 인스턴스”라는 표현이 훨씬 잘 어울린다. cf. 변수 값을 넣을 수 있는 이름이 붙어있는 공간. 일반적으로 값을 변경할 수 있다. 값을 변경할 수 없을 경우 특별하게 ‘상수’라고 한다. cf. 인스턴스 변수와 클래스 변수 인스턴스 변수와 클래스 변수를 합쳐서 ‘멤버 변수’라고 한다. 인스턴스 변수는 객체를 생성할 때 생성된다. 각각의 인스턴스마다 다른 값을 가질 수 있다. 클래스 변수는 인스턴스 변수에 static이 붙은 형식이다. 인스턴스 변수는 각각 고유한 값을 가질 수 있는 것에 반해 클래스 변수는 모든 인스턴스가 동일한 값을 공유한다. 인스턴스 변수, 클래스 변수 모두 Class 내부에서 선언된다. cf. 캡슐화 캡슐화(Encapsulation)는 객체 지향 프로그래미에서 다음 2가지 측면이 있다. 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용을 외부에 감추어 은닉한다. 외부로부터 영향을 받지 변경되지 않도록 기본적으로 캡슐화를 이용한다. 함수나 변수도 캡슐로 감싼 예 중 하나이다. 또한 함수들을 다시 묶어서 모듈로 감쌀 수도 있다. 접근 지정자를 따로 지정하여 외부에서 캡슐에 얼마나 접근할 수 있을지 설정하기도 한다. 12345678910111213class C(object): def __init__(self, v): self.value = v def show(self): print(self.value) def getValue(self): # 인스턴스의 value를 반환 return self.value def setValue(self, v): # 인스턴스의 value를 설정 self.value = vc1 = C(10) # C의 인스턴스 c1 생성 print(c1.getValue()) # c1의 value값을 받아온 뒤, print() 호출c1.setValue(20) # c1의 value값을 설정print(c1.getValue()) # c1의 value값을 받아온 뒤, print() 호출 set은 객체 내부의 데이터를 직접 바꾸기 위한 메소드,get은 객체 내부의 데이터를 직접 받아오기 위한 메소드이다. 1234567891011121314class Person: bag = [] # bag 속성(클래스 속성) def put_bag(self, stuff): self.bag.append(stuff) james = Person()james.put_bag(&apos;책&apos;) maria = Person()maria.put_bag(&apos;열쇠&apos;) print(james.bag)print(maria.bag) 클래스 속성으로서 bag 속성을 만들었다. james 인스턴스에서 ‘책’을 넣었고, maria 인스턴스에서 ‘열쇠’를 넣었는데, james, maria 모두 bag 속성으로서 책과 열쇠를 모두 갖는다.클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다. 123456789101112131415class Person: def __init__(self): self.bag = [] # bag 속성(인스턴스 속성) def put_bag(self, stuff): self.bag.append(stuff) james = Person()james.put_bag(&apos;책&apos;) maria = Person()maria.put_bag(&apos;열쇠&apos;) print(james.bag)print(maria.bag) 인스턴스 속성으로서 bag 속성을 만들었다. 이 경우, 클래스 속성으로 만들었을 때와는 달리 각 인스턴스마다 고유한 속성을 갖게 된다. Reference 05-1 클래스, 점프 투 파이썬, 2019. 1. 29, https://wikidocs.net/28 35.1 크래스 속성과 인스턴스 속성 알아보기, 코딩도장, 2019. 1. 29, https://dojang.io/mod/page/view.php?id=2378 객체와 변수, 생활코딩, 2019. 1. 29, https://opentutorials.org/course/1750/10000","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Algorithm] 동전 거스름돈 (동적계획)","slug":"algo23","date":"2019-01-29T09:07:17.000Z","updated":"2019-02-16T07:42:34.713Z","comments":true,"path":"2019/01/29/algo23/","link":"","permalink":"http://dudri63.github.io/2019/01/29/algo23/","excerpt":"","text":"1. 동전 거스름돈2. 알고리즘3. 시간 복잡도 1. 동전 거스름돈 거스름돈을 동전으로 받을 때, 누구나 적은 수의 동전을 받길 원한다고 가정한다.동전 거스름돈 문제는 그리디 알고리즘으로 해결할 수도 있으나, 160원짜리 동전을 추가로 발행하는 등의 상황이 있을 때는 항상 최적해를 찾을 수는 없다.동적 계획 알고리즘은 모든 동전 거스름돈 문제에 대하여 항상 최적해를 찾는다. 다른 문제들과 마찬가지로 동적 계획 알고리즘을 고안하기 위해서는 부분문제들을 찾아내야 한다.동전 거스름돈 문제에 주어지는 일반적인 문제 요소들을 고려한다.정해진 동전의 종류, 거스름돈이 그것들이다. 동전 거스름돈 문제도 배낭 문제와 마찬가지로 동전 거스름돈도 1원씩 증가시켜 문제를 해결한다.그리고 부분문제들의 해를 1차원 배열 C에 저장한다. 1원을 거슬러 받을 때 사용되는 최소의 동전 수 C[1] 2원을 거슬러 받을 때 사용되는 최소의 동전 수 C[2] 3원을 거슬러 받을 때 사용되는 최소의 동전 수 C[3]… n원을 거슬러 받을 때 사용되는 최소의 동전 수 C[n] 그렇다면, C[j]를 구하는 데 어떤 부분문제가 필요한가? 500원짜리 동전이 거스름돈 j원에 필요하면 C[j-500] = C[j-d1]에 500원짜리 동전 1개를 추가한다. 100원짜리 동전이 거스름돈 j원에 필요하면 C[j-100] = C[j-d2]에 100원짜리 동전 1개를 추가&gt;한다. 50원짜리 동전이 거스름돈 j원에 필요하면 C[j-50] = C[j-d3]에 50원짜리 동전 1개를 추가&gt;한다. 10원짜리 동전이 거스름돈 j원에 필요하면 C[j-10] = C[j-d4]에 10원짜리 동전 1개를 추가&gt;한다. 1원짜리 동전이 거스름돈 j원에 필요하면 C[j-1] = C[j-d5]에 1원짜리 동전 1개를 추가&gt;한다. 위 다섯 가지 중에서 가장 작은 값을 C[j]로 정한다. 그리하여 C[j]의 정의는 다음과 같다. C[j] = min1&lt;=i&lt;=k{C[j-di] + 1}, if j &gt;= di 2. 알고리즘 다음은 거스름돈 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 배열 C는 최소의 동전 수를 저장하는 데 사용된다.123456789101112DPCoinChange입력: 거스름돈 n원, k개의 동전의 액면, d1&gt;d2&gt;...&gt;dk=1출력: C[n]for i = 1 to n C[i] = ∞C[0] = 0for j = 1 to n &#123; // j는 1원부터 증가하는 임시 거스름돈 액수, j=n이면 입력에 주어진 거스름돈 for i = 1 to k &#123; // 액면이 가장 높은 동전부터 1원짜리 동전까지 if (di &lt;= j) and (C[j-di] + 1 &lt; C[j]) // 액면이 가장 높은 동전부터 1원짜리 동전까지 C[j] = C[j-di] + 1 &#125;&#125;return C[n] 다음은 d1=16, d2=10, d3=5, d4=1이고, 거스름돈 n=20일 때, DPCoinChange 알고리즘이 수행되는 과정이다. Line 4~5 : 배열 C를 초기화한다. Line 6~9 : j = 1일 때(임시 거스름론), i = 1, 2, 3일 때,d1 = 16 &gt; j, d2=10 &gt; j, d3=5 &gt; jif 조건을 만족하지 않음 i = 4일 때,d4 = 1 &lt; j, C[j-d4]+1 = C[1-1]+1 = 0+1 = 1 &lt; C[j] = C[1] = ∞if 조건을 만족C[j] = C[j-d4] + 1 = C[1] = C[1-1] + 1 = 0 + 1 = 1 Line 6~9 : j = 2, 3, 4일 때, i = 4일 때에만 if 조건을 만족함(j = 1일 때와 동일)C[2] = C[2-1] + 1 = 2, C[3] = 3, C[4] = 4 Line 6~9 : j = 5일 때 i = 1, 2일 때,d1 = 16 &gt; j, d2=10 &gt; jif 조건을 만족하지 않음 i = 3일 때,d3 = 5 = j, C[j-d3]+1 = C[5-5]+1 = 0+1 = 1 &lt; C[j] = C[5] = ∞if 조건을 만족C[5] = C[j-d3]+1 = C[5-5]+1 = 0+1 = 1 i = 4일 때,d4 = 1 = j, C[j-d4]+1 = C[5-1]+1 = 4+1 = 5 &gt; C[j] = C[5] = 1if 조건을 만족하지 않음 Line 6~9 : j = 6, 7, 8, 9일 때 i = 3일 경우에만 if 조건을 만족함(j = 5일 때와 동일)C[6] = C[6-5] + 1 = 2, C[7] = 3, C[8] = 4, C[9] = 5 Line 6~9 : j = 10일 때 i = 1일 때,d1 = 16 &gt; jif 조건을 만족하지 않음 i = 2일 때,d2 = 10 = j, C[j-d2]+1 = C[10-10]+1 = 0+1 = 1 &lt; C[j] = C[10] = ∞if 조건을 만족C[10] = C[j-d2]+1 = C[10-10]+1 = 0+1 = 1 i = 3,4 일 때,di &lt; j = 10,C[j-d3]+1 = C[10-5]+1 = 2 &gt; 1, C[j-d4]+1 = C[10-1]+1 = 6 &gt; 1if 조건을 만족하지 않음 Line 6~9 : j = 11, 12, 13, 14, 15일 때 i = 2일 경우에만 if 조건을 만족함(j = 10일 때와 동일)C[11] = 2, C[12] = 3, C[13] = 4, C[14] = 5 Line 6~9 : j =15일 때 i = 1일 때,d1 = 16 &lt; jif 조건을 만족하지 않음 i = 2일 때,d2 = 10 &gt; j, C[j-d2]+1 = C[15-10]+1 = 1+1 = 2 &lt; C[j] = C[10] = ∞if 조건을 만족C[15] = C[j-d2]+1 = C[15-10]+1 = 2 i = 3,4일 때,if 조건을 만족하지 않음 Line 6~9 : j = 16일 때 i = 1일 때,d1 = 16 = j, C[j-d1]+1 = C[16-16]+1 = 0+1 = 1 &lt; C[j] = C[16] = ∞if 조건을 만족C[16] = C[j-d1]+1 = C[16-16]+1 = 0+1 = 1 i = 2, 3, 4일 때,if 조건을 만족하지 않음 Line 6~9 : j = 17, 18, 19일 때 i = 1일 경우에만 if 조건을 만족함(j = 16일 때와 동일)C[17] = 2, C[18] = 3, C[19] = 4 Line 6~9 : j = 20일 때 i = 1if 조건을 만족하지 않음 i = 2if 조건을 만족C[20] = C[j-d2]+1 = C[10]+1 = 2 i = 3C[20] = C[j-d3]+1 = C[15]+1 = 3 &gt; 2if 조건을 만족하지 않음 i = 4일 때C[20] = C[j-d4]+1 = C[19]+1 = 5 &gt; 2if 조건을 만족하지 않음 Line 12 C[20] = 2를 return 3. 시간복잡도 DPCoinChange 알고리즘의 시간복잡도는 O(nk)이다.왜냐하면 거스름돈 j가 1원부터 n원까지 변하며, 각각의 j에 대하여 최악의 경우 모든 동전을 1번씩 고려하기 때문이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 배낭 문제 (동적계획)","slug":"algo22","date":"2019-01-29T06:53:17.000Z","updated":"2019-02-16T07:42:27.936Z","comments":true,"path":"2019/01/29/algo22/","link":"","permalink":"http://dudri63.github.io/2019/01/29/algo22/","excerpt":"","text":"1. 배낭 문제2. 알고리즘3. 시간 복잡도 1. 배낭 문제 배낭 문제(Knapsack)는 n개의 물건과 각 물건 i의 무게 wi와 가치 vi가 주어지고, 배낭의 용량이 C일 때, 배낭에 담을 수 있는 물건의 최대 가치를 찾는 문제이다.단, 배나에 담은 물건의 무게의 합이 C를 초과하지 말아야 하고, 각 물건은 1개씩만 있다. 이러한 배낭 문제를 0-1 배낭 문제라고 하는데, 이는 각 물건이 담기지 않은 경우 ‘0’, 담긴 경우 ‘1’로 간주하기 때문이다. 배낭 문제는 제한적입 입력에 대해서 동적 계획 알고리즘으로 풀 수 있다.배낭 문제의 부분 문제를 정의하기 위해서 물건, 물건의 무게, 물건의 가치, 배낭의 용량, 4가지의 요소를 고려할 수 있다. 배낭 문제의 부분문제의 정의를 위해 물건은 하나씩 차례로 고려하면 되지만, 물건의 무게는 각각 다를 수 있기 때문에, 무게에 대해서는 배낭의 용량 0(kg)으로부터 1(kg)씩 증가하여 입력으로 주어진 용량 C가 될 때까지 변화시켜 가며 물건을 배낭에 담는 것이 가치가 더 커지는지를 결정해야 한다. 따라서 배낭 용량이 0부터 1씩 증가할 경우의 용량을 ‘임시’ 배낭 용량이라고 한다.따라서 배낭 문제의 부분문제를 다음과 같이 정의할 수 있다. K[i,w] = 물건 1~i까지만 고려하고, (임시) 배낭 용량이 w일 때의 최대 가치단, i - 1, 2, …, n, w = 1, 2, 3, …, C이다. 문제의 최적해는 K[n,C]이다. 2. 알고리즘 다음은 배낭 문제의 동적 계획 알고리즘이다. 2차원 배열 K가 최대 가치를 저장하는 데 사용된다. 1234567891011121314Knapsack입력: 배낭의 용량 C, n개의 물건, 각 물건 i의 무게 wi, 가치 vi, 단, i = 1,2,3,...,n출력: K[n,C]for i = 0 to n K[i,0]=0 // 배낭의 용량이 0일 때 총 가치 0으로 초기화for w = 0 to C K[0,w]=0 // 배낭에 아무것도 담기지 않았을 때 총 가치 0으로 초기화for i = 1 to n &#123; for w = 1 to C &#123; if (wi &gt; w) // 물건 i의 무게가 임시 배낭의 용량을 초과하면 K[i,w] = K[i-1,w] else // 물건 i를 배낭에 담지 않을 경우와 담을 경우를 고려 K[i,w] = max&#123;K[i-1,w], K[i-1,w-wi]+vi&#125; &#125;&#125;return K[n,C] Line 8~9 : 현재 배낭에 담으려고 고려하는 물건 i의 무게 wi가 임시 배낭의 무게 w보다 크면 배낭에 담을 수 없다. 따라서 K[i,w]는 물건 (i-1)까지 담은 K[i-1,w]가 된다. Line 10~11 : 고려하는 물건 i의 무게 wi가 임시 배낭의 무게 w보다 같거나 작으면, 물건 i를 배낭에 담을 수 있다. 그러나 배낭에서 물건 i를 담을 공간을 마련하는 작업을 고려하여야 한다.(배낭의 무게가 부족할 경우) 즉, 물건 i를 배낭에 담기 위해서는 2가지 경우를 살펴보아야 한다. 1) 물건 i를 배낭에 담을 수 없는 경우, K[i,w] = K[i-1,w]2) 물건 i를 배낭에 담을 수 있는 경우, K[i,w] = max{K[i-1,w],K[i-1,w-wi]+vi}, 기존 물건을 빼고 물건 i를 담거나, 물건 i를 담지 않거나, 기존 물건들은 배낭에 냅둔 체 물건 i를 새롭게 담는 경우로서 3가지 경우를 망라한다. 배낭의 용량이 C=10kg, 각 물건의 무게와 가치가 다음과 같을 때 위 알고리즘이 적용되는 것을 본다. Line 3~4 : 0번 행과 0번 열의 각 원소를 ‘0’으로 초기화한다. Line 5 : 물건을 하나씩 고려하기 위해 물건 번호 i가 1~4까지 변화Line 6 : 배낭의 임시 용량 w가 1씩 증가하여 마지막엔 10kg이 된다. i = 1일 때, w = 1일 때, 물건 1을 배낭에 담으려고 한다. 그러나 w1=5 &gt; w=1, K[1,1] = K[1-1,1] = 0 w = 2, 3, 4일 때, w1 &gt; w, K[1,2]=K[1,3]=K[1,4]=0 w = 5일 때, w1 = w = 5,K[1,5] = max{K[i-1,w], K[i-1,w-wi]+vi} = max{K[0,5], K[0,0] + 10} = max{0, 10} = 10 w = 6, 7, 8, 9, 10일 때, w = 5일 때와 같다. K[1,6] = K[1,7] = K[1,8] = K[1,9] = K[1,10] = 10이다. i = 2일 때, 물건 1에 대한 부분문제들의 해는 구한 상태, 이를 이용하여 물건 2를 고려한다. w = 1, 2, 3일 때, 물건 2를 배낭에 담으려고 한다. 그러나 w2=4 &gt; w, K[2,1] = K[2,2] = K[2,3] = 0 w = 4일 때, 물건 2를 배낭에 담을 수 있다.K[2,4] = max{K[i-1,w], K[i-1,w-wi]+vi} = max{K[1,4], K[1,0]+40} = max{0, 40} = 40 w = 5일 때, 물건 2를 배낭에 담을 수 있다. 그러나 물건 1이 배낭에 담았을 때의 가치와 물건 2를 담았을 때의 가치를 비교하여, 더 큰 가치를 얻는 물건을 배낭에 담는다.K[2,5] = max{K[i-1,w], K[i-1,w-wi]+vi} = max{K[1,5], K[1,1]+40} = max{10,40} = 40물건 1을 배낭에서 뺀 후, 물건 2를 담는 것의 가치가 더 높으므로 물건 2를 담는다. w = 6, 7, 8일 때, 물건 1을 빼내고 물건 2를 담는 것이 더 큰 가치를 얻는다. K[2,6] = K[2,7] = K[2,8] = 40 w = 9일 때, 물건 2를 배낭에 담을 수 있다.K[2,9] = max{K[i-1,w], K[i-1,w-wi&lt;/sub]&gt;+vi} = max{10,50} = 50배낭에 물건 1,2를 모두 담을 수 있고, 그때 가치가 50이 된다. w = 10일 때, w = 9일 때와 마찬가지로 물건 1,2를 모두 담을 수 있고, K[2,10] = 50이 된다. i = 3, 4일 때 알고리즘 수행 결과는 다음과 같다. 최적해는 물건 2와 4의 가치의 합인 90이다. 3. 시간 복잡도 Knapsack 알고리즘은 line 8에서 무게를 한번 비교한 후 line 9에서 1개의 부분문제의 해를 참조 line 11에서 2개희 해를 참조한 계산이므로 O(1) 시간이 걸린다. 그런데, 부분문제의 수는 원소 수인 n*C이므로, 시간복잡도는 O(1)*n*C = O(nC)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 편집 거리 문제 (동적계획)","slug":"algo21","date":"2019-01-29T05:32:05.000Z","updated":"2019-02-16T07:42:22.699Z","comments":true,"path":"2019/01/29/algo21/","link":"","permalink":"http://dudri63.github.io/2019/01/29/algo21/","excerpt":"","text":"1. 편집 거리 문제2. 알고리즘3. 시간 복잡도 1.편집 거리 문제 문서 편집기를 사용하는 중에 하나의 문자열을 수정하여 다른 문자열로 변환시키고자 할 때, 삽입(insert), 삭제(delete), 대체(substitute) 연산이 사용된다. 예를 들어, A를 B로 변환시키는 데 필요한 최소의 편집 연산 횟수를 편집 거리(Edit Distance)라고 한다. 편집 거리 문제는 편집 거리를 찾는 문제이다. 예를 들어, ‘strong’을 ‘stone’으로 편집하는 과정을 본다. ‘s’, ‘t’는 그대로 사용, ‘o’를 삽입, ‘r’, ‘o’를 삭제, ‘n’을 그대로 사용, ‘g’를 ‘e’로 대체한다.이 경우, 총 4회의 편집 연산이 수행되었다.(삽입 1회, 삭제 2회, 대체 1회) 반면에 위 경우, ‘r’ 삭제, ‘g’를 ‘e’로 대체, 단 2회의 편집 연산을 수행하였다. 이처럼 문자를 편집할 때, 어떤 연산을 어느 문자에 수행하느냐에 따라서 편집 연산 횟수가 달라진다. 부분 문제를 정의하기 위하여 스트링 S, T를 위와 같이 지정하고, 길이를 각각 m, n이라고 한다. 그리고 각각의 문자를 si,ti이라 한다. E[i,j]는 S의 접두부의 i개 문자를 T의 접두부 j개 문자로 변환시키는 데 필요한 최소 편집 연산 횟수, 즉 편집 거리이다.예를 들어, ‘strong’의 접두부는 ‘stro’이므로 i = 4, ‘stone’의 접두부는 ‘sto’이므로 j = 3인데, 각 문자열의 접두부를 바꾸기 위한 편집 거리를 찾는 문제는 E[i,j] = E[4,3]이다.E[4,3]을 점진적으로 E[6,5]를 해결하면 문제의 해를 찾을 수 있다. s1 -&gt; t1 부분문제 : E[1,1] = 0 S1 -&gt; t1t2 부분문제 : E[1,2] = 1, ‘s’를 ‘st’로 편집, ‘t’ 삽입 1회 연산 s1s2 -&gt; t1 부분문제 : E[2,1] = 1, ‘st’를 ‘s’로 편집, ‘t’ 삭제 1회 연산 s1s2 -&gt; t1t2 부분문제 : E[2,2] = 0 이 때, 부분문제 s1s2s3s4 -&gt; t1t2t3 : E[4,3], ‘stro’를 ‘sto’로 편집은 어떻게 계산하는가? E[4,2] (부분문제 s1s2s3s4 -&gt; t1t2)를 알면, t3 = ‘o’를 삽입하면 된다. 그러므로 E[4,3] = E[4,2] + 1이다. E[3,3] (부분문제 s1s2s3 -&gt; t1t2t3)를 알면, s4 = ‘o’를 삭제하면 된다. 그러므로 E[4,3] = E[3,3] + 1이다. E[3,2] (부분문제 s1s2s3 -&gt; t1t2)를 알면, s4 -&gt; t3로 편집하는데 필요한 연산을 계산하면 도니다. 그러나 이 경우, 2개의 문자가 ‘o’로 같으므로 편집할 필요가 없다. 그러므로 E[4,3] = E[3,2]이다. 따라서 E[4,3]의 편집 거리를 계산하려면 앞의 3가지 부분문제의 해, 즉, E[4,2], E[3,3], E[3,2]의 편집 거리를 알아야 한다. 그런데 이 경우, (2+1), (1+1), 1 중에서 최솟값인 1이 E[4,3]의 편집 거리가 된다. 일반적으로 E[i-1,j], E[i,j-1], E[i-1,j-1]의 해가 미리 계산되어 있으면 E[i,j]를 계산할 수 있다. 그러므로 편집 거리 문제의 부분문제 간의 함축적인 순서는 다음과 같다. 위 E[4,3] 예제와 비교하면, 위 그림이 의미하는 바는 금방 파악된다.세 가지 경우 중 가장 적은 값을 E[i,j]의 해로서 선택한다.E[i,j] = min{E[i,j-1]+1, E[i-1,j]+1, E[i-1,j-1]+a} 단, if si=tj a=0, else a=1 위 식을 위해, E[0,0], E[1,0], … , E[m,0]과 E[0,1], E[0,2], … , E[0,n]을 다음과 같이 초기화한다. ε = (공 문자열)공 문자열에서 문자열이 하나씩 추가되는 것이므로 삽입 연산에 의해 1씩 증가하는 것은 자명한 사실이다.**2. 알고리즘다음은 편집 거리 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 2차원 배열 E는 편집 거리를 저장하는 데 사용된다.123456789EditDistance입력: 스트링 S,T, 단, S와 T의 길이는 각각 m,n이다.출력: S를 T로 변환하는 편집 거리, E[m,n]for i=0 to m E[i,0]=i // 0번 열의 초기화for j=0 to n E[0,j]=j // 0번 행의 초기화for i=1 to m for j=1 to n E[i,j] = min&#123;E[i,jj-1]+1, E[i-1,j]+1, E[i-1,j-1]+a&#125;return E[m,n] 위 그림은 EditDistance 알고리즘이 ‘strong’을 ‘stone’으로 바꾸는 데 필요한 거리를 계산한 결과인 배열 E이다.a = 0 or a = 1인 경우에 유의하여 9시, 11시, 12시 방향에서 가장 작은 값을 푸른색 배경의 셀에 넣으면서 나아가면 된다. 3. 시간 복잡도 EditDistance 알고리즘의 시간복잡도는 O(mn)이다. 총 부분문제의 수가 m*n이고, 각 부분문제를 해결하기 위해서 주위의 3개의 부분문제들의 해를 참조한 후 최솟값을 찾는 것이므로 O(1) 시간이 걸리기 때문이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Python] 함수, 모듈","slug":"python7","date":"2019-01-28T15:08:23.000Z","updated":"2019-02-16T07:47:16.214Z","comments":true,"path":"2019/01/29/python7/","link":"","permalink":"http://dudri63.github.io/2019/01/29/python7/","excerpt":"","text":"1. 함수2. 모듈 1. 함수 함수란 믹서기와 같다. 입력값을 가지고 어떤 일을 수핸한 다음에 그 결과물을 내놓는 역할을 한다.예를 들어 y = 4x + 5도 함수이다. 프로그래밍을 하다 보면 똑같은 내용을 반복해서 작성할 수 있다. 이 때, 함수를 사용하면 유용하다.또한, 프로그램을 함수화하면 프로그램의 흐름을 일목요연하게 볼 수 있다. 이 경우, 에러가 발생 시에도 어디서 발생하였는지 금방 알 수 있다. 123def a3(): # 함수 a3() 정의 print(&apos;aaa&apos;)a3() def : 함수를 정의한다. 123def a3(): return &apos;aaa&apos;print(a3()) 123def a(num): return &apos;a&apos;*numprint(a(3)) 123def make_string(str, num): return str*numprint(make_string(&apos;b&apos;, 3)) 1234567891011input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)def login(_id): members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;] for member in members: if member == _id: return True return Falseif login(input_id): print(&apos;Hello, &apos;+input_id)else: print(&apos;Who are you?&apos;) 2. 모듈 모듈이란 함수나 변수 또는 클래스들을 모아놓은 파일이다.또한, 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.다른 사람들이 이미 만들어놓은 모듈을 사용할 수도 있고, 직접 만들어서 사용할 수도 있다. 1234import mathprint(math.ceil(2.9))print(math.floor(2.9))print(math.sqrt(16)) math 모듈은 여러가지 수학 관련 함수를 담고 있는 모듈이다. ceil(x) : x를 가까운 정수까지 반올림한 뒤 반환floor(x) : x를 가까운 정수까지 버림한 뒤 반환sqrt(x) : x의 제곱근을 반환 egoing.py123456def a(): return &apos;a&apos;def b(): return &apos;b&apos;def c(): return &apos;c&apos; k8805.py12def a(): return &apos;B&apos; 6.py1234from egoing import a as zimport k8805 as kprint(z())print(k.a()) egoing 모듈로부터 모듈함수를 import할 수 있다. 이 경우, 모듈이름을 붙이지 않고 바로 해당 모듈의 함수를 사용할 수 있다.또한, 모듈을 import할 경우, 해당 모듈 함수를 사용하기 위해서는 모듈이름을 붙여야 한다. auth.py123456def login(_id): members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;] for member in members: if member == _id: return True return False 6.py123456import authinput_id = input(&quot;아이디를 입력해주세요.\\n&quot;)if auth.login(input_id): print(&apos;Hello, &apos;+input_id)else: print(&apos;Who are you?&apos;) Reference ‘04-1 함수’, 점프 투 파이썬, 2019. 1. 29, https://wikidocs.net/24#_1 ‘05-5 내장 함수’, 점프 투 파이썬, 2019. 1. 29, https://wikidocs.net/32#len ‘[파이썬]공통함수,수학(math) 함수’, andamiro25, 2019. 1. 29, https://andamiro25.tistory.com/","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 반복문","slug":"python6","date":"2019-01-28T14:46:58.000Z","updated":"2019-02-16T07:47:10.307Z","comments":true,"path":"2019/01/28/python6/","link":"","permalink":"http://dudri63.github.io/2019/01/28/python6/","excerpt":"","text":"1. 반복문, while2. 컨테이너와 반복문3. for 1. 반복문, while 1.1 반복문이 없다면 12345678910print(&quot;Hello world 0&quot;)print(&quot;Hello world 9&quot;)print(&quot;Hello world 18&quot;)print(&quot;Hello world 27&quot;)print(&quot;Hello world 36&quot;)print(&quot;Hello world 45&quot;)print(&quot;Hello world 54&quot;)print(&quot;Hello world 63&quot;)print(&quot;Hello world 72&quot;)print(&quot;Hello world 81&quot;) 1.2 while 123while False: print(&apos;Hello world&apos;)print(&apos;After while&apos;) 1234i = 0while i &lt; 3: print(&apos;Hello world&apos;) i = i + 1 1234i = 0while i &lt; 10: print(&apos;print(&quot;Hello world &apos;+str(i*9)+&apos;&quot;)&apos;) i = i + 1 str() : 숫자를 문자열로 변환하는 함수 12345i = 0while i &lt; 10: if i == 4: print(i) i = i + 1 1234567i = 0while i &lt; 10: if i == 4: break print(i) i = i + 1print(&apos;after while&apos;) 2. 컨테이너와 반복문 12345members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]i = 0while i &lt; len(members): print(members[i]) i = i + 1 3. for 123members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]for member in members: print(member) 12for item in range(5, 11): print(item) 12345678input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]for member in members: if member == input_id: print(&apos;Hello!, &apos;+member) import sys sys.exit()print(&apos;Who are you?&apos;) Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 28, https://opentutorials.org/course/1750/9621, https://opentutorials.org/course/1750/9874","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Algorithm] 연속 행렬 곱셈 (동적계획)","slug":"algo20","date":"2019-01-28T07:59:17.000Z","updated":"2019-02-16T07:42:17.235Z","comments":true,"path":"2019/01/28/algo20/","link":"","permalink":"http://dudri63.github.io/2019/01/28/algo20/","excerpt":"","text":"1. 연속 행렬 곱셉 (Chained Matrix Multiplications)2. 알고리즘3. 시간 복잡도 1. 연속 행렬 곱셉 (Chained Matrix Multiplications) 연속 행렬 곱셉 (Chained Matrix Multiplications) 문제는 연속된 행렬들의 곱셉에 필요한 원소 간의 최소 곱셉 횟수를 찾는 문제이다. 예를 들어, 위와 같은 두 개의 행렬을 곱하는 경우, 10*20 행렬 A와 20*5 행렬 B를 곱하는데 원소간의 곱셈 횟수는 10*20*5 = 1000이다. 그리고 두 행렬을 곱한 결과 행렬 C는 10*5이다. 또 다른 예시로, 세 개의 행렬을 곱하는 경우를 고려한다.행렬의 곱셈에서는 결합법칙이 허용됨을 기억한다. A*B*C = (A*B)*C = A*(B*C) A*B를 먼저 계산한 후에 그 결과 행렬과 행렬 C를 곱하는 경우, 곱셈 횟수는 다음과 같다.A*B = 10*20*5 = 1000, AB*C = 10*5*15 = 750총 1000 + 750 = 1750회의 원소의 곱셈이 필요하다. B*C를 먼저 계산한 후에 그 결과 행렬과 행렬 A를 곱하는 경우, 곱셈 횟수는 다음과 같다.B*C = 20*5*15 = 1500, A*BC = 10*20*15 = 3000총 1500 + 3000 = 4500회의 원소의 곱셈이 필요하다. 동일한 결과를 얻음에도 불구하고 원소 간의 곱셈 횟수가 차이가 난다. 따라서 연속 행렬을 곱하는 데 필요한 원소 간의 곱셈 횟수를 최소화시키기 위한 적절한 곱셈 순서를 찾아야 한다. 연속 행렬 곱셈 문제는 대표적인 동적 계획 알고리즘 문제이다.단, 이웃하는 행렬끼리 먼저 곱해야 하는 특징 때문에 비교적 간단하게 해결할 수 있다. 행렬 A, B, C, D, E를 곱하는데 다음과 같은 부분 문제가 만들어진다. 부분 문제들이 겹쳐있다는 것이 중요하다. 크기가 3인 부분문제가 3인 경우도 서로 이웃하는 부분문제들끼리 겹쳐 있음을 알 수 있다. 마지막 부분문제의 갯수가 1개인 경우는 주어진 문제로서 입력이다. 2. 알고리즘 다음은 연속 행렬 곱셈을 위한 동적 계획 알고리즘이다.단, 원소 간의 최소 곱셈 횟수를 C[i,j]에 저장한다.1234567891011121314151617MatrixChain입력: 연속된 행렬 A1\\*A2\\*...\\*An,출력: 입력의 행렬 곱셈에 필요한 원소 간의 최소 곱셈 횟수for i = 1 to n C[i,i] = 0for L = 1 to n-1 &#123; //L은 부분문제의 크기를 조절하는 인덱스 for i = 1 to n-L &#123; j = i + L C[i,j] = ∞ for k = i to j-1 &#123; temp = C[i,k] + C[k+1,j] + d(i-1)dkdj if (temp &lt; C[i,j]) C[i,j] = temp &#125; &#125;&#125;return C[1,n] A1 : 10*20, A2 : 20*5, A3 : 5*15, A4 : 15*30일 때, MatrixChain 알고리즘 수행 과정은 다음과 같다. Line 4~5 : C[1,1] = C[2,2] = C[3,3], C[4,4] = 0으로 초기화 Line 6 : L이 1부터 n-1 = 4-1 = 3까지 변하고, 각각의 L값에 대해, i가 변화, C[i,j]를 계산 L = 1일 때, i는 1부터 n-L = 4-1 = 3까지 변한다. i = 1이면, j = i+L = 1+1 = 2, C[1,2] = ∞,temp = C[1,1] + C[2,2] + d0d1d2 = 0 + 0 + (10*20*5) = 1000temp = 1000 &lt; C[1,2] = ∞, C[1,2] = 1000 i = 2이면, j = i+L = 2+1 = 3, C[2,3] = ∞temp = C[2,2] + C[3,3] + d1d2d3 = 0 + 0 + (20*5*15) = 1500temp = 1500 &lt; C[2,3] = ∞, C[2,3] = 1500 i = 3이면, j = i+L = 3+1 = 4, C[3,4] = ∞temp = C[3,3] + C[4,4] + d2d3d4 = 0 + 0 + (5*15*30) = 2250temp = 2250 &lt; C[3,4] = ∞, C[3,4] = 2250 A1 * A2 = 1000, A2 * A3 = 1500, A3 * A4 = 2250 L = 2일 때, i는 1부터 n-L = 4-2 = 2까지 변한다. i = 1이면, j = i+L = 1+2 = 3, C[1,3] = ∞ k = 1일 때, temp = C[1,1] + C[2,3] + d0d1d3 = 0 + 1500 + (10*20*15) = 4500temp = 4500 &lt; C[1,3] = ∞, C[1,3] = 4500A2*A3 = 1500, A1*A2A3 = 3000 + 1500 k = 2일 때, temp = C[1,2] + C[3,3] + d0d2d3 = 1000 + 0 + (10*5*15) = 1750temp = 1750 &lt; C[1,3] = 4500, C[1,3] 1750A1*A2 = 1000, A1A2*A3 = 1000 + 750 i =2이면, j = i+L = 2+2 = 4, C[2,4] = ∞ k = 2일 때, temp = C[2,2] + C[3,4] + d1d2d4 = 0 + 2250 + (20*5*30) = 5250temp = 5250 &lt; C[2,4] = ∞, C[2,4] = 5250A3*A4 = 2250, A2*A3A4 = 3000 + 2250 k = 3일 때, temp = C[2,3] + C[4,4] + d1d3d4 = 1500 + 0 + (20*15*30) = 10500temp = 10500 &gt; C[2,4] = 2250, C[2,4] = 5250A2*A3 = 1500, A2A3*A4 = 9000 + 1500 L = 3일 때, i는 1부터 n-L = 4-3 = 1까지 변한다.(i=1일때만 수행) i = 1이면, j = i+L = 1+3 = 4, C[1,4] = ∞ k = 1일 때, temp = C[1,1] + C[2,4] = d0d1d4 = 0 + 5250 + (10*20*30) = 11250temp = 11250 &lt; C[1,4] = ∞, C[1,4] = 11250A2*A3*A4 = 5250, A1*A2A3A4 = 6000 k = 2일 때, temp = C[1,2] + C[3,4] = d0d2d4 = 1000 + 2250 + (10*5*30) = 4750temp = 4750 &lt; C[1,4] = ∞, C[1,4] = 4750A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1000 + 1500 + 2250 = 4750 k = 3일 때, temp = C[1,3] + C[4,4] = d0d3d4 = 1750 + 0 + (10*15*30) = 6250temp = 6250 &gt; C[1,4] = 4750, C[1,4] = 4750A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1750 + 4500 = 6250 C[1,4]= 4750을 반환 3. 시간복잡도 3중 for문 -&gt; O(n3) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Python] 컨테이너, 리스트","slug":"python5","date":"2019-01-27T10:12:22.000Z","updated":"2019-02-16T07:47:04.836Z","comments":true,"path":"2019/01/27/python5/","link":"","permalink":"http://dudri63.github.io/2019/01/27/python5/","excerpt":"","text":"1. 컨테이너2. 리스트 1. 컨테이너 변수는 컨테이너와 비슷하다. ex. name = ‘seo’ 와 같이 값을 대입할 수 있다.위 예에서 볼 수 있듯이 변수는 ‘하나의 값을 담는 그릇’과 같다. 하나의 그릇에 여러 개의 값을 담을 수는 없을까?-&gt; 컨테이너라는 것을 만들어서 각각의 값을 담을 수 있다. 위 그림은 컨테이너의 개념을 파악하는 데 유용하다.하나의 그릇에 세 개의 값(‘Egoing’, ‘Leezche’, ‘Graphittie’)을 담았다. 또한, 그릇데 담긴 값들은 각각 0, 1, 2라는 번호가 부여된다.또한, 컨테이너를 다시 변수에 담을 수 있다. 그리하여 변수의 이름을 통해 컨테이너에 접근할 수 있다. 컨테이너란 포괄적인 개념이며, 파이썬에서는 보통 ‘리스트(list)’로 지칭한다. 2. 리스트 리스트란 “0개 이상의 값의 원소들의 순서있는 집합”이다. 즉, 일종의 집합이나 컨테이너의 형태로 그 내부에 여러 개의 값을 원소로 가질 수 있으며 다른 언어에서는 배열 혹은 벡터로 불리는 타입과 비슷하다.리스트는 순서있는 집합이므로 각 원소는 리스트 내부에서 고유한 순서를 가지고 있는데, 이 순서를 인덱스라고 한다. 12345678910print(type(&apos;egoing&apos;)) # &apos;egoing&apos;의 타입(stirng)을 출력name = &apos;egoing&apos;print(name) # 변수 name에 담긴 것을 출력print(type([&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;])) # [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]의 타입(list)을 출력names = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;] # 변수 name에 list를 담음print(names) print(names[2]) # 변수 name의 2번을 출력egoing = [&apos;programmer&apos;, &apos;seoul&apos;, 25, False] # list 생성 및 변수 name에 담음egoing[1] = &apos;busan&apos; # egoing의 1번을 변경print(egoing) # [&apos;programmer&apos;, &apos;busan&apos;, 25, False] 123456al = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;] # list al 생성print(len(al)) # al의 전체 요소 개수를 반환al.append(&apos;E&apos;) # al list에 &apos;E&apos;를 추가print(al) # [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]del(al[0]) # al list의 0번을 제거print(al) # [&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;] len() : 입력값의 길이 또는 요소의 전체 개수를 반환하는 함수.append() : 리스트에 요소를 추가하는 함수.del() : 리스트의 요소를 삭제하는 함수.ex. del a[1] : a list의 1번을 삭제 del a[1:] : a list의 1번부터 삭제(여러개의 요소를 한꺼번에 삭제) Reference (연재) 파이썬은 처음이라 - 리스트는 처음이라, Wireframe-숩은 아직 20대, 2019. 1 .27, https://soooprmx.com/archives/8824 “Python &amp; Ruby”, 생활코딩, 2019. 1. 27, https://opentutorials.org/course/1750/9681, https://opentutorials.org/course/1750/9619, https://opentutorials.org/course/1750/9626","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Algorithm] 모든 쌍 최단 경로 (동적계획)","slug":"algo19","date":"2019-01-26T16:04:54.000Z","updated":"2019-02-16T07:42:11.921Z","comments":true,"path":"2019/01/27/algo19/","link":"","permalink":"http://dudri63.github.io/2019/01/27/algo19/","excerpt":"","text":"1. 모든 쌍 최단 경로 (All Pairs Shortest Paths)2. 플로이드-워셜(Floyd-Warshall) 알고리즘3. 시간 복잡도 1. 모든 쌍 최단 경로(All Pairs Shortest Paths) 모든 쌍 최단 경로(All Pairs Shortest Paths) 문제는 각 쌍의 점 사이의 최단 경로를 찾는 문제이다.이 문제를 해결하려면, 각 점을 시작점으로 다익스트라 알고리즘을 수행하면 된다.이 때, 시간 복잡도는 (n-1)*O(n2) = O(n3)이다. 모든 쌍 최단 경로를 찾는 동적 계획 알고리즘을 플로이드-워셜(Floyd-Warshall) 알고리즘이라고 한다.(이하, 플로이도 알고리즘)플로이드 알고리즘의 시간복잡도는 O(n3)으로 다익스트라 알고리즘을 (n-1)번 사용할 때의 시간복잡도와 동일하다.그러나 플로이드 알고리즘은 매우 간단하다는 장점이 있다. 동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면 먼저 부분문제들을 찾아야 한다. 그래프에 3개의 점이 있는 경우,점 i에서 점 j까지의 최단 경로를 찾으려면 2가지 경로, 점 j로 직접 가능 경로와 1을 경유하는 경로 중에서 짧은 것을 선택. 다른 아이디어는 경유 가능한 점들을 점 1로부터 시작하여, 점 1과 2, 그 다음에는 점 1,2,3으로 하나씩 추가, 마지막에는 점 1에서 점 n까지의 모든 점을 경유 가능한 점들로 고려, 모든 쌍의 최단 경로의 거리를 계산하는 것이다. 위 아이디어를 이용하면 부분문제들을 만들 수 있다. Dijk = 점 {1,2,…,k}만을 경유하는 점들로 고려, 점 i로부터 점 j까지의 모든 경로 중에서 가장 짧은 경로의 거리(단, 점 1에서 k까지의 모든 점들을 반드시 경유하는 경로를 의미하는 것은 아님) Dij1은 i에서 점 1을 경유하여 j로 가는 경로, i에서 j로 직접 가는 경로, 즉 선분 (i,j) 중에서 짧은 거리이다. 단, i≠1, j≠1 i에서 점 2를 경유하여 j로 가는 경로의 거리와 Dij1 중에서 짧은 거리를 Dij2로 정한다. 단, 점 2를 경유하는 경로의 거리는 Di21 + D2j1 이다. 단, i≠2, j≠2 … i에서 점 k를 경유하여 j로 가는 경로의 거리와 Dijk-1 중에서 짧은 것을 Dijk로 정한다. 단, 점 k를 경유하는 경로의 거리는 Dikk-1+Dkjk-1이다. 단, i≠k, j≠k 이런 방식으로 k가 1에서 n이 될 때까지 Dijk를 계산해서 모든 점을 경유 가능한 점들로 고려된 모든 쌍 i와 j의 최단 경로의 거리를 찾는 방식이 플로이드의 모든 쌍 최단 경로 알고리즘이다. 2. 플로이드 알고리즘 1234567AllPairsShortest입력: 2차원 배열 D, 단, D[i,j] = 선분 (i,j)의 가중치, 만일 선분 (i,j)이 존재하지 않으면 D[i,j] = ∞, 모든 i에 대해 D[i,j]=0이다.출력: 모든 쌍 최단 경로의 거리를 저장한 2차원 배열 Dfor k = 1 to n for i = 1 to n (단, i≠k) for j = 1 to n (단, j≠k, j≠i) D[i,j] = min&#123;D[i,k]+D[k,j],D[i,j]&#125; 배열 D의 원소들이 k가 1부터 5까지 증가함에 따라서 갱신되는 것을 살펴본다. k = 1일 때 : D[2,3] = min{D[2,1]+D[1,3], D[2,3]} = min{∞+2,1} = 1 D[2,4] = min{D[2,1]+D[1,4], D[2,4]} = min{∞+5,∞} = ∞ D[2,5] = min{D[2,1]+D[1,5], D[2,5]} = min{4,∞+∞} = 4 D[3,2] = min{D[3,1]+D[1,2], D[3,2]} = min{1+4,3} = 3 D[3,4] = min{D[3,1]+D[1,4], D[3,4]} = min{1+5,1} = 1 D[3,5] = min{D[3,1]+D[1,5], D[3,5]} = min{1+∞,2} = 2 D[4,2] = min{D[4,1]+D[1,2], D[4,2]} = min{-2+4,∞} = 2 // 갱신됨 (∞-&gt;2) D[4,3] = min{D[4,1]+D[1,3], D[4,3]} = min{-2+2,∞} = 0 // 갱신됨 (∞-&gt;0) D[4,5] = min{D[4,1]+D[1,5], D[4,5]} = min{-2+∞,2} = 2 D[5,2] = min{D[5,1]+D[1,2], D[5,2]} = min{∞+4,-3} = -3 D[5,3] = min{D[5,1]+D[1,3], D[5,3]} = min{∞+2,3} = 3 D[5,4] = min{D[5,1]+D[1,4], D[5,4]} = min{∞+5,1} = 1 즉, 모든 i,j에 대한 Dij1을 계산한 결과는 다음과 같다. k = 2일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij2을 계산한 결과는 다음과 같다. k = 3일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij3을 계산한 결과는 다음과 같다. k = 4일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij4를 계산한 결과는 다음과 같다. k = 5일 때 : (계산 과정 생략) 모든 i,j에 대한 Dij5를 계산한 결과는 다음과 같다. (최종 해) 3. 시간 복잡도 3중 for문 -&gt; O(n3)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 동적 계획 알고리즘","slug":"algo18","date":"2019-01-26T11:02:09.000Z","updated":"2019-02-16T07:42:07.188Z","comments":true,"path":"2019/01/26/algo18/","link":"","permalink":"http://dudri63.github.io/2019/01/26/algo18/","excerpt":"","text":"‘동적 계획(Dynamic Programming)’ 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 동적 계획 알고리즘은 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다. 단, 분할 정복 알고리즘과는 달리 부분문제의 해를 중복 사용하기도 한다. 동적계획 알고리즘에는 부분문제들 사이에 의존적 관계가 존재한다. 이러한 관계는 문제 또는 알고리즘에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 ‘함축적인 순서(implicit order)’라고 한다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"http://dudri63.github.io/tags/Dynamic-Programming/"}]},{"title":"[Algorithm] 허프만 압축 (그리디)","slug":"algo17","date":"2019-01-25T14:02:55.000Z","updated":"2019-02-16T07:42:02.242Z","comments":true,"path":"2019/01/25/algo17/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo17/","excerpt":"","text":"1. 허프만 압축2. 알고리즘3. 시간 복잡도 1. 허프만 압축 파일의 각 문자가 8bit 아스키(ASCII) 코드로 저장되면, 그 파일의 bit 수는 8 * (파일의 문자수)이다.즉, 파일의 각 문자는 고정된 크기의 코드로 표현된다.이러한 고정된 크기의 코드로 구성된 파일을 저장하거나 전송할 때 파일의 크기를 줄이고, 필요시 원래의 파일로 변환할 수 있으면,메모리 공간을 효율적으로 사용할 수 있고, 파일 전송 시간을 단축시킬 수 있다.주어진 파일의 크기를 줄이는 방법을 파일 압축(file compression)이라고 한다. 허프만(Huffman) 압축은 파일에 빈번히 나타나는 문자에는 짧은 이진 코드를 할당, 드물게 나타나는 문자에는 긴 이진 코드를 할당한다. 허프만 압축 방법으로 변환시킨 문자 코드들 사이에는 접두부 특성(Prefix Property)이 존재한다.이는 각 문자에 할당된 이진 코드는 어떤 다른 문자에 할당된 이진 코드의 접두부가 되지 않는다는 것을 의미.즉, 문자 ‘a’에 할당된 코드가 ‘101’이라면, 다른 모든 문자의 코드는 ‘101’로 시작되지 않으며 또한 ‘1’이나 ‘10’으로도 시작되지 않는다.접두부 특성을 가진 코드의 장점은 코드와 코드 사이를 구분할 특별한 코드가 필요 없다는 것이다.예를 들어. 101#100#0#111#…에서 ‘#’이 인접한 코드를 구분 짓는데, 허프만 압축에서는 이러한 특별한 코드가 필요 없이 파일을 압축 및 해제할 수 있다. 허프만 압축은 입력 파일에 대해 각 문자의 출현 빈도수에 기반을 둔 이진트리를 만든 뒤, 각 문자에 이진 코드를 할당한다. 이 때, 이 이진 코드를 허프만 코드라고 한다. 2. 알고리즘 다음은 파일 압축을 위한 허프만 코드를 찾기 위한 그리디 알고리즘이다.입력 파일에 대해 각 문자에 할당될 이진 코드를 추출할 이진 트리인 허프만 트리를 리턴한다.1234567891011HuffmanCoding입력: 입력 파일의 n개의 문자에 대한 각각의 빈도수출력: 허프만 트리각 문자에 대해 노드를 만들고, 그 문자의 빈도수를 노드에 저장한다.n개의 노드들의 빈도수에 대해 우선순위 큐 Q를 만든다.while (Q에 있는 노드 수 &gt;=2) &#123; 빈도수가 가장 작은 2개의 노드(A와 B)를 Q에서 제거한다. 새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다. 노드 N을 Q에 삽입한다.&#125;return Q // 허프만 트리의 루트를 리턴하는 것이다. 입력 파일이 4개의 문자로 구성되어 있고, 각 문자의 빈도수는 다음과 같다고 가정한다. A: 450 T: 90 G:120 C:270 Line 5 : 4개의 문자들의 빈도수에 대해 우선순위 Q를 만든다. Line 6 : while-루프 조건이 ‘참’이므로, Line 7~10을 수행한다.즉, Q에서 ‘T’와 ‘G’를 제거한 후, 새 부모 노드를 Q에 삽입한다. Line 6 : while-루프 조건 ‘참’, Line 7~10을 수행.즉, Q에서 ‘T’와 ‘G’의 ‘부모 노드’와 ‘C’를 제거한 후, 새 부모 노드를 Q에 삽입한다. Line 6 : while-루프 조건 ‘참’, Line 7~10을 수행.즉, Q에서 ‘c’의 ‘부모 노드’와 ‘A’를 제거한 후, 새 부모 노드를 Q에 삽입한다. Line 6 : while-루프 조건 ‘거짓’, Line 11에서 Q에 있는 노드를 리턴.즉, 허프만 트리의 루트가 리턴된다. 반환한 트리를 보면, 문자는 leaf 노드에만 존재한다.루트로부터 왼쪽 자식 노드로 내려가면 ‘0’, 오른쪽 자식 노드로 내려가면 ‘1’을 부여할 수 있다.그리하여 leaf 노드에 도착할 때까지 이진수를 추출, 문자의 이진코드를 구할 수 있다.빈도수가 가장 높은 ‘A’는 가장 짧은 코드인 ‘0’,빈도수가 가장 낮은 ‘T’는 가장 긴 코드인 ‘100’이 부여됐다.또한 이렇게 얻은 숫자에 대한 코드는 접두부 특성을 가지고 있다.(왜냐하면, leaf 노드에만 문자가 있고, 내부 노드에는 문자 없으며 코드를 부여하지 않았기 때문) 위 예제에서 압축된 파일의 bit 수는 (450*1)+(90*3)+(120*3)+(270*3) = 1620 bit이다.반면에 아스키 코드로 된 파일 크기는 (450+90+120+270)*8 = 7440 bit이다.압축률은 (1620/7440)*100 = 21.8%이다. 3. 시간 복잡도 line 4, n개의 노드생성, 각 빈도수를 노드에 저장, O(n)line 5, n개의 노드로 우선순위 큐 Q를 만듬. 힙 자료 구조 사용, O(n)line 6~10, 노드 2개를 Q에서 제거, 새 노드를 Q에 삽입하므로 O(long), while-루프는 (n-1)번 반복, (n-1)*O(logn) = O(nlogn)line 8, 트리의 루트를 리턴, O(1) 따라서 HuffmanCoding의 알고리즘은 O(nlogn) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 25, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 작업 스케줄링 (그리디)","slug":"algo16","date":"2019-01-25T13:56:10.000Z","updated":"2019-02-16T07:41:57.427Z","comments":true,"path":"2019/01/25/algo16/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo16/","excerpt":"","text":"1. 작업 스케줄링2. 알고리즘3. 시간 복잡도 1. 작업 스케줄링 기계에서 수행되는 n개의 작업 t1, t2, … tn이 있고, 각 작업은 시작시간과 종료시간이 있다.작업 스케줄링(Task Scheduling) 문제는 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정하는 문제이다. 작업 스케줄링 문제는 학술대회에서 발표자들을 강의실에 배정하는 문제와 같다. 작업 스케줄링 문제에 주어진 문제 요소들은 작업의 수, 각 작업의 시작시간과 종료시간이다.작업의 시작시간과 종료시간은 정해져 있으므로 작업의 길이도 주어진 것이다.그리하여 시작시간, 종료시간, 작업 길이에 대해 다음과 같은 그리디 알고리즘들을 생각할 수 있다. 빠른 시작시간 작업을 우선(Earliest start time first) 배정 빠른 종료시간 작업을 우선(Earliest finish time first) 배정 짧은 작업 우선(Shortest job first) 배정 긴 작업을 우선(Longest job first) 배정 위 4가지 알고리즘들 중 첫 번째 알고리즘을 제외, 나머지 3가지 알고리즘은 항상 최적해를 찾지 못한다.(추후 공부 필요) 2. 알고리즘 다음은 작업 스케줄링 문제를 위한 빠른 시작시간 작업을(Earilest start time first) 우선 배정하는 그리디 알고리즘이다. 12345678910111213JobScheduling입력: n개의 작업 t1, t2, ... , tn출력: 각 기계에 배정된 작업 순서시작시간의 오름차순으로 정렬한 작업 리스트를 L이라고 한다.while (L ≠ ∅) &#123; L에서 가장 이른 시작시간을 가진 작업 ti를 가져온다. if (ti를 수행할 기계가 있으면) ti를 수행할 수 있는 기계에 배정한다. else 새로운 기계에 ti를 배정한다. ti를 L에서 제거한다.&#125;return 각 기계에 배정된 작업 순서 t1 = [7,8],t2 = [3,7],t3 = [1,5],t4 = [5,9],t5 = [0,2],t6 = [6,8],t7 = [1,6]과 같은 작업 이 있다고 가정한다. 단, [s,f]에서 s는 시작시간, f는 종료시간이다. Line 4 : L = {[0,2], [1,6], [1,5], [3,7], [5,9], [6,8], [7,8]}이다. Line 5~11 : while-루프를 반복 수행하면서 각 작업이 적절한 기계에 배정된다. 이 경우 최적해는 3대의 기계에 모든 작업을 마지막 그림과 같이 배정하는 것이다. 3. 시간 복잡도 Line 4에서 n개의 작업을 정렬하는 데 O(nlogn) 시간이 걸린다.while-루프에서 작업을 L에서 가져다가 수행 가능한 기계를 찾아 배정하므로 O(m)이 걸린다.(m은 사용된 기계의 수)while-루프가 수행된 총 횟수는 n번이므로, line 5~12까지는 O(m)*n = O(mn) 시간이 걸린다.따라서 O(nlogn) + O(nm)이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 집합 커버 문제 (그리디)","slug":"algo15","date":"2019-01-25T12:24:18.000Z","updated":"2019-02-16T07:41:52.723Z","comments":true,"path":"2019/01/25/algo15/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo15/","excerpt":"","text":"1. 집합 커버 문제2. 알고리즘3. 시간 복잡도 1. 집합 커버 문제 n개의 원소를 가진 집합인 U가 있고, U의 부분 집합들을 원소로 하는 집합 F가 주어질 때, F의 원소들인 집합들 중에서 어떤 집합들을 선택하여 합집합하면 U와 같게 되는가?집합 커버(Set Cover) 문제는 F에서 선택하는 집합들의 수를 최소화하는 문제이다. 다음은 신도시를 계획함에 있어서 학교를 배치하는 문제이다. 위 그림과 같이 신도시에 10개의 마을이 만들어질 계획이다.이 때, 아래의 2가지 조건이 만족되도록 학교의 위치를 선정하여야 한다고 가정한다. 학교는 마을에 위치한다. 등교 거리는 걸어서 15분 이내여야 한다. 어느 마을에 학교를 신설해야 학교의 수가 최소로 될 것인가?2번 마을에 학교를 만들면 마을 1, 2, 3, 4, 8이 커버된다.또한, 6번 마을에 학교를 만들면 마을 5, 6, 7, 9, 10이 커버된다.즉, 2번과 6번을 선택하면 학교 수를 최소로 신설할 수 있다. 위 신도시 계획 문제를 집합 커버 문제로 변환하면 아래와 같다. U = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} // 신도시의 마을 10개F = {S1, S2, S3, S4, S5, S6, S7, S8, S9, S10}S1 = {1, 2, 3, 8}S2 = {1, 2, 3, 4, 8}S3 = {1, 2, 3, 4}S4 = {2, 3, 4, 8}S5 = {4, 5, 6, 7}S6 = {5, 6, 7, 9, 10}S7 = {4, 5, 6, 7}S8 = {1, 2, 4, 8}S9 = {6, 9}S10 = {6, 10} Si 집합들 중에서 어떤 집합들을 선택하여야 그들의 합집합이 U와 같은가?(단, 선택된 집합의 수는 최소이어야 한다.)답은 S2 ∪ S6 = {1, 2, 3, 4, 8} ∪ {5, 6, 7, 9, 10} = {1, 2, 3, 4, 5, 6, 7, 8, 9 10} = U 집합 커버 문제의 최적해를 찾는 가장 간단한 방법은 F에 있는 집합들의 모든 조합을 하나씩 합집합하여 U가 되는지 확인, U가 되는 조합의 집합 수가 최소인 것을 찾는 것이다.그런데 이 경우 F에 n개의 원소가 있으면 (2n-1)개를 다 검사, n이 커지면 최적해를 찾는 것은 실질적으로 불가능하다. 이를 극복하기 위한 방법은 최적해를 찾는 대신 최적해에 근사한 근사해(Approximation Solution)을 찾는 것이다. 2. 알고리즘 다음은 집합 커버 문제를 위한 근사 알고리즘이다. 12345678910SetCover입력: U, F=&#123;Si&#125;, i=1,2,...,n출력: 집합 커버 CC = ∅while (U ≠ ∅) do &#123; U의 원소들을 가장 많이 포함하고 있는 집합 Si를 F에서 선택한다. U = U - Si Si를 F에서 제거하고, Si를 C에 추가한다.&#125;return C 위 신도시 계획 문제에 이 알고리즘을 적용한다. Line 4 : C = ∅로 초기화한다. Line 5 : while-조건 (U ≠ ∅)을 만족한다. Line 6 : U의 원소들을 가장 많이 커버하는 집합인 S4를 F에서 선택한다. Line 7 : U - S4 = {1, 6, 9, 10} Line 8 : S4를 F에서 제거, 즉, F = {S1, S2, S3, S5, S6, S7, S8, S9, S10},S4를 C에 추가, 즉, C = {S4} Line 5 : while-조건 만족 Line 6 : U의 원소들을 가장 많이 커버하는 집합인 S6를 F에서 선택. Line 7 : U = S6 = {1] Line 8 : S6를 F에서 제거, F = {S1, S2, S3, S5, S7, S8, S9, S10},S6를 C에 추가, C = {S4, S6} Line 5 : while-조건 만족 Line 6 : U의 원소들을 가장 많이 커버하는 집합인 S1을 F에서 선택.(S2, S3, S8을 선택해도 무방) Line 7 : U = ∅ Line 8 : S1을 F에서 제거,S1을 C에 추가, C = {S1, S4, S6} Line 5 : while-조건 불만족 Line 9 : C={S1, S4, S6}를 리턴 3. 시간 복잡도 Line 5 : while-루프 조건 검사 시간 O(1)Line 6 : Si 각각을 U와 비교하여야 한다. Si들의 수가 최대 n이라면, O(n2) 시간Line 7 : 집합 U에서 집합 Si의 원소를 제거, O(n) 시간이 걸린다.Line 8 : Si를 F에서 제거, Si를 C에 추가, O(1) 시간이 걸린다.따라서 루프 1회의 시간 복잡도는 O(1)+O(n2)+O(n)+O(1) = O(n2)이다.그러므로 SetCover 알고리즘의 시간복잡도는 O(n)*O(n2) = O(n3) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 부분 배낭 문제 (그리디)","slug":"algo14","date":"2019-01-25T11:21:08.000Z","updated":"2019-02-16T07:41:47.597Z","comments":true,"path":"2019/01/25/algo14/","link":"","permalink":"http://dudri63.github.io/2019/01/25/algo14/","excerpt":"","text":"1. 부분 배낭 문제2. 알고리즘3. 시간 복잡도 1. 부분 배낭 문제 배낭(Knapsack) 문제는 n개의 물건이 있고, 각 물건은 무게와 가치를 가지고 있을 때, 최대의 가치를 갖도록 한정된 용량의 배낭에 넣을 물건들을 정하는 문제이다.원래의 배낭 문제는 물건을 통째로 배낭에 넣어야 하는 것에 반해,부분 배낭(Fractional Knapsack) 문제는 물건을 부분적으로 담는 것이 허용 된다. 부분 배낭 문제에서는 물건을 부분적으로 배낭에 담을 수 있으므로, 최적해을 위해서 ‘욕심을 내어’ 단위 무게당 가장 값나가는 물건을 배낭에 넣고, 계속해서 그 다음으로 값나가는 물건을 넣는다. 그런데 만일 그 다음으로 값나가는 물건을 ‘통째로’ 배낭에 넣을 수 없게 되면, 배낭에 넣을 수 있을 만큼만 물건을 부분적으로 배낭에 담도록 한다. 2. 알고리즘 다음은 부분 배낭 문제를 위한 그리디 알고리즘이다. 12345678910111213141516171819FractionalKnapsack입력: n개의 물건과 각 물건의 무게와 가치, 배낭의 용량 C출력: 배낭에 담은 물건 리스트 L과 배낭에 담은 물건의 가치 합 v각 물건의 단위 무게당 가치를 계산.물건들을 단위 무게당 가치를 기준으로 내림차순으로 정렬, 정렬된 물건 리스트를 S라고 한다.L=∅, w=0, v=0 // L: 배낭에 담을 물건 리스트, w: 배낭에 담긴 물건들의 무게의 합, v: 배낭에 담긴 물건들의 가치의 합S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다.while((w + x의 무게)&lt;=C)&#123; x를 L에 추가시킨다. w = w + x의 무게 v = v + x의 가치 x를 S에서 제거한다. S에서 단위 무게당 가치가 가장 큰 물건 x를 가져온다.&#125;if ((C-w) &gt; 0) &#123; // 배낭에 물건을 부분적으로 더 담을 여유가 있으면 물건 x를 (C-w)만큼만 L에 추가한다. v = v + (C-w)만큼의 x의 가치&#125;return L, v 위와 같은 4개의 금속 분말이 있고, 배낭의 최대 용량(C)이 40g이라고 가정한다.FractionalKnapsack 알고리즘의 수행 과정은 다음과 같다. Line 4 : 단위 무게당 가치, 주석 1천원, 백금 6만원, 은 4천원, 금 5만원 Line 5 : S = {백금,금,은,주석} Line 6 : L=∅, w=0, v=0로 각각 초기화한다. Line 7 : S에서 단위 무게당 가장 큰 물건인 백금을 x로서 가져온다. Line 8 : w + x의 무게 = 10g &lt; C = 40g 으로 while-문 조건을 만족한다. Line 9 : 백금 x를 L에 추가, L = {백금} Line 10 : w = 0 + 10g = 10g Line 11 : v = 0 + 60만원 = 60만원 Line 12 : S = {금,은,주석} Line 13 : S에서 금을 x로서 가져온다. Line 8 : w + x의 무게 = 10g + 15g &lt; C = 40g, while-문 조건 만족 Line 9 : L ={백금, 금} Line 10 : w = 10g + 15g = 25g Line 11 : v = 60만원 + 75만원 = 135만원 Line 12 : S = {은,주석} Line 13 : S에서 은을 x로서 가져온다. Line 8 : w + x의 무게 = 25g + 25g = 50g &gt; C = 40g, while-문 조건 만족X Line 15 : C-w = 40g - 25g = 15g &gt; 0, if-문 조건 만족 Line 16 : 물건 x인 은을 (C-w) = 15g만큼만 L에 추가, L = {백금,금,은} Line 17 : v = 135만원 + (C-w)만큼의 x의 가치 = 135만원 + 15X4천원 = 141만원 Line 19 : L = {백금, 금, 은}, v = 141만원 반환 3. 시간 복잡도 Line 4에서 n개의 물건 단위 무게당 가치를 계산하는 데 O(n) 시간이 걸림.Line 5에서 물건의 단위 무게당 가치에 대해 정렬하므로 O(nlogn) 시간이 걸림.Line 8~13의 while-루프의 수행은 n번을 넘지 않으며, 루프 내부의 수행은 O(1) 시간,Line 14~17, O(1) 시간이 걸림. 따라서 O(n) + O(nlogn) + n*O(1) + O(1) = O(nlogn) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Python] PEP, 객체","slug":"python4","date":"2019-01-22T11:02:13.000Z","updated":"2019-02-16T07:46:58.813Z","comments":true,"path":"2019/01/22/python4/","link":"","permalink":"http://dudri63.github.io/2019/01/22/python4/","excerpt":"","text":"1. PEP2. 객체 1. PEP 파이썬은 수많은 사람들이 의견을 수용하고 토론하며 발전해온 언어이다.언어 발전을 위해 논의된 주제를 PEP라는 이름으로 문서화해왔다.수많은 PEP 문서들이 있는데, 개발자들마다 작성한 코드 스타일이 다르다.그렇기 때문에 대부분은 PEP 8문서를 통해 권장하는 파이썬 스타일을 학습한다. 2. 객체 파이썬은 모든 것이 객체(Object)로 이루어져 있다.객체란 ‘어떠한 속성(attribute)값과 행동(method)을 가지고 있는 데이터’이다.파이썬의 존재하는 숫자, 문자, 함수 등은 여러 속성과 행동을 가지고 있는 데이터이다. 예를들어, 문자 ‘a’는 파이썬에서 단순하게 문자를 표현되는 것으로 끝나지 않는다.a.join, a.upper와 같이 문자 자체를 객체로 만들고 다양한 속성과 행동을 넣을 수 있다. 이러한 프로그래밍 기법을 객체지향 프로그래밍이라고 한다.객체지향 프로그래밍은 해결할 문제를 실제의 세계처럼 다양한 정보들을 가진 객체로 표현하고, 객체들 간의 통신으로 해결하는 기법이다. 2.1 객체의 타입, 클래스 파이썬에서 객체의 타입(type)은 객체를 어떤 클래스(Class)로 만들어졌는냐에 따라 결정된다.클래스는 객체를 만드는 일종의 틀이다.클래스는 생성할 객체들의 속성과 행동을을 정의하는 공간이고,객체끼리 서로 같은 타입을 가진다면 같은 속성과 행동을 가지게 된다.타입의 예로는 int, float, str 등이 있다. Reference 2.파이썬은 객체로 이뤄져잇다, 제대로 파이썬, 2019. 1. 22, https://wikidocs.net/21733, https://wikidocs.net/20456, https://wikidocs.net/20457, https://wikidocs.net/21719,","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 입력과 출력, 논리 연산, 주석","slug":"python3","date":"2019-01-22T10:32:22.000Z","updated":"2019-02-16T07:46:53.451Z","comments":true,"path":"2019/01/22/python3/","link":"","permalink":"http://dudri63.github.io/2019/01/22/python3/","excerpt":"","text":"1. 입력과 출력2. 논리 연산3. 주석 (Comment) 1. 입력과 출력 12in_str = input(&quot;입력해주세요.\\n&quot;)print(in_str.upper()+&quot; World!&quot;) input() 사용자가 입력한 값을 반환하는 함수 입력할 값에 대한 안내를 출력할 수도 있다. 사용자가 입력한 값은 문자열로 취급 입력한 값을 정수로 저장하고 싶다면 int() 함수를 이용한다.ex. x = int(input(“숫자를 입력해주세요.\\n”)) string.upper() : 문자열을 대문자로 변환하여 반환string.lower() : 문자열을 소문자로 변환하여 반환 123456789in_str = input(&quot;아이디를 입력해주세요.\\n&quot;)real_egoing = &quot;11&quot;real_k8805 = &quot;ab&quot;if real_egoing == in_str: print(&quot;Hello!, egoing&quot;)elif real_k8805 == in_str: print(&quot;Hello!, k8805&quot;)else: print(&quot;Who are you?&quot;) 2. 논리 연산 1234567in_str = input(&quot;아이디를 입력해주세요.\\n&quot;)real_egoing = &quot;egoing&quot;real_k8805 = &quot;k8805&quot;if real_egoing == in_str or real_k8805 == in_str: print(&quot;Hello!&quot;)else: print(&quot;Who are you?&quot;) if를 중첩해서 사용한 경우1234567891011input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)input_pwd = input(&quot;비밀번호를 입력해주세요.\\n&quot;)real_id = &quot;egoing&quot;real_pwd = &quot;11&quot;if real_id == input_id: if real_pwd == input_pwd: print(&quot;Hello!&quot;) else: print(&quot;잘못된 비밀번호입니다&quot;)else: print(&quot;잘못된 아이디입니다&quot;) and로 통합한 경우12345678input_id = input(&quot;아이디를 입력해주세요.\\n&quot;)input_pwd = input(&quot;비밀번호를 입력해주세요.\\n&quot;)real_id = &quot;egoing&quot;real_pwd = &quot;11&quot;if real_id == input_id and real_pwd == input_pwd: print(&quot;Hello!&quot;)else: print(&quot;로그인에 실패했습니다&quot;) 3. 주석(Comment) 파이썬에서 주석 사용은 다음과 같다. ‘’’~’’’ : ‘’’ 사이에 주석을 작성(‘은 아포스트로피) #~ : # 뒤에 주석을 작성 Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/1750/9681, https://opentutorials.org/course/1750/9619, https://opentutorials.org/course/1750/9626","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 변수, 비교, 조건문","slug":"python2","date":"2019-01-22T01:49:38.000Z","updated":"2019-02-16T07:46:48.195Z","comments":true,"path":"2019/01/22/python2/","link":"","permalink":"http://dudri63.github.io/2019/01/22/python2/","excerpt":"","text":"1. 변수2. 비교(Boolean) 1. 변수 Python은 C언어를 비롯한 다른 언어들과는 다르게 변수 선언을 미리 하지 않고도, 변수에 데이터를 저장할 수 있다.123456x=10 # 정수형 변수y=5print(x+y) title = &quot;python &amp; ruby&quot; # 문자열형 변수print(&quot;Title is &quot;+title) 1.1 문자열에서 변수의 사용1234name = &quot;서영기&quot;print(&quot;안녕하세요. &quot;+name+&quot;님&quot;) # 두 문자열을 합친 결과를 출력print(name+&quot;님을 위한 강의를 준비했습니다.&quot;)print(name+&quot;님 꼭 참석 부탁드립니다.&quot;) 1.2 수 계산에서 변수의 사용1234donation = 200student = 10sponsor = 100print((donation*student)/sponsor) 2. 비교(Boolean) bool연산(boolean)의 결과를 확인할 수 있다.12345678a=1b=1print(a==b)print(1==2)print(1&gt;2)print(1&lt;2)print(True)print(False) 3. 조건문(Conditional Statement) 1234if True: # true라고 쓰면 오류 print(&quot;code1&quot;) print(&quot;code2&quot;)print(&quot;code3&quot;) 1234if False: # false라고 쓰면 오류 print(&quot;code1&quot;) print(&quot;code2&quot;)print(&quot;code3&quot;) if 조건문에 포함되어 있는 것들은 “code1”, “code2” 문자열을 각각 출력하는 print() 함수이다. 조건이 True일 때 if 조건문 내부에 있는 것들이 동작, Flase일 때 조건문 내부에 있는 것들이 동작하지 않음을 알 수 있다. 그리고 code3 문자열을 출력하는 print() 함수는 조건문 내부에 포함되어 있지 않다. 1234input = 11real = 11if real == input: print(&quot;Hello!&quot;) 123456input = 11real = 11if real == input: print(&quot;Hello!&quot;)else: print(&quot;Who are you?&quot;) 123456input = 11real = 12if real == input: print(&quot;Hello!&quot;)else: print(&quot;Who are you?&quot;) 123456789input = &quot;ab&quot;real_egoing = 11real_k8805 = &quot;ab&quot;if real_egoing == input: print(&quot;Hello!, egoing&quot;)elif real_k8805 == input: print(&quot;Hello!, k8805&quot;)else: print(&quot;Who are you?&quot;) else if를 elif 라고 함을 주의하자. 또한, 문자열 비교도 가능한 것을 알 수 있다. Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/1750/9616, https://opentutorials.org/course/1750/9618, https://opentutorials.org/course/1750/9620","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Python] 실행, 수와 계산, 문자 및 문자열","slug":"python1","date":"2019-01-21T03:40:35.000Z","updated":"2019-02-16T07:46:42.367Z","comments":true,"path":"2019/01/21/python1/","link":"","permalink":"http://dudri63.github.io/2019/01/21/python1/","excerpt":"","text":"1. Execution2. 수와 계산3. 문자 및 문자열 1. Execution 1.1 대화형 모드로 실행 터미널에서 python3를 입력한다. 1.2 파일 모드로 실행 대화형 모드로 간단하게 코드를 작성하기는 편리하지만, 크고 많은 양의 코드를 작성하는 것은 어려움. 따라서 파일을 사용하여 실행한다.windows의 경우, 메모장, linux의 경우 gedit을 사용할 수 있다. gedit을 연 뒤, 코드 작성, 확장자를 *.py로 하여 저장한다.이 후, $ python3 명령어 뒤에 경로 및 파일이름, 확장자를 실행한다. 2. 수와 계산 1234print(10 + 5)print(10 - 5)print(10 * 5)print(10 / 5) 12345import mathprint(math.ceil(2.2)) # ceil : 소수점 이하를 올림print(math.floor(2.7)) # floor : 소수점 이하를 버림print(math.pow(2,10)) # 2^10, pow : 제곱print(math.pi) # pi : 3.14 math 모듈을 가져오고, 해당 모듈을 이용하여 위와 같은 연산을 실시할 수 있다. 3. 문자 및 문자열 1234print(&apos;Hello&apos;)print(&quot;Hello&quot;)print(&quot;Hello &apos;world&apos;&quot;)print(&apos;Hello &quot;world&quot;&apos;) 12345print(&apos;Hello &apos;+&apos;world&apos;) # 두 문자열을 합친 결과를 출력print(&apos;Hello &apos;*3) # 해당 문자열을 3회 출력print(&apos;Hello&apos;[0]) # 해당 문자열(배열)의 특정 원소를 출력print(&apos;Hello&apos;[1])print(&apos;Hello&apos;[2]) 12345print(&apos;hello world&apos;.capitalize()) # 문자열의 첫 글자를 대문자로 변경print(&apos;hello world&apos;.upper()) # 문자열이 모든 문자를 대문자로 변경print(&apos;hello world&apos;.__len__()) # 문자열의 길이를 출력print(len(&apos;hello world&apos;))print(&apos;Hello world&apos;.replace(&apos;world&apos;, &apos;programming&apos;)) # 특정 문자열을 다른 문자열로 변경 123456print(&quot;egoing&apos;s \\&quot;tutorial\\&quot;&quot;) # &quot;를 문자로서 출력하기 위해 \\(escape)를 사용print(&quot;\\\\&quot;) # 첫번째 \\은 뒤의 \\의 임무(escape)를 해제print(&quot;Hello\\nworld&quot;) # \\: 줄바꿈print(&quot;Hello\\t\\tworld&quot;) # \\t: 탭print(&quot;\\a&quot;) # \\a: 경고음을 출력print(&apos;Hello\\nworld&apos;) 12print(10+5) # 수의 합을 출력print(&quot;10&quot;+&quot;5&quot;) # 문자열의 합을 출력 Reference “Python &amp; Ruby”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/1750/9612, https://opentutorials.org/course/1750/9614, https://opentutorials.org/course/1750/9615","categories":[{"name":"Language","slug":"Language","permalink":"http://dudri63.github.io/categories/Language/"},{"name":"Python","slug":"Language/Python","permalink":"http://dudri63.github.io/categories/Language/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://dudri63.github.io/tags/Python/"}]},{"title":"[Git] GitHub (2)","slug":"git12","date":"2019-01-21T02:36:03.000Z","updated":"2019-02-16T07:56:09.209Z","comments":true,"path":"2019/01/21/git12/","link":"","permalink":"http://dudri63.github.io/2019/01/21/git12/","excerpt":"","text":"1. 원격 저장소 생성2. 원격 저장소에 push 1. 원격 저장소 생성 깃허브에 로그인한다. new repository 버튼을 클릭한다. 저장소 이름을 설정한다. public / private option을 설정한다. readme (프로젝트에 대한 설명) 파일 생성 여부를 설정한다. 저장소를 생성한다. https를 선택 및 저장소의 고유 주소를 확인한다. 2. 원격 저장소에 push $ git remote add ‘별명’ ‘경로’ 명령어를 실행하여 생성한 저장소 주소의 별명을 설정하고, 원격 저장소로서 설정한다. $ git push ‘별명’ ‘branch 이름’ 명령어를 실행하여 origin이 가리키는 원격 저장소의 master branch에 현재 지역 저장소의 branch를 push한다.-u : 서로 연결할 때, 최초 1회 사용한다. 이후에는 git push만 해도 위 설정대로 push하게 된다. 위 페이지와 같이 원격저장소에 성공적으로 push된 것을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/2708/15426","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"},{"name":"Repository","slug":"Repository","permalink":"http://dudri63.github.io/tags/Repository/"},{"name":"GitHub","slug":"GitHub","permalink":"http://dudri63.github.io/tags/GitHub/"}]},{"title":"[Git] GitHub (1)","slug":"git11","date":"2019-01-21T01:49:56.000Z","updated":"2019-02-16T07:56:02.253Z","comments":true,"path":"2019/01/21/git11/","link":"","permalink":"http://dudri63.github.io/2019/01/21/git11/","excerpt":"","text":"1. GitHub란2. GitHub 둘러보기3. GitHub 프로젝트 가져오기 1. GitHub란 ‘깃허브(GitHub)’는 분산 버전 관리 툴인 깃을 사용하는 프로젝트를 지원하는 웹호스팅 서비스이다. 다른 말로, 자신의 서버를 직접 운영하지 않고도, 온라인 서비스를 이용하여 원격 저장소를 사용할 수 있게 해주는 웹 서비스이다. 2. GitHub 둘러보기(‘git’ project) GitHub 홈페이지에서 git을 검색하여 git/git 항목으로 접속한다.위와 같이 git이라는 오픈 소스 프로젝트의 원격 저장소를 볼 수 있다.상위 리스트들의 수치가 의미하는 바는 다음과 같다. 54,244 commits : 총 54,244번의 commit으로 현재까지 옴 (매우 큰 프로젝트) 5 branches : 5개의 branch가 있음 1240 contributors : 소스 코드에 접근하여 수정할 수 있는 인원 Fork 14,817 : 다른 사람들에 의해 fork한 횟수 cf. fork 버튼을 누르면 이 프로젝트 나의 것이 된다. contributor에 속하지 않아도 코드를 수정할 수 있다. 그러나 해당 프로젝트의 소스 코드를 수정하는 것이 아니라, 나의 저장소로 복제된 코드를 수정하는 것이다. fork 숫자가 높을수록 높은 영향력을 지닌 개발자의 코드이다. 3. Github 프로젝트 가져오기 위 페이지에서 ‘Clone or download’라고 쓰인 초록색 버튼을 클릭하면, 주소가 나오는데 이를 복사한다.이 후, 터미널에서 적당한 디렉토리로 이동한다.1$ git clone &apos;주소&apos; &apos;디렉토리 이름&apos; 위와 같은 명령어를 실행하면 해당 디렉토리 이름으로 저장소를 만들고 그 곳의 주소가 가리키는 것들을 복사하여 저장한다. gitsrc라는 저장소 생성 및 해당 저장소에 git 프로젝트를 복사하였다.$git log 명령어를 실행하여 git 프로젝트의 commit history를 파악할 수 있다. 1$ git log --reverse // commit을 과거순으로 확인 가능 $ git log –reverse 명령어를 실행하여 가장 상위에 있는 commit(최초의 commit) ID를 복사한다. 최초의 commit으로 checkout한 뒤, $ls -al 명령어를 실행하여 git 프로젝트의 최초 코드를 확인할 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/2708/15426","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"},{"name":"Repository","slug":"Repository","permalink":"http://dudri63.github.io/tags/Repository/"},{"name":"GitHub","slug":"GitHub","permalink":"http://dudri63.github.io/tags/GitHub/"}]},{"title":"[Algorithm] 최단 경로 찾기 (그리디)","slug":"algo13","date":"2019-01-21T01:26:27.000Z","updated":"2019-02-16T07:41:42.734Z","comments":true,"path":"2019/01/21/algo13/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo13/","excerpt":"","text":"1. 최단 경로 찾기1. 다익스트라 알고리즘1. 시간 복잡도1. 응용 1. 최단 경로 찾기 최단 경로(Shortest Path) 문제는 주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제이다. 최단 경로를 찾는 가장 대표적인 그리디 알고리즘은 다익스트라(Dijkstra) 최단 경로 알고리즘이다. 다익스트라 알고리즘은 프림의 최소 신장 트리 알고리즘과 거의 흡사한 과정으로 진행된다. 차이점은 다음과 같다. 프림 알고리즘은 임의의 점에서 시작하지만, 다익스트라 알고리즘은 주어진 출발점에서 시작 프림 알고리즘은 트리에 하나의 점, 선분을 추가시킬 때 현재 상태의 트리에서 가장 가까운 점을 추가시키지만, 다익스트라 알고리즘은 출발점으로부터 최단거리가 확정되지 않은 점들 중 출발점으로부터 가장 가까운 점을 추가, 그 점의 최단 거리를 확정 2. 다익스트라 알고리즘 다음은 다익스트라 최단 경로 알고리즘이다. 단, 입력 그래프는 양수의 가중치 그래프로서 하나의 연결요소로 되어 있다. 또한, s는 출발점이다.12345678ShortestPath(G, s)입력: 가중치 그래프 G=(V,E), |V|=n(점의 수), |E|=m(선분의 수)출력: 출발점 s로부터 (n-1)개의 점까지 각각 최단 거리르 저장한 배열 D배열 D를 ∞로 초기화한다. 단, D[s]=0으로 초기화한다. // 배열 D[v]에는 출발점 s로부터 점 v까지의 거리로 저장된다.while (s로부터의 최단 거리가 확정되지 않은 점이 있으면)&#123; 현재까지 s로부터 최단 거리가 확정되지 않은 각 점 v에 대해 최소의 D[v]의 값을 가진 점 vmin을 선택, 출발점 s로부터 vmin까지의 최단 거리 D[vmin]을 확정시킨다. s로부터 현재보다 짧은 거리로 점 vmin을 통해 우회 가능한 각 점 w에 대해서 D[w]를 갱신한다.&#125;return D 위와 같이 서울에서부터 각 지역까지 최단 거리를 알 수 있다. 3. 시간 복잡도 ShortestPath 알고리즘은 while-루프가 (n-1)번 반복되고, 1회 반복될 때 line 6에서 최소의 D[v]를 가진 점 vmin을 찾는 데 O(n) 시간이 걸린다.(입력만큼 비교)또한 line 7에서 vmin에 연결된 점의 수가 최대 (n-1)개이므로, 각 D[w]를 갱신하는 데 걸리는 시간은 O(n이다.)따라서 시간복잡도는 (n-1)X{O(n)+O(n)}=O(n2)이다. 4. 응용 최단 경로 알고리즘은 구글 웹사이트의 지도 서비스에서 사용된다.또한, 자동차 네비게이션, 네트워크 및 통신 분야, 로봇 공학 등에 널리 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 최소 신장 트리 (그리디)","slug":"algo12","date":"2019-01-20T20:50:19.000Z","updated":"2019-02-16T07:41:38.121Z","comments":true,"path":"2019/01/21/algo12/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo12/","excerpt":"","text":"1. 최소 신장 트리란2. 크러스컬 알고리즘3. 크러스컬 알고리즘의 시간복잡도4. 프림 알고리즘5. 프림 알고리즘의 시간복잡도6. 응용 1. 최소 신장 트리란 최소 신장 트리(Minimum Spanning Tree)란 주어진 가중치 그래프에서 사이클 없이 모든 점들을 연결시킨 트리들 중 선분들의 가중치 합이 최소인 트리이다. 위 경우에서 (a)를 주어진 가중치 그래프라고 가정한다.(점들끼리 연결된 선분들마다 가중치(숫자)가 다른 그래프이다.) (b) 최소 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 이러한 종류의 트리들 중 가중치의 합이 최소임. (c) 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 단, 이러한 종류의 트리들 중 가중치의 합이 최소는 아님. (d) 부분그래프 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시키지 못함. 그래프의 점의 수가 n이면, 신장 트리에는 정확히 (n-1)개의 선분이 있다. 만일 (n-1)개의 선분보다 많다면, 반드시 사이클이 만들어져 신장 트리가 아니게 된다. 최소 신장 트리를 찾는 대표적인 그리디 알고리즘은 크러스컬(Kruskal)과 프림(prim) 알고리즘이다. 2. 크러스컬 알고리즘 다음은 크러스컬 알고리즘이다.크러스컬 알고리즘은 가중치가 가장 적은 선분이 사이클을 만들지 않을 때에만 ‘욕심 내어’ 그 선분을 추가시킨다.단, 알고리즘의 입력은 1개의 연결요소로 된 가중치 그래프이다.(cf. 연결요소) 12345678910111213KruskalMST(G)입력: 가중치 그래프 G=(V,E), |V|=n (점의 수), |E|=m (선분의 수)출력: 최소 신장 트리 T가중치의 오름차순으로 선분들을 정렬한다. 정렬된 선분 리스트를 L이라고 하자.T=∅ // 트리 T를 초기화시킨다.while (T의 선분 수 &lt; n-1) &#123; L에서 가장 작은 가중치를 가진 선분 e를 가져오고, e를 L에서 제거한다. if (선분 e가 T에 추가되어 사이클을 만들지 않으면) e를 T에 추가시킨다. else // e가 T에 추라되어 사이클이 만들어지는 경우 e를 버린다.&#125;return 트리 T // 이 때, T는 최소 신장 트리이다. 3. 크러스컬 알고리즘의 시간복잡도 Line 4에서 선분들을 가중치를 기준으로 정렬하는데 O(mlogm)의 시간이 걸린다.(이 때, m은 입력 그래프에 있는 선분의 수이다.)Line 5에서는 T를 초기화하므로 O(1) 시간이 걸린다.Line 6~11에서는 그래프의 선분을 검사하는데, 이 때, 선분의 수만큼 m번 수행된다.(최악의 경우)또한, while-루프 내에서는 L로부터 가져온 e가 사이클을 만드는지를 검사하는데, O(log*m) 시간이 걸린다.따라서 크러스컬 알고리즘의 시간복잡도는 O(mlogm)+O(mlog*m) = O(mlogm)이다. 4. 프림 알고리즘 다음은 프림 알고리즘이다.프림 알고리즘은 주어진 가중치 그래프에서 임의의 점 하나를 선택한 후, (n-1)개의 선분을 하나씩 추가시켜 트리를 만든다. 현재까지 만들어진 트리에 새로운 선분을 추가하면서 연결시킬 때 ‘욕심 내어서’ 항상 최소의 가중치로 연결되는 선분을 추가시킨다.단, 알고리즘의 입력은 1개의 연결요소로 된 가중치 그래프이다. 12345678910111213141516171819PrimMST(G)입력: 가중치 그래프 G=(V,E), |V|=n(점의 개수), |E|=m(선분의 개수)출력: 최소 신장 트리 T그래프 G에서 임의의 점 p를 시작점으로 선택, D[p]=0 // D[v]는 T에 있는 점 u, v를 연결하는 선분의 최소 가중치를 저장for (점 p가 아닌 각 점 v에 대하여)&#123; // 배열 D의 초기화 if (선분 (p,v)가 그래프에 있으면) D[v] = 선분 (p,v)의 가중치 else D[v] = ∞&#125;T&#123;p&#125; // 초기에 트리 T는 점 p만을 가진다.while (T에 있는 점의 수 &lt; n) &#123; T에 속하지 않은 각 점 v에 대하여, D[v]가 최소인 점 vmin과 연결된 선분 (u,vmin)을 T에 추가한다. 단, u는 T에 속한 점이고, 이 때 점 vmin도 T에 추가된다. for (T에 속하지 않은 각 점 w에 대해서)&#123; if (선분(vmin, w)의 가중치 &lt; D[w]) D[w] = 선분 (vmin, w)의 가중치 // D[w]를 갱신한다. &#125;&#125;return T 위 그림에 프림 알고리즘을 적용한다. Line 4: 임의로 점 c를 선택, D[c]=0 Line 5~9: 시작점 c와 선분으로 연결된 각 점 v에 대해 D[v]를 각 선분의 가중치로 초기화, 나머지 각 점 w에 대해 D[w]는 ∞로 초기화D[a]=∞, D[b]=1, D[c]=0, D[d]=∞, D[e]=∞, D[f]=1 Line 10: T={c}로 초기화 Line 11: 현재 T에는 점 c만 있으므로 루프 조건 ‘참’ Line 12: T에 속하지 않은 각 점 v에 대해 D[v]가 최소인 점 vmin을 선택. 단, 이 경우, D[b]=D[f]=1로서 최소값이므로 점 b나 점 f 중 하나를 선택. 점 b를 선택한 상황을 가정한다. 점 b와 선분 (c,b)를 T에 추가T={c, b, (c,b)} Line 13~15: 점 b에 연결된 점 a와 d의 D[a]와 D[b]를 각각 3, 4로 갱신. 점 f는 점 b와 선분으로 연결되어 있으나 선분 (b,f)의 가중치인 2가 현재 D[f]=1보다 크므로 D[f]를 갱신 안함D[a]=3, D[b]=1, D[c]=∞, D[d]=4, D[e]=∞, D[f]=1 Line 11: 루프 조건 ‘참’ Line 12: T에 속하지 않은 각 점 v에 대해 vmin인 점 f를 찾고, 점 f와 선분 (c,f)를 T에 추가T={c, b, f, (c,b), (c,f)} Line 13~15: 점 f에 연결된 점 e의 D[e]=9로 갱신. D[d]는 선분 (f,d)=7보다 작아서 if 조건문을 만족하지 못하므로 제외D[a]=∞, D[b]=1, D[c]=0, D[d]=∞, D[e]=9, D[f]=1 Line 11~15 과정을 반복한다. Line 16 : T를 리턴한다. 프림 알고리즘은 항상 T 밖에 있는 점을 추가하므로 사이클을 만들지 않는다. 5. 프림 알고리즘의 시간 복잡도 프림 알고리즘은 while-루프가 (n-1)번 반복, 1회 반복될 때 line 9에서 T에 속하지 않은 각 점 v에 대해 vmin을 찾는 데 O(n) 시간이 걸린다. 따라서 프림 알고리즘의 시간복잡도는 (n-1)XO(n) = O(n2)이다. 6. 응용 최소 신장 트리 알고리즘은 최소 비용으로 선로 또는 파이프 네트워크를 설치하는 데 활용되며, 여행자 문제를 근사적으로 해결하는 데 이용된다. cf. 연결요소 1개의 연결요소로 된 그래프 2개의 연결요소로 된 그래프 Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid= “6장 그래프 - (3) 그래프 탐색 문제1 - 연결 요소(11724번)”, 살구의 개발자 첫걸음을 위한 , 2019. 1. 21, http://salguru.tistory.com/","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 동전 거스름돈 (그리디)","slug":"algo11","date":"2019-01-20T19:59:30.000Z","updated":"2019-02-16T07:41:33.345Z","comments":true,"path":"2019/01/21/algo11/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo11/","excerpt":"","text":"1. 동전 거스름돈 문제란2. 동전 거스름돈 알고리즘 1. 동전 거스름돈 문제란 거스름돈을 동전으로 받아야 할 때, 누구나 적은 수의 동전을 거스름돈으로 받기를 원한다고 가정한다.동전 거스름돈 문제를 해결하는 가장 간단하고 효율적인 방법은 남은 액수를 초과하지 않는 조건하에 ‘욕심내어’ 가장 큰 액면의 동전을 취하는 것이다. 2. 동전 거스름돈 알고리즘 다음은 동전 거스름돈 문제의 최소 동전 수를 찾는 그리디 알고리즘이다. 12345678910CoinChange(W)입력: 거스름돈 액수 W출력: 거스름돈 액수에 대한 최소 동전 수change=W, n500=n100=n50=n10=n1 //n500, n100, n50, n10, n1은 각각의 동전수를 위한 변수while(change&gt;=500) change=change-500, n500++ //500원짜리 동전수를 증가while(change&gt;=100) change=change-100, n100++ //100원짜리 동전수를 증가while(change&gt;=50) change=change-50, n50++ //50원짜리 동전수를 증가while(change&gt;=10) change=change-10, n10++ //10원짜리 동전수를 증가while(change&gt;=1) change=change-1, n1++ //1원짜리 동전수를 증가return (n500+n100+n50+n10+n1) //총 동전수를 반환 Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 그리디 알고리즘","slug":"algo10","date":"2019-01-20T19:49:01.000Z","updated":"2019-02-16T07:41:28.113Z","comments":true,"path":"2019/01/21/algo10/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo10/","excerpt":"","text":"그리디(Greedy) 알고리즘은 최적화 문제를 해결하는 알고리즘이다. 최적화(Optimization) 문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다. 그리디 알고리즘은 입력 데이터 간의 관계를 고려하지 않고 수행 과정에서 최솟값 또는 최댓값을 가진 데이터를 선택한다. 이러한 선택을 ‘근시안적’인 선택이라고도 하는데, 그리디 알고리즘은 근시안적인 선택으로 부분적인 최적해를 찾고, 이들을 모아서 문제의 최적해를 얻는다. 또한, 그리디 알고리즘은 일단 한번 선택하면, 이를 절대로 번복하지 않는다. 위와 같은 그리디 알고리즘의 특징들 때문에 그리디 알고리즘은 매우 단순하며 제한적인 문제들만이 그리디 알고리즘으로 해결이 가능하다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Greedy","slug":"Greedy","permalink":"http://dudri63.github.io/tags/Greedy/"}]},{"title":"[Algorithm] 주의할 점 (분할정복)","slug":"algo9","date":"2019-01-20T19:33:06.000Z","updated":"2019-02-16T07:41:20.873Z","comments":true,"path":"2019/01/21/algo9/","link":"","permalink":"http://dudri63.github.io/2019/01/21/algo9/","excerpt":"","text":"분할 정복은 분활된 부분문제의 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우 사용기하게 부적절하다.예를 들어, 피보나치 수를 구할 때, F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 한다고 가정한다. 그러나 이 경우는 n이라는 숫자로 인해 2개의 부분문제인 F(n-1), F(n-2)이 만들어지고, 입력의 크기의 합이 (n-1) + (n-2)가 되어 분할 후 입력의 총 크기가 거의 2배가 된다. 위와 같이 6의 피보나치 수를 구할 때, 분할 정복을 사용하면, 중복되는 부분문제들이 생겨서 오히려 총 소요 시간이 증가함을 알 수 있다. 피보나치 수와 같은 경우에는 분할 정복(재귀 호출)을 사용하지 않고, for-루프를 사용하는 것이 더욱 효율적이다.12345FiboNumber(n)F[0]=0F[1]=1for i=2 to n F[i] = F[i-1] + F[i-2] 위와 같은 알고리즘을 사용하면, 루프의 수행 횟수로서 시간복잡도가 O(n)이 된다. 주어진 문제를 분할 정복 알고리즘으로 해결하려고 하라 때 중의해야 하는 점 중 다른 하나는 취합 과정이다. 입력을 분할 한다고 해서 효율적인 알고리즘이 만들어지는 것은 아니다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “3장분할정복알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Git] 원격 저장소(Remote Repository)","slug":"git10","date":"2019-01-20T15:34:11.000Z","updated":"2019-02-16T07:55:56.913Z","comments":true,"path":"2019/01/21/git10/","link":"","permalink":"http://dudri63.github.io/2019/01/21/git10/","excerpt":"","text":"1. 원격 저장소란1. 원격 저장소 생성 1. 원격 저장소란 원격 저장소(Remote Repository)란 흔히 지역 저장소(Local Repository)와 구별되는 개념이다. 자신의 컴퓨터에서 작업하고 commit하면 저장되는 곳이 지역 저장소이다. 그런데, 작업물들을 인터넷에 올려서 백업을 하거나 다른 사람들과 협업을 할 경우, 컴퓨터와 연결된 다른 저장소가 필요하다. 원격 저장소의 역할은 크게 다음과 같다. 협업 백업 일반적으로 원격 저장소는 같은 컴퓨터에 연결되어 있지 않고, 인터넷을 통하여 다른 컴퓨터와 연결되어 있다. 원격 저장소는 프로젝트가 커지는 과정에서 굉장히 중요한 역할을 한다. 그러나 혼자서 프로젝트를 진행할 때에는 원격 저장소가 필요한 일은 많지 않다. 주로, dropbox 등과 같은 서비스를 이용한다. 2. 원격 저장소 생성 앞서 이야기하였듯이, 원격 저장소는 주로 인터넷을 통해 연결, 같은 컴퓨터 안에 있지 않는다. 그러나 원격 저장소 개념을 알기 위하여 본 포스팅에서는 한 대의 컴퓨터, 다른 디렉토리에 원격 저장소를 생성, 원격 저장소에 commit할 것이다. 위와 같이 gitfth2 디렉토리에 ‘local’이라는 이름의 저장소를 생성한다. 이 후, f1.txt를 add하고 commit한다.(local 이름의 저장소를 지역 저장소라고 가정한다.) gitfth2 디렉토리에 또 다른 저장소 ‘remote’를 생성한다.(remote 이름의 저장소를 원격 저장소라고 가정한다.) cf.1$ git init --bare &apos;저장소 이름&apos; // 작업이 불가능, 저장만 가능한 저장소를 생성 remote 저장소는 –bare option을 적용하였기 때문에 .git 디렉토리가 내부에 존재하지 않고 위와 같은 파일들이 존재한다.원격 저장소는 일반적으로 작업을 하지 않고, 저장만 하는 경우가 많다. cf.123$ git remote add &apos;별명&apos; &apos;경로&apos; // 경로에 있는 디렉토리를 별명으로 설정 및 원격저장소로 연결$ git remote -v // 연결된 저장소 및 별명을 파악할 수 있음$ git remote remove &apos;별명&apos; // 연결된 원격원격소를 제거 별명을 설정하는 이유는 항상 경로를 입력하기가 불편하기 때문이다.같은 경로에 대하여 별명을 여러 개 설정할 수도 있다. 위와 같이 remote 디렉토리를 origin이라는 별명으로 하여 원격저장소로서 연결한다. cf.1234$ git push // 현재 저장소의 현재 branch를 연결시킨 원격 저장소에 upload$ git config --global push.default.simple // git의 push 형식을 simple 방식으로 설정$ git push --set-upstream origin master // 현재 branch를 origin의 master branch로 push // 또한, 앞으로 git push할 경우 위와 같이 psuh하겠음을 설정 remote 디렉토리에서 확인하면, push가 잘 되었음을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 21, https://opentutorials.org/course/2708/15395","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"},{"name":"Repository","slug":"Repository","permalink":"http://dudri63.github.io/tags/Repository/"}]},{"title":"[Git] Branch (4)","slug":"git9","date":"2019-01-20T14:23:16.000Z","updated":"2019-02-16T07:55:51.229Z","comments":true,"path":"2019/01/20/git9/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git9/","excerpt":"","text":"1. $ git branch -d, -D2. Branch 병합 시 충돌 해결 1. $ git branch -d, -D 12$ git branch -d &apos;branch name&apos; // 해당 branch를 제거$ git branch -D &apos;branch name&apos; // 강제로 해당 branch를 제거 2. Branch 병합 시 충돌 해결 2.1 충돌이 일어나지 않는 경우 위와 같이 master, exp branch가 있고, 각각의 branch에서 master.txt, exp.txt가 commit된 상태임을 가정한다. master branch에서 $ git merge exp 명령어를 실행하면, master branch에서 exp branch를 병합하는 새로운 commit이 생성된 것을 확인할 수 있다. 또한, ls -al 명령을 실행하면, 새로 생긴 commit은 master.txt, exp.txt를 모두 포함하는 것을 확인할 수 있다.이것은 branch 병합시 충돌이 일어나지 않는 경우인데, 병합 시, 공통된 이름의 파일이 존재하지 않았기 깨문에 가능한 것이다. 다음은 또다른 상황을 가정한다. master branch, exp branch에 모두 common.txt가 있는데, 위와 같이 각각의 common.txt의 내용은 다를 경우를 가정한다.(첫 번째 이미지가 master branch의 common.txt, 두 번째 이미지가 exp branch의 common.txt이다.) $ git merge master 명령어를 실행하면, 위와 같이 충돌 없이 두 branch가 병합되었음을 알 수 있다. 또한, $ cat 명령어를 이용하여 확인하면, common.txt에 function a, b, c가 모두 포함되어 있음을 확인할 수 있다.서로 다른 branch에 같은 이름의 파일이 존재하고, 각 파일들은 서로 다른 내용을 포함하고 있지만 충돌없이 병합할 수 있는 경우이다. 2.2 충돌이 일어나는 경우 위와 같이 master branch와 exp branch의 common.txt라는 같은 이름의 파일이 존재하지만, 그 내용이 각각 다른 경우를 가정한다. master branch에서 $ git merge exp 명령어를 실행하면, Conflict가 발생한다. 구체적으로, $ git status 명령어를 실행하면, common.txt가 서로 다른 branch에서 both modified되었기 때문에 conflict가 발생하여 merge에 실패하였음을 확인할 수 있다. common.txt를 텍스트 편집기를 이용하여 불러오면, 위와 같이 텍스트 내용이 변경되었음을 확인할 수 있다.=======를 구분자로 하여 구분자를 중심으로 위 쪽은 현재 checkout한 branch인 master의 충돌 요인, 아래 쪽은 exp의 충돌 요인을 확인할 수 있다. 2.3 충돌 해결 방법 위와 같은 상황에서 common.txt를 위와 같이 수정한다.(구분자를 비롯하여 나머지 부분들은 삭제한다.)이 후, common.txt를 add, commit하면 충돌 없이 병합할 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15275","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Branch (3)","slug":"git8","date":"2019-01-20T13:53:07.000Z","updated":"2019-02-16T07:55:45.773Z","comments":true,"path":"2019/01/20/git8/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git8/","excerpt":"","text":"작업을 분기한 뒤, 각자의 history들을 이어가다가 병합할 필요성이 있을 수 있다.1$ git merge &apos;branch name&apos; 이럴 경우, $ git merge ‘branch name’ 명령어를 실행하면 현재 chekcout되어 있는 branch에서 명령어에 함께 입력한 branch의 버전 정보들을 포함하는 새로운 commit이 생성된다. 현재 저장소에 2 version에서 5 version으로 진행된 master branch, 3,4 version으로 진행된 exp branch가 있다고 가정한다. master branch에서 $ git merge exp 명령어를 실행하면, commit message를 작성하는 화면이 나온다. 이 때, commit message를 작성 완료한 뒤, $ git log –branches 명령어를 실행하면, master branch에서 각 branch의 최신 commit들을 병합한 새로운 commit이 생성되었음을 확인할 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15261","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Branch (2)","slug":"git7","date":"2019-01-20T13:05:31.000Z","updated":"2019-02-16T07:55:39.525Z","comments":true,"path":"2019/01/20/git7/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git7/","excerpt":"","text":"1. $ git log –branches –decorate2. $ git log –branches –decorate –graph3. $ git log –branches –decorate –graph –oneline4. $ git log ‘branch name a’..’branch name b’ 123&lt;a name=&quot;1&quot;&gt;1. $ git log --branches --decorate&lt;/a&gt;$ git log --branches --decorate 기본적으로 $ git log 명령어는 현재 속해있는 branch의 버전 history만을 출력한다. 그러나 –branches 옵션을 추가로 실행하면, 현재 checkout되어 있는 branch 뿐만 아니라 저장소에 속해있는 모든 branches의 버전 정보들을 출력한다. master의 최신 commit이 2, exp의 최신 commit이 4, 현재 checkout된 branch는 exp임을 알 수 있다. 2. $ git log –branches –decorate –graph 1$ git log --branches --decorate --graph –graph 옵션을 추가로 실행하면, 버전이 진행된 것을 도형(선)으로 나타내어 효율적으로 버전 정보들을 파악할 수 있다. 위와 같이 graph가 나타나 효율적으로 버전 histories를 파악할 수 있다. 2 version에서 exp branch는 3,4 version으로 차례대로 변화, master branch는 5 version으로 변화하였음을 알 수 있다. 3. $ git log –branches –decorate –graph –oneline 1$ git log --branches --decorate --graph --oneline 더 간결하게 histories를 graph로 나타낸다. 4. $ git log ‘branch name a’..’branch name b’ 1$ git log &apos;branch name a&apos;..&apos;branch name b&apos; 위 명령어는 branch name a에는 없는 branch name b의 commit들을 전시한다. master branch에는 없는 exp branch들의 commit들을 나타내었다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15261","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Branch (1)","slug":"git6","date":"2019-01-20T11:58:30.000Z","updated":"2019-02-16T07:51:03.200Z","comments":true,"path":"2019/01/20/git6/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git6/","excerpt":"","text":"1. Git을 쓰는 이유2. $ git branch, $ git checkout ‘branch name’ 1. Git을 쓰는 이유 예를 들어, report.xsl file을 버전 관리한다고 가정한다.파일 내용이 변경될 때마다 새로운 이름으로 저장한다. report1.xsl, report2.xsl, ….그런데, 순차적으로 수정이 되다가 경우에 따라서 나뉘어서 수정될 수 있다.고객용으로 수정되면, report2_client.xsl으로 파일 이름을 저장할 수 있다.그리고, 고객용이 아니라 또 다시 내용 변경되면, report3.xsl으로 파일 이름을 저장할 수 있다.이렇게 나뉘어서 버전이 증가하다가, 다시 합쳐지는 경우도 있음. 위와 같이 버전 관리를 할 경우, 파일 이름을 변경해야 하는데, 작업이 분기되거나 합쳐질 경우, 매우 복잡하다.git을 쓰면 위와 같이 과정을 쉽고, 세련되게 할 수 있다. 2. $ git branch, $ git checkout ‘branch name’ 123$ git branch // 현재 저장소의 branch들, 현재의 branch$ git branch &apos;branch name&apos; // 새로운 branch 생성$ git checkout &apos;branch name&apos; // 해당 branch로 이동 $ git branch 명령어를 실행하면 현재 저장소의 모든 branch들과 함께 현재 속해 있는 branch가 무엇인지 알 수 있다.$ gir branch ‘branch name’ 명령어를 실행하면 해당 name의 새로운 branch가 생성된다.$ git checkout ‘branch name’ 명령어를 입력하면 해당 branch로 이동한다. 기본적으로 저장소에는 master branch가 존재한다. $ git branch 명령어를 실행하면, master branch가 있음을 알 수 있고, $ git branch exp 명령어를 실행하여 새로운 branch exp를 만든 뒤, $ git checkout exp 명령어를 실행하여 exp branch로 이동하였다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15260","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Reset, Command","slug":"git5","date":"2019-01-20T11:25:27.000Z","updated":"2019-02-16T07:50:57.496Z","comments":true,"path":"2019/01/20/git5/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git5/","excerpt":"","text":"1. $ git reset2. $ git commit –help, -a, -m 1. $ git reset 버전 관리 시스템에서 과거로 돌아가기란 commit을 취소하는 것을 의미한다. Git에서 과거로 돌아가는 방법에는 크게 2가지가 있다. reset revert 과거로 돌아가는 작업은 상당히 위험한 작업이며, 프로젝트 폴더 전체를 copy한 뒤, 위험한 작업을 실시하는 것이 좋다. 12$ git reset &apos;Commit ID&apos; --hard // Commit ID version이 최신이 됨$ git revert // Commit을 취소하면서 새로운 버전을 생성 $ git reset 명령어 뒤에 3 commit ID를 붙여서 실행하였더니, 이 후에 버전들은 삭제되고, 3 commit이 최신 버전이 된 것을 확인할 수 있다.(실제로 이후에 버전들이 삭제된 것은 아니다. Git은 특별한 경우를 제외하고는 버전에 관한 정보들을 삭제하지 않는다.) 원격 저장소에 협업을 할 경우, 자신의 버전을 공유할 수 있다. 이 때, 공유한 이후에는 reset를 하면 안되고, reset은 local 저장소에서만 사용하도록 한다. 2. $ git commit –help, -a, -m 123$ git commit --help // commit에 대한 도움말을 볼 수 있다.$ git commit -a, --all // 수정하거나 삭제한 파일을 자동으로 stage에 올린다.$ git commit -m, --message // commit message를 바로 쓴다. cf.$ git commit -a : 자동으로 변경된 파일을 add시킨다. 그러나 이전에 한번도 add하지 않은 파일에 대해서는 add하지 않는다. 즉, 파일을 생성하면 최초 1회는 $ git add 명령어를 사용하여야 한다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 20, https://opentutorials.org/course/2708/15210, https://opentutorials.org/course/2708/15211","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Commit ID, Diff","slug":"git4","date":"2019-01-20T10:22:19.000Z","updated":"2019-02-16T07:50:52.244Z","comments":true,"path":"2019/01/20/git4/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git4/","excerpt":"","text":"1. Commit ID2. $ git diff 1. Commit ID 각각의 commit들은 고유한 ID가 있다.git log 명령어를 실행하였을 때 나오는 매우 긴 노란쌕 문자열이 고유 ID다. 1$ git log &apos;commit ID&apos; // 해당 commit을 포함하여 이전의 history들만을 출력 위와 같이 $ git log 명령어 뒤에 commit ID를 붙이면, 그 commit을 포함하여 이전의 history들만을 화면에 출력한다. 2. $ git diff 12$ git diff &apos;commit ID A&apos;..&apos;commit ID B&apos; // 두 개의 commit 사이의 차이점 출력$ gii diff // 마지막 commit으로부터 변경된 점 출력 $ git diff ‘commit ID A’..’commit ID B’ 명령어를 입력하면 두 개의 commit 사이의 차이점을 보여준다. f1.txt의 경우, ID A에서는 그 내용이 ‘f1.txt : 4’, ID B에서는 그 내용이 ‘source : 2’이었음을 알 수 있다.f2.txt의 경우, ID A에서는 그 내용이 ‘source : 2’, ID B에서는 해당 파일이 없었음을 알 수 있다.$ git diff 명령어를 실행하면, 마지막 commit으로부터 변경된 점을 출력한다.(단, 변경사항을 git add하여 stage area로 이동시키면, 출력하지 않는다.) f1.txt, f2.txt를 수정한 뒤, add하기 전에 $ git diff 명령어를 실행했을때의 결과는 위와 같다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 19, https://opentutorials.org/course/2708/15202","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Setting, Commit, Log","slug":"git3","date":"2019-01-19T15:31:03.000Z","updated":"2019-02-16T07:50:47.204Z","comments":true,"path":"2019/01/20/git3/","link":"","permalink":"http://dudri63.github.io/2019/01/20/git3/","excerpt":"","text":"1. Setting2. $ git commit3. $ git log 1. Setting Git을 처음 쓰는 거라면, 앞으로 만들 버전이 내가 만들었음을 알리기 위하여 name, email을 setting한다.123$ git config --global user.name &quot;이름&quot;$ git config --global user.email &quot;이메일 주소&quot;$ git config --list // 입력한 사용자 정보 조회 2. $ git commit 1$ git commit // 버전 생성 git commit 명령어를 실행하면, add한 파일들에 한하여 해당 버전에 추가한다.또한, git commit 명령어를 실행하면, commit message를 작성할 수 있는데, commit message에는 어떠한 변화가 있는지 혹은 변화의 이유에 대하여 작성하도록 한다. 파일에 대하여 commit하고 싶으면 반드시 이전에 add하여야 한다. cf.버전 : 의미 있는 변화, 완성된 코드 단위git add : commit 대기 상태에 들어가게 한다.git commit : commit 대기 상태에 있는 파일들만 해당 버전에 추가한다.commit 대기 상태 : stage area에 올린다. 3. $ git log 12$ git log // 버전 생성이 되었는지 확인 가능$ git log -p // 각 commit 사이의 소스상 차이점을 파악할 수 있음 git log 명령어를 실행하면, 각 버전들의 verseion message, author, date 등을 확인할 수 있다.(version history를 파악할 수 있음) $ git log 명령어를 입력하면 각 commit들의 정보를 파악할 수 있다. $ git log -p 명령어를 입력하면 각 버전들 사이의 소스상 차이점을 알 수 있다.위 경우, version 4(commit message가 ‘4’인 버전) commit에서, version 4의 f1.txt의 내용이 ‘f1.txt : 4’, version 3의 f1.txt의 내용이 ‘source : 2’이었음을 알 수 있다.또한, version 3 commit에서, version 2에서는 f2.txt가 없었으나 version 3에서는 그 내용을 ‘source : 2’로 하는 f2.txt가 새로 생성되었음을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 19, https://opentutorials.org/course/2708/15202","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Init, Status, Add","slug":"git2","date":"2019-01-19T13:45:44.000Z","updated":"2019-02-16T07:50:41.800Z","comments":true,"path":"2019/01/19/git2/","link":"","permalink":"http://dudri63.github.io/2019/01/19/git2/","excerpt":"","text":"1. $ git init2. $ git status, $ git add 1. $ git init 1$git init //현재 디렉토리를 Git의 저장소로 등록 위와 같은 명령어를 실행하면, 현재 디렉토리를 Git으로 관리할 수 있다. 이 후, ls -al로 확인하면, .git 디렉토리가 현재 디렉토리 내부에 새롭게 생성된 것을 알 수 있다. 버전 관리를 하게 되면, 여러 가지 정보가 생성되는데, 이 때 이 정보들은 .git 디렉토리에 저장된다. 2. $ git status, $ git add Git은 init을 하여 관리하고 있는 디렉토리라고 할지라도, 기본적으로 새롭게 생성된 파일에 대해서는 관리하지 않는다. 파일을 관리하기 위해서는 관리 대상으로 등록해야 한다. 12git status // 현재 관리하고 있는 파일과 그렇지 않은 파일 확인git add + 파일 // 해당 파일을 git에게 추적하라고 명령 f1.txt의 내용을 ‘source:1’으로 하여 생성한다. git status를 실행하였을 때, f1.txt는 untracked file임을 확인할 수 있다. 즉, f1.txt는 버전 관리가 되고 있는 디렉토리에 존재하지만, 아직 git에 의해 관리되고 있지 않다.그러나 이 후, git add 명령어를 입력하여 git에게 f1.txt를 추적하라고 명령하면, 새롭게 f1.txt가 관리되기 시작하는 것을 알 수 있다. Reference “지옥에서 온 Git”, 생활코딩, 2019. 1. 19, https://opentutorials.org/course/2708/15170, https://opentutorials.org/course/2708/15172","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Git] Git의 기본","slug":"git1","date":"2019-01-19T09:32:02.000Z","updated":"2019-02-16T07:50:36.456Z","comments":true,"path":"2019/01/19/git1/","link":"","permalink":"http://dudri63.github.io/2019/01/19/git1/","excerpt":"","text":"1. 파일 복구 2. Git이란 1. 파일 복구 파일을 편집 전 상태로 돌리기 위한 방법 중 가장 간단한 것은 기존 파일을 미리 복사해두는 것이다. 이 경우에는 특별하게 파일명을 구분할 수 있게 해주어야 한다는 번거로움이 있다. 또한, 여러 명이 공유한 파일을 동시에 편집할 경우 다른 사람이 변경하고 있는 내용을 지워버릴 수 있다. 2. Git이란 이러한 문제점들을 해결하기 위하여 버전 관리 시스템이 ‘Git’을 사용한다.Git에서는 소스 코드가 변경된 이력을 쉽게 확인할 수 있고, 특정 시점에 저장된 버전과 비교하거나 특정 시점으로 되돌릴 수 있다.또한, 내가 업로드하는 파일이 누군가가 편집한 내용과 충돌한다면, 경고 메세지가 발생하여 사전에 다른 사람들과 조율할 수 있다. Reference Git의 기본(시작하기), 누구나 쉽게 이해할 수 있는 Git 입문, 2017. 1. 19, https://backlog.com/git-tutorial/kr/","categories":[{"name":"etc.","slug":"etc","permalink":"http://dudri63.github.io/categories/etc/"},{"name":"Git","slug":"etc/Git","permalink":"http://dudri63.github.io/categories/etc/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://dudri63.github.io/tags/Git/"}]},{"title":"[Algorithm] 최근접 점의 쌍 찾기 (분할정복)","slug":"algo8","date":"2019-01-19T09:31:18.000Z","updated":"2019-02-16T07:41:16.017Z","comments":true,"path":"2019/01/19/algo8/","link":"","permalink":"http://dudri63.github.io/2019/01/19/algo8/","excerpt":"","text":"1. 최근접 점의 쌍 찾기2. 최근접 점의 쌍을 찾는 알고리즘3. 시간복잡도4. 응용 1. 최근접 점의 쌍 찾기 ‘최근접 점의 쌍(Closest Pair)’을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다. 최근접 점의 쌍을 찾는 가장 간단한 방법은 모든 점에 대하여 각각의 두 점 사이의 거리를 계산하여 가장 가까운 점의 쌍을 찾는 것이다. 그러나 이러한 방법을 사용할 경우, 경우의 수는 nC2 = n(n-1)/2 = O(n2)의 시간복잡도로써 굉장히 오랜 시간이 걸린다. 효율적인 방법은 분할 정복을 이용하는 것이다. 즉, n개의 점을 1/2로 분할하여 각각의 부분문제에서 최근점 점의 쌍을 찾고, 2개의 부분해 중에서 가장 짧은 거리를 가진 점의 쌍을 찾는다. 그러나 다음과 같은 경우도 있다. 2개의 부분해를 취합할 때, 더 가까운 거리를 가진 점의 쌍이 있는 경우이다.따라서 단순히 2개로 분할한 부분문제에서 더 짧은 거리의 점의 쌍이 전체 문제에서 최근접 점의 쌍이라고 할 수 없는 것이다.(중간 영역에 있는 점들 때문에) 다음은 배열에 점의 좌표가 저장되어 있을 때, 중간 영역에 있는 점들을 찾는 방법이다. 0 1 2 3 4 5 6 7 8 9 (1,- ) (13,-) (17,-) (25,-) (26,-) (28,-) (30,-) (37,-) (45,-) (56,-) (4번, 5번 점을 각각 왼쪽 부분문제의 가장 오른쪽 점, 오른쪽 부분문제의 가장 왼쪽 점이라고 한다.)(일단 y-좌표는 무시하고 생각한다.)2차원 공간에서 위와 같이 10개의 점이 있다고 가정한다.이 때, 중간 영역에 속한 점들은 어떤 점들인가? 왼쪽 부분문제의 가장 오른쪽 점의 x-좌표에서 d를 뺀값과 오른쪽 부분문제의 가장 왼쪽 점의 x-좌표에 d를 더한 값 사이의 x-좌표 값을 가진 점들이다.(이 때, d=min{왼쪽 부분의 최근접 점 쌍 사이의 거리, 오른쪽 부분의 최근접 점 쌍 사이의 거리})만약, d=10이라면, 26-d=16, 28+d=38, 즉, 16~38 사이의 점들이 그것들이다. 2. 최근접 점의 쌍을 찾는 알고리즘 다음은 최근접 점의 쌍을 찾는 분할 정복 알고리즘이다. 단, 입력 점들은 x-좌표를 기준으로 미리 정렬되어 있다고 가정한다.123456789ClosestPair(S)입력: x-좌표의 오름차순으로 정렬된 배열 S출력: S에 있는 점들 중 최근접 점의 쌍의 거리if(i&lt;=S) return (2 또는 3개의 점들 사이의 최근접 쌍) // 3개 이하일 경우, 분할 X정렬된 S를 같은 크기의 S1과 S2로 분할한다. 단 |S|가 홀수이면, S1이 1 더 많게 분할한다.CP1 = ClosestPair(S1) // CP1은 S1에서의 최근접 점의 쌍CP2 = ClosestPair(S2) // CP2는 S2에서의 최근접 점의 쌍d = min&#123;dist(CP1), dist(CP2)&#125;일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서 이를 CPc라고 한다. 단, dist()는 두 점 사이의 거리이다.return (CP1, CP2, CPc 중에거 거리가 가장 짧은 쌍) 3. 시간 복잡도 ClosestPair 알고리즘의 전처리 과정으로서 S의 점을 x-좌표로 정렬하여야 하는데, 이 과정에서 O(nlogn)의 시간이 소요된다.왜냐하면 합병 정렬 또는 퀵 정렬을 사용하면 O(nlogn)의 시간이 소요되기 때문이다. 이 후, Line 4에서 O(1) 시간이 걸린다. Line 5에서는 S1, S2로 S를 분할하는데, 배열의 중간 인덱스를 계산해야 하므로 O(1) 시간이 걸린다. Line 6~7에서는 S1, S2가 각각 ClosestPair를 호출한다.합병 정렬처럼 분할하면서 호출하는 데에는 특별한 시간이 소요되지 않는다.단, 합병하면서 O(nlgon) 시간이 소모된다. Line 8에서는 중간 영역에 속해 있는 점들 중에서 최근접 점의 쌍을 찾는다. 기준선을 중심으로 거리가 d 이내인 영역에 있는 점들을 y-좌표 기준으로 정렬한다. 제일 아래에 있는 점부터 시작해서 각 점을 자기보다 더 위에 있는 점이랑만 비교한다. 초록색 점을 기준으로 자기보다 위에 있는 점만 비교한다면, 빨간색 직사각형 내부의 점들만을 고려한다. y-좌표를 기준으로 정렬하였으니 O(nlogn) 시간이 소모된다. Line 9에서는 3개의 점의 쌍 중 가장 짧은 거리를 가진 점의 쌍을 리턴하므로 O(1) 시간이 걸린다. ClosestPair 알고리즘의 분할 과정은 합병 정렬의 분할 과정과 동일하다. 그러나 취합하여 올라가는 과정에서 O(nlogn) 시간이 추가로 걸린다.(y-좌표 기준 정렬)따라서, O(nlog2n)이 된다. 4. 응용 최근점 점의 쌍을 찾는 ClosestPair 알고리즘은 컴퓨터 그래픽스, 컴퓨터 비전, 지리 정보 시스템, 분자 모델링, 마케팅 등의 분야에서 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “알고리즘) Closest Pair”, Au commencement, 2019. 1. 19, https://m.blog.naver.com/PostView.nhn?blogId=babobigi&amp;logNo=220530321348&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F “최근접 점쌍 문제”, Wikipedia, 2019. 1. 19, https://ko.wikipedia.org/wiki/%EC%B5%9C%EA%B7%BC%EC%A0%91_%EC%A0%90%EC%8C%8D_%EB%AC%B8%EC%A0%9C","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 선택 문제 (분할정복)","slug":"algo7","date":"2019-01-18T12:05:24.000Z","updated":"2019-02-16T07:41:10.773Z","comments":true,"path":"2019/01/18/algo7/","link":"","permalink":"http://dudri63.github.io/2019/01/18/algo7/","excerpt":"","text":"1. 선택문제란2. 선택문제 알고리즘3. 시간 복잡도4. 응용 1. 선택문제란 ‘선택(selection) 문제’는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.선택문제는 Quick-Select 알고리즘이라고도 한다.간단한 방법은 최소 숫자들을 오름차순으로 정렬한 후, k번째 숫자를 찾는 것이다.그러나 이러한 알고리즘은 O(nlogn)의 수행 시간이 걸린다.이보다 효율적인 해결을 위하여 분할 정복 개념을 활용할 수 있다. 선택 문제는 입력이 정렬되어 있지 않으므로, 퀵 정렬과 마찬가지로 피봇을 선택하여 피봇보다 작은 숫자들은 피봇의 왼쪽으로, 큰 숫자들은 피봇의 오른쪽 숫자로 이동시킨다.이렇게 2개로 분할된 그룹들의 크기를 각각 파악하면, k번째로 작은 숫자가 2개의 그룹 중 어디에 속해있는 지를 알 수 있다.이 후, 원하는 숫자가 속해 있지 않은 그룹은 고려하지 않고, 숫자가 속해 있는 그룹에서 위와 같은 작업을 반복하여 k번째로 작은 숫자를 파악한다. 선택 문제 알고리즘은 문제가 2개의 부분문제로 분할되나,그 중에 1개의 부분문제는 고려할 필요 없으며,부분문제의 크기가 일정하지 않은 크기가 감소하는 형태의 분할 정복 알고리즘이다. 2. 선택문제 알고리즘 다음은 선택 문제를 위한 분할 정복 알고리즘이다. 1234567891011Selection(A, left, right, k)입력: A[left]~A[right]와 k, 단, 1&lt;=k&lt;=|A|, |A|=right-left+1출력: A[left]~A[right]에서 k번째 작은 원소피봇을 A[left]~A[right]에서 랜덤하게 선택,피봇과 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교,피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다. // 퀵 정렬과 일치S = p-left // S = small group의 크기if (k &lt;= S) Selection(A, left, p-1, k) // Small group에서 찾기else if (k = S+1) return A[p] // 피봇이 k번째 숫자인 경우else Selection(A, p+1, right, k-S-1) // Large group에서 찾기 위 이미지에 이 알고리즘을 적용하여 살펴본다. k=10, 피봇은 A[0]인 23을 선택한다. (이 경우, A[left]를 피봇으로 선정하였음, 자리 변경 없음) 퀵 정렬과 마찬가지로 피봇과 원소들을 비교하여 자리를 바꾼 뒤, 피봇을 두 그룹의 가운데로 이동한다. p=7, small group의 크기 S=7, 10보다 작으니깐 large group만 고려한다.(그림 상 2번 과정까지) Selection(A, 8, 15, 2)을 실시한다. 피봇은 A[8]인 44를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음) 2번 과정을 다시 수행한다. p’=11, small group’의 크기 S’=3, k’=2 &lt;=3이므로 찾고자 하는 수는 small group’내에 있다.(그림 상 3번 과정까지) Selection(A, 8, 10, 2)을 실시한다. 피봇을 A[8]인 39를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음) 2번 과정을 다시 수행한다. p’’=9, small group’’의 크기 S’’=1, k’’=2=S’’+1이므로, 피봇이 k=10번째 숫자이다. A[9]를 리턴한다. 3. 시간 복잡도 Selection 알고리즘은 분할 정복 알고리즘이기도 하지만 랜덤(Random) 알고리즘이기도 하다. 왜냐하면 위 알고리즘에서 line 4에서 피봇을 랜덤하게 정하기 때문이다. 만일 피봇이 입력을 너무 한 쪽으로 치우치게 분할하면, 알고리즘의 수행시간이 길어진다. 피봇이 입력을 분할하는 데, 두 그룹 중 하나의 크기가 입력 크기의 3/4과 같거나 그보다 크면 bad 분할이고, 그 반대의 경우는 good 분할이다. 그런데, bad 분할이 되거나 good 분할이 될 확률은 각각 1/2로 동일하다.즉, 피봇을 랜덤하게 정했을 때 good 분할이 될 학률이 1/2이므로 평균 2회 연속해서 랜덤하게 피봇을 정하면 good 분할을 할 수 있다.따라서, 매 2회 호출마다 good 분할이 되므로, good 반할만 연속하여 이루어졌을 때마다의 시간복잡도를 구하여, 그 값에 2를 곱하면 평균 경우 시간복잡도를 구할 수 있다. 처음 입력의 크기가 n일 때 피봇을 랜덤하게 정한 후 입력은 두 그룹으로 분할된다. 이 과정에서 소요시간은 O(n)이고, 분할 후 large group의 최대 크기는 (3n-1)/4이다. 왜냐하면 good 분할만 일어난다고 가정하였기 때문이다.(편의상 (3n-1)/4를 (3/4)n으로 하겠음)2번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)2n이다.3번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)3n이다.……..i번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)in이다. 즉, 입력의 크기가 계속해서 줄어들게 된다.그리하여 평균 경우 시간 복잡도는 다음과 같다.O(n + (3/4)n + (3/4)2n + (3/4)3n + … + (3/4)i) = O(n)(입력의 크기는 계속해서 줄어든다. 그리고 분할 된 리스트들 중에서는 가장 큰 것의 입력만을 고려하면 된다. 왜냐하면 작은 리스트들은 고려하지 않기 때문이다.)위 시간복잡도에 2를 곱한다.(평균 2회만에 good 분할이 되기 때문)그리하여 Selection 알고리즘의 시간복잡도는 2XO(n) = O(n)이다. 4. 응용 선택 알고리즘은 정렬을 하지 않고 k번째 작은 수를 선형 시간에 찾을 수 있게 해준다. 따라서 선택 알고리즘은 데이터 분석을 위한 중앙값을 찾는 데 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Quick Select”, AlgoCoding, 2019. 1. 18, http://www.algocoding.net/design/dc/quickselect.html","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 퀵 정렬 (분할정복)","slug":"algo6","date":"2019-01-17T10:07:32.000Z","updated":"2019-02-16T07:41:05.437Z","comments":true,"path":"2019/01/17/algo6/","link":"","permalink":"http://dudri63.github.io/2019/01/17/algo6/","excerpt":"","text":"1. 퀵 정렬이란2. 퀵 정렬 알고리즘3. 시간 복잡도4. 응용 1. 퀵 정렬이란 ‘퀵 정렬(Quick Sort)’은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 정복 후 분할하는 알고리즘이다. 퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다. 퀵 정렬의 아이디어는 피봇(pivot)이라 일컫는 배열의 원소를 기준으로 피봇보다 작은 숫자들은 왼편으로, 피봇보다 큰 숫자들은 오른편에 위치하도록 분할하고, 피봇을 그 사이에 놓는 것이다.단, 피봇은 분할된 왼편이나 오른편 부분에 포함되지 않는다. 위 경우는 피봇을 분할된 왼편과 오른편 부분에 가운데에 위치시켰다. 2. 퀵 정렬 알고리즘 다음은 퀵 정렬 알고리즘이다.123456789101112QuickSort(A, left, right)입력: 배열 A[left]~A[right]출력: 정렬된 배열 A[left]~A[right]if(left&lt;right)&#123; // 원소가 1개일 경우에는 정렬하지 않는다. 피봇을 A[left]~A[right] 중에서 선택, 피봇을 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교, 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고, 피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮긴다. 피봇은 A[p]에 놓는다. QuickSort(A, left, p-1) // 피봇보다 작은 그룹 QuickSort(A, p+1, right) // 피봇보다 큰 그룹&#125; 위 이미지를 이 알고리즘에 적용하여 살펴본다.초기상태의 배열에서 left는 0, right은 8이다.피봇(A[pivot])을 A[0]인 1으로 선택한다.피봇 A[pivot]를 A[left]과 자리를 바꾼다.(이 경우, 피봇과 A[left]가 일치)피봇과 배열의 각 원소들과 비교를 실시하여 자리를 옮긴 뒤 피봇의 위치를 A[p]로 옮긴다.이 과정은 아래 그림에 잘 나와 있다. 2개의 인덱스가 A[left+1], A[right]에서 출발하여 각각 오른쪽, 왼쪽으로 이동하면서, 비교를 진행한다.왼쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 작을 경우 정지,오른쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 클 경우 정지한다.양 쪽의 인덱스가 모두 정지하면 교환한다.교환한 후 인덱스는 다시 각각 오른쪽 왼쪽으로 이동하면서, 위 작업을 반복한다.작업을 계속 실시하다가 두 인덱스가 엇갈려서 지난 경우, stop한다.이 후, 피봇의 위치를 가운데로 옮긴다. 위 작업을 실시하면 피봇을 기준으로 왼쪽 부분 리스트와 오른쪽 부분 리스트가 생긴다.각 리스트들에 대해서도, 이 작업을 반복, 배열의 원소가 1개만 남을 때까지 반복한다. 3. 시간 복잡도 퀵 정렬의 성능은 기본적으로 피봇 선택이 결정한다.항상 1/2씩 분할한다면 최선의 경우가 되지만(O(nlogn))(합병 정렬과 일치),피봇으로 가장 작은 숫자 또는 가장 큰 숫자가 선택되면, 최악의 경우가 된다.(O(n2)) 최선의 경우 최악의 경우 그럼에도 불구하고 퀵 정렬은 합병정렬보다 빠를뿐 아니라 정렬 알고리즘 중에서 평균적으로 가장 빠르다.퀵 정렬을 불필요한 데이터 이동을 줄이고, 먼 거리의 데이터를 교환, 한 번 결정된 피봇들이 추후 연산에서 제외되는 특성 때문이다. 피봇 선정 방법 퀵 저렬의 불균형한 분할을 완화시키기 위해서, 일반적으로 다음과 같은 피봇 선정 방법이 사용된다. 랜덤하게 선정 세 숫자의 중앙 값으로 선정하는 방법 입력의 크기가 매우 클 때, 퀵 정렬의 성능을 더 향상시키기 위해서, 삽입 정렬이 동시에 사용되기도 한다. 퀵 정렬을 재귀 호출로 수행되어 문제가 크기가 작아지면 중단하고, 삽입 정렬을 사용하면 효율적이다. 4. 응용 퀵 정렬은 커다란 크기의 입력에 대해서 가장 좋은 성능을 보이는 정렬 알고리즘이다. 퀵 정렬은 실질적으로 어느 정렬 알고리즘보다 좋은 성능을 보인다. 생물 정보 공학에서 특정 유전자를 효율적으로 찾는 데 퀵 정렬이 사용되곤 한다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “[알고리즘] 퀵 정렬(quick sort)이란”, Heee’s Development Blog, 2019. 1. 17, https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 합병 정렬 (분할정복)","slug":"algo5","date":"2019-01-17T07:41:43.000Z","updated":"2019-02-16T07:40:58.497Z","comments":true,"path":"2019/01/17/algo5/","link":"","permalink":"http://dudri63.github.io/2019/01/17/algo5/","excerpt":"","text":"1. 합병 정렬이란?2. 합병 정렬 알고리즘3. 시간 복잡도4. 응용 1. 합병 정렬이란? ‘합병 정렬(Merge Sort)’은 입력이 2개의 부분문제로 분할, 부분 문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다. 합병 과정이 문제를 정복한다는 것이 중요하다.합병(merge)이란 2개의 각각 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것이다. 2. 합병 정렬 알고리즘 다음은 분할 정복에 기반을 둔 합병 정렬 알고리즘이다.123456789MereSort(A,p,q)입력: A[p]~A[q]출력: 정렬된 A[p]~A[q]if(p &gt; q) &#123; // 배열의 원소의 수가 2개 이상이면, k = [(p+q)/2] // (k는 배열을 반으로 나누기 위한 중간 원소의 인덱스이다.) MergeSort(A,p,k) // 앞부분 재귀 호출 MergeSort(A,k+1,q) // 뒷부분 재귀 호출 A[p]~A[q]와 A[k+1]~A[q]를 정렬된 형태로 합병한다.&#125; 분할하여 재귀 호출하는 것은 line 6, 7에서 수행되고, 합병은 line 8에서 수행된다. 위 그림에 이 알고리즘을 적용하여 살펴본다. 그림에서 가장 상위에 있는 배열을 A, p를 7, q를 0이라고 한다. 그리하여 k는 3이 되고, 배열 A는 A[0]~A[3], A[4]~A[7] 두 부분으로 나뉜다. 2번을 배열의 원소가 한 개씩 남을 때까지 반복한다. 원소가 단 1개인 배열들을 2개씩 합병한다.(합병이란 2개의 정렬된 숫자들을 1개의 정렬된 숫자들로 합치는 것) 분할된 배열들이 완성된 한 개의 배열이 될 때까지 4번을 반복한다. 3. 시간 복잡도 정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 나타낸다.위 그림에서 알고리즘이 수행한 비교 횟수를 본다.분할하는 부분은 배열의 중간 인덱스 계산과 2번의 재귀 호출을 하는 것이므로 O(1) 시간이 걸린다.(비교 연산 및 이동 연산이 수행되지 않기 때문)이에 반해, 합병의 수행 시간은 입력의 크기에 비례한다.2개의 정렬된 배열 A, B의 크기가 각각 n, m이라면 최대 비교 횟수는 (n+m-1)이다.마지막에 합병되는 숫자는 비교할 대상이 없으므로, -1을 한다. 예를들어, 위 그림에서 {3,27,38,43} 배열과 {9,10,82} 배열을 합병하는 과정을 본다.3과 9를 비교, 최종 배열 {3}27과 9를 비교, 최종 배열 {3,9}27과 10을 비교, 최종 배열 {3,9,10}27과 82를 비교, 최종 배열 {3,9,10,27}38과 82를 비교, 최종 배열 {3,9,10,27,38}43과 82를 비교, 최종 배열 {3,9,10,27,38,43,82}총 6번의 비교를 하였다.(이 경우는 불운한 경우로서, 비교 횟수가 n+m-1로서 비교를 할 수 있는 최대의 경우만큼 비교하였다.) 즉, 1회 합병의 시간복잡도는 O(n+m)이다. 그러나 비교 횟수를 직접 세보는 것보다 더 쉬운 계산은 층별로 살피는 것이다. 위 그림에서 합병 과정은 총 3개의 층으로 이루어져 있는데, 각 층에서 모든 숫자가 합병에 참여하고 있다.앞서 알아보았 듯이, 합병은 입력의 크기에 비례하므로 각 층에서 수행된 비교 횟수는 O(n)이다.그런데, 층이 높아질수록(아래로 올라갈수록) 입력의 크기(배열의 크기)가 반씩 줄어든다.즉, 다음과 같다. 1층 : n/23 = 1 / {38}, {27}, {43}, {3}, {9}, {82}, {10} (n은 7) 2층 : n/22 = 2 / {27,38}, {3,43}, {9,82}, {10} 3층 : n/2 = 4 / {3,27,38,43}, {9,10,82} k번 1/2로 분할하였으면 k개의 층이 생기는 것이고, k=log2n임을 알 수 있다.결과적으로 합병 정렬의 시간복잡도는 (층수)XO(n) = log2nXO(n) = O(nlogn)이다.(각 층마다 모든 입력의 합은 n이다. 헷갈리지 말자. 그림을 보자.) 합병 정렬 알고리즘의 공간 복잡도는 O(n)이다.(단점)왜냐하면 입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요하기 때문이다. 2개의 정렬된 부분을 하나로 합병하는 데 있어서, 합병된 결과를 저장할 곳이 필요하다. 4. 응용 합병 정렬은 외부정렬의 기본이 되는 정렬 알고리즘이다. 연결 리스트에 있는 데이터를 정렬할 때 퀵 정렬이나 힙 정렬보다 훨씬 효율적이다. CPU와 GPU를 이용한 병렬 프로세싱에서도 합병 정렬 알고리즘이 활용된다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Merge Sort”, Wikipedia, 2019. 1. 17, https://en.wikipedia.org/wiki/Merge_sort “3장분할정복알고리즘-0”, 영산대학교 교수 블로그, 2017. 1. 23, https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Sort","slug":"Sort","permalink":"http://dudri63.github.io/tags/Sort/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 분할 정복 알고리즘","slug":"algo4","date":"2019-01-16T12:37:50.000Z","updated":"2019-02-16T07:40:52.869Z","comments":true,"path":"2019/01/16/algo4/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo4/","excerpt":"","text":"1. 분할 정복 알고리즘이란?2. 분할 정복 알고리즘의 분류 1. 분할 정복 알고리즘이란? ‘분할 정복(Divide-and-Conquer) 알고리즘’이란 주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다.분할된 입력에 대하여 동일한 알고리즘을 적용 및 계산하고 결과들을 취합하여 원래 문제의 결과를 얻는다.분할된 입력에 대한 문제를 부분문제(subproblem)라고 하고, 부분문제의 해를 부분해라고 한다. 부분문제는 더이상 분할할 수 없을 때까지 계속 분할한다. 위 이미지는 분할 정복의 예이다. 그렇다면 입력 크기가 n일 때 총 몇 번 분할하여야 더 이상 분할할 수 없는 크기인 1이 될까? 답을 계산하기 위해 분할한 총 횟수를 k라고 하고, 1번 분할할 때마다 각각의 입력 크기가 절반씩 줄어든다고 가정한다. 이 때, k번 분할하였으면, 입력의 크기는 n/2k이고, 입력 크기가 n/2k=1일 때 더 이상 분할할 수 없으므로, k = log2n이다. 2. 분할 정복 알고리즘의 분류 분할 정복 알고리즘은 분할되는 부분문제의 수와 부분문제의 크기에 따라서 다음과 같이 분류할 수 있다. 입력이 2개의 부분문제로 분할, 부분문제의 크기가 1/2로 감소하는 알고리즘-&gt; 합병 정렬(Merge Sort) 입력이 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘-&gt; 퀵 정렬(Quick Sort) 입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없는 알고리즘-&gt; 이진 탐색(Binary Search) 입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘-&gt; 선택 문제(Selection) Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013 “Divide-and-conquer algorithm”, Wikipedia, 2019. 1. 16, https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"},{"name":"Divide-and-Conquer","slug":"Divide-and-Conquer","permalink":"http://dudri63.github.io/tags/Divide-and-Conquer/"}]},{"title":"[Algorithm] 알고리즘을 배우기 위한 준비(2)","slug":"algo3","date":"2019-01-16T09:41:23.000Z","updated":"2019-02-16T07:40:47.085Z","comments":true,"path":"2019/01/16/algo3/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo3/","excerpt":"","text":"4. 알고리즘의 분류5. 알고리즘의 효율성 표현6. 복잡도의 점근적 표기7. 왜 효율적인 알고리즘이 필요한가? 4. 알고리즘의 분류 알고리즘은 문제의 해결 방식에 따라 다음과 같이 분류된다. 분할 정복 알고리즘(Divide-and-Conquer) 그리디 알고리즘(Greedy) 동적 계획 알고리즘(Dynamic Programming) 근사 알고리즘(Approximation) 백트래킹 기법(Backtracking) 분기 한정 기법(Branch-and-Bound) 이 외에도 랜덤 알고리즘, 병렬 알고리즘, 분산 알고리즘, 양자 알고리즘, 유전자 알고리즘 등이 있다.문제에 따라 어떤 알고리즘이 더 효율적일지는 다를 것이다.또한, 이름 지어지지 못한 알고리즘들도 다수 존재한다.위와 같이 해결 방식에 따른 알고리즘 분류 외에도 문제에 기반을 두어 알고리즘을 분류하기도 한다.정렬 알고리즘, 그래프 알고리즘, 기하 알고리즘 등이 그 예이다. 5. 알고리즘의 효율성 표현 알고리즘의 효율성은 알고리즘의 ‘수행 시간’ 또는 알고리즘이 수행하는 동안 사용되는 ‘메모리 공간의 크기’로 나타낼 수 있다. 이들을 각각 ‘시간복잡도’, ‘공간복잡도’라고 한다. 일반적으로 알고리즘들을 비교할 때에는 시간복잡도가 주로 사용된다. 알고리즘을 프로그램으로 구현 및 실행 시켜 시간을 측정할 수 있으나, 이러한 방법은 객관적으로 평가하기가 어렵다. 왜냐하면 컴퓨터 환경, 프로그래밍 언어, 프로그래머 실력 등에 의하여 달라질 수 있기 때문이다. 그리하여 시간복잡도는 알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수로 표현한다.예를 들어, n장의 숫자 카드 중에서 최대 숫자를 찾는데, 순차탐색으로 찾을 경우, (n-1)번의 비교를 수행한다. 이 경우, 시간복잡도는 (n-1)이다. 알고리즘의 복잡도를 표현하는 대는 다음과 같은 분석 방법들이 있다. 최악 경우 분석(worst case analysis) 평균 경우 분석(average case analysis) 최선 경우 분석(best case analysis) 일반적으로 ‘최악 경우 분석’으로 알고리즘의 복잡도를 나타낸다. 6. 복잡도의 점근적 표기 시간복잡도, 공간복잡도는 입력 크기에 대한 함수로 표기한다.이 때, 함수는 주로 다항식인데, 이를 단순하게 나타내기 위해 ‘점근적 표기(asymptotic notation)‘를 사용한다. 이는 입력 크기 n이 무한대로 커질 때의 복잡도를 간단하게 표현하기 위함이다. 예를 들어, 3n3-15n2+10n-18을 n3으로, 4n+6을 n으로 단순화시킨다.이 단순화된 식에 상한, 하한, 동일한 증가율과 같은 개념을 적용하여, 다음과 같이 점근적 표기를 사용한다. O(Big-Oh)-표기 : 점근적 상한 Ω(Big-Omega)-표기 : 점근적 하한 θ(Theta)-표기 : 상한과 하한이 동시에 적용되는 경우 O-표기는 복잡도의 ‘점근적 상한’, Ω-표기는 복잡도의 ‘점근적 하한’, θ-표기는 복잡도의 ‘상한과 하한이 동시에 적용’되는 경우를 나타낸다. 복잡도가 f(n) = 2n2-8n+3이라면, f(n)의 O-표기는 O(n2)이다. 의미는 다음과 같다.f(n)의 단순화된 표현 n2에 임의의 상수 c를 곱한 cn2이 n이 증가함에 따라 f(n)의 상한이 된다. 단, c&gt;0 (cn2은 n0 이상일 때, 항상 f(n)보다 큼) 마찬가지로, 교차점 이후 상한 관계를 만족하는 어떤 양수 c가 존재한다면, f(n) = O(n2)이다. f(n)의 Ω-표기는 Ω(n2)이다. 단, 의미는 ‘n이 증가함에 따라 2n2-8n+3이 cn2보다 작을 수 없다.’이다. 그렇기 때문에 이 경우 c=1이다. θ-표기는 복잡도의 O-표기와 θ-표기가 같은 경우에 사용한다. 의미는 ‘f(n)은 n이 증가함에 따라 n2과 동일한 증가율을 가진다.’라는 뜻이다. f(n) = 2n2+10n+3 = O(n2) = Ω(n2)이므로, f(n) = θ(n2)이다. 위 그래프에서 n0보다 큰 모든 n에 대해서 θ-표기가 상한과 하한을 동시에 만족한느 것을 보여준다. 7. 왜 효율적인 알고리즘이 필요한가? 입력이 커질수록 알고리즘에 따른 수행 시간의 차이가 매우 커지게 된다. 효율적인 알고리즘은 값비싼 하드웨어의 기술 개발보다 훨씬 더 경제적이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"}]},{"title":"[Algorithm] 알고리즘을 배우기 위한 준비(1)","slug":"algo2","date":"2019-01-15T17:08:43.000Z","updated":"2019-02-16T07:40:41.725Z","comments":true,"path":"2019/01/16/algo2/","link":"","permalink":"http://dudri63.github.io/2019/01/16/algo2/","excerpt":"","text":"1. 알고리즘이란?2. 최초의 알고리즘3. 알고리즘의 표현 방법 1. 알고리즘이란? 알고리즘은 문제를 해결하는 단계적 절차 또는 방법이다.컴퓨터 분야에서는 컴퓨터를 이용하여 해결할 수 있는 문제여야 한다. 다음은 알고리즘의 일반적인 특성이다.정확성 : 모든 입력에 대하여 원칙적으로 올바른 답을 출력해야 한다.수행성 : 각 단계는 컴퓨터에서 수행이 가능하여야 한다. 애매모호한 표현이 있게 될 경우, 컴퓨터에서 수행할 수 없다.유한성 : 알고리즘은 일정한 시간 내에 종료되어야 한다.효율성 : 알고리즘은 항상 시간적, 공간적인 효율을 갖도록 고안되어야 한다. 2. 최초의 알고리즘 가장 오래된 알고리즘은 기원전 300년경에 만들어진 유클리드의 최대공약수를 찾는 알고리즘이다.유클리드는 2개의 자연수의 최대공약수는 ‘큰 수에서 작은 수를 뺀 수’와 ‘작은 수’와의 최대공약수와 같다는 성질을 이용하였다. 예를 들어, 22와 10의 최대공약수는 12(22-10), 10(작은 수)의 최대 공약수와 같다.이것을 반복하면 다음과 같다.최대 공약수(22, 10)= 최대공약수(22-10, 10) = 최대공약수(12, 10)= 최대공약수(12-10, 10) = 최대공약수(2, 10)= 최대공약수(10-2, 2) = 최대공약수(8, 2)= 최대공약수(8-2, 2) = 최대공약수(6, 2)= 최대공약수(6-2, 2) = 최대공약수(4, 2)= 최대공약수(4-2, 2) = 최대공약수(2, 2)= 최대공약수(2-2, 2) = 최대공약수(0, 2)= 최대공약수(2, 0) = 2(단, 최대공약수(a, 0) = a 라고 한다.) 위 예시를 뺄셈 대신 나눗셈을 사용할 경우 매우 빠르다.12345Euclid(a,b)입력: 정수 a,b; 단, a&gt;=b&gt;=0출력: 최대공약수(a,b)if(b=0) return areturn Euclid(b, a mod b) 이 경우, Euclid(22, 10)에 대하여 위 알고리즘이 수행되는 과정은 다음과 같다.b = 10이므로, Euclid(10, 22 mod 10) = Euclid(10 ,2)이 호출b = 2이므로, Euclid(2, 10 mod 2) = Euclid(2,0)이 호출b = 0이므로, return a, 최종적으로 2를 반환한다. 3. 알고리즘의 표현 방법 알고리즘의 형태는 단계별 절차이므로, 컴퓨터 프로그래밍 언어로만 표현할 필요는 없다.그러나 일반적으로 프로그래밍 언어와 유사한 의사 코드로 표현한다.이전 포스트에서 다룬 ‘최대 숫자 찾기’ 알고리즘은 다음과 같다. 보통 말로 표현한 알고리즘12345첫 카드의 숫자를 읽고 머릿속에 기억해 둔다.다음 카드의 숫자를 읽고, 그 숫자를 머릿속의 숫자와 비교한다.비교 후 큰 숫자를 머릿속에 기억해 둔다.다음에 읽을 카드가 남아 있으면 line 2로 간다.머릿속에 기억된 수자가 최대 숫자이다. 의사 코드로 표현한 알고리즘1234max=A[0]for i = 1 to 9 if(A[i] &gt; max) max = A[i]return max 위 경우는 카드가 10장 있다고 가정한 경우이다. 알고리즘이 매우 간단하면, 보통 말로도 표현할 수 있으나, 복잡하면 표현하기 어렵다.그리하여 많은 경우 알고리즘을 의사코드로 표현한다.‘플로우 차트’형식으로도 알고리즘을 표현하기도 하지만, 매우 제한적인 경우이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"}]},{"title":"[Algorithm] 알고리즘의 첫걸음","slug":"algo1","date":"2019-01-15T12:02:20.000Z","updated":"2019-02-16T07:40:35.937Z","comments":true,"path":"2019/01/15/algo1/","link":"","permalink":"http://dudri63.github.io/2019/01/15/algo1/","excerpt":"","text":"1. 최대 숫자 찾기2. 임의의 숫자 찾기3. 동전 거스름돈4. 한붓 그리기5. 미로 찾기6. 가짜 동전 찾기7. 독이 든 술단지 알고리즘이란 문제를 해결하기 위한 단계적인 절차이다.주어진 문제에 대하여 여러 종류의 알고리즘이 있을 수 있지만, 보다 더 효율적인 알고리즘을 고안하는 것이 중요하다. 1. 최대 숫자 찾기 임의의 숫자가 적혀진 카드 10장이 바닥에 놓여있는 상황을 가정한다.가장 큰 숫자가 적힌 카드를 찾는 방법들은 무엇인가? 한 가지 방법은 카드의 숫자를 하나씩 비교, 가장 큰 숫자를 기억해가며 진행하는 방법이다.이러한 방식을 ‘순차탐색(Sequential Search)’이라고 한다. 2. 임의의 숫자 찾기 위와 같은 상황에서 특정한 숫자가 적힌 카드를 찾는 방법들은 무엇인가? 한 가지 방법은 찾으려고 하는 특정 숫자를 머리 속에 기억하고 펼쳐진 카드를 한 장씩 읽으며 해당 숫자를 찾는다.이러한 방식 역시 ‘순차탐색’을 이용한 것이다. 그런데, 10장의 카드가 오름차순으로 미리 정렬되어 있다고 가정한다.이러한 경우에는 순차탐색보다 더 효율적인 방법이 있다. 오름차순으로 정렬된 데이터를 반으로 나누고 나누어진 반을 다시 반으로 나누는 것을 반복하면서 원하는 데이터를 찾는다.이러한 탐색 알고리즘을 ‘이진탐색(Binary Search)’이라고 한다. 3. 동전 거스름돈 물건을 사고 거스름돈을 동전으로 받는 상황을 가정한다.대부분의 사람들은 거스름 돈으로 적은 수의 동전을 받기를 원한다.예를 들어, 거스름돈이 700원이라면 500원짜리 1개, 100원짜리 2개를 받기를 원한다.특별한 경우를 제외하고는 100원짜리 7개, 또는 10원짜리 70개를 받기를 원하지 않는다.그렇다면, 적은 수의 동전을 거스름돈으로 받기 위한 일반적인 방법은 무엇인가? 일반적으로 거스름돈에 대하여 가장 큰 액면의 동전부터 차례로 고려한다.남은 거스름돈 액수를 넘지 않는 한도에서 가장 큰 액면의 동전을 계속하여 선택하는 방법이다.즉, 710원이 거스름돈일 경우, 500원짜리부터, 100원, 10원 순서대로 선택한다.(710 - 500X1 = 210, 210 - 100X2 = 10, 10 - 10X1 = 0)이러한 알고리즘을 ‘그리디(Greedy) 알고리즘’이라고 한다. 4. 한붓그리기 종이에서 연필을 떼지 않고 그리는 것을 한붓그리기라고 한다.어느 한 점에서 출발하여 모든 선분을 한 번만 지나서 출발점으로 돌아오되, 그리는 동안 종이에서 연필이 떨어져서는 안 된다. 단, 한 점을 여러 차례 방문하여도 괜찮다.한붓그리기의 경우, 어떻게 해결 방안을 찾을 것인가? 현재 점으로부터 진행하고자 하는 점을 지나서 현재 점으로 돌아오는 ‘사이클(cycle)’을 찾는다. 5. 미로 찾기 복잡한 미로 속에 갇혀있을 때, 미로에서 탈출하는 방법은 무엇인가?일반적인 방법은 현 위치에서 한 방향을 선택하여 이동 후, 길이 막혀 있으면 다시 돌아 나와서 다른 방향으로 시도하는 것을 반복하는 것이다.그러나 이러한 방법은 매우 비효율적이다. 미로에서 나가는 방법 중 하나는 ‘오른속 법칙’을 이용하는 것이다. 벽에 오른손을 댄 뒤, 출구가 나올 때까지 오른속을 벽에서 떼지 않고 걸어간다.이러한 방법은 크레타 섬 미로의 실타래가 없어도, 미로에 특별한 표시를 하지 않아도 항상 출구를 찾게 해준다. 6. 가짜 동전 찾기 아주 많은 동전 더미 속에 1개의 가짜 동전이 섞여 있는 상황을 가정한다.가짜 동전은 눈으로 식별하 수 없으며, 오직 양팔 저울만을 이용해서 찾을 수 있다.(가짜 동전은 가볍다.)가능한 저울에 동전을 다는 횟수를 줄일 수 있는 방법들은 무엇인가? 첫 째, 임의의 동전 1개를 저울 왼편에 올리고, 나머지 동전을 하나씩 오른편에 올려서 가짜 동전을 찾는다.이 경우, 운이 좋다면 1번만에 가짜 동전을 찾을 수 있다.그러나 최악의 경우, 가짜 동전을 마지막으로 선택한다면, (n-1)번 저울을 재야 한다. 둘 째, 동전을 2개씩 짝을 지어, n/2 짝을 각각 저울에 달아서 가짜 동전을 찾는다.이 경우에도 마찬가지로, 운이 좋으면 첫 번째 짝을 저울에 올렸을 때 바로 가짜 동전을 발견할 수 있다.최악의 경우는 가짜 동전이 포함된 동전 짝을 가장 마지막으로 저울에 올렸을 때인데, 이 때 n/2번의 저울을 재야 한다. 셋 째, 동전들을 2개의 그룹으로 나눈 뒤 저울 양편에 각각 놓는다.그렇다면 2개의 그룹 중 가짜 동전이 어디 속해 있는지 알 수 있다.가짜 동전이 속해 있는 그룹을 다시 2개의 그룹으로 나누고, 위와 같은 작업을 반복한다.이러한 방법은 운이 좋고 나쁘고가 없다. 왜냐하면 가짜 동전은 어차피 마지막에 가서야 발견할 수 있기 때문이다.항상 log2n 횟수를 시행하여야 한다.그러나 동전의 갯수가 매우 많다면, 가장 효율적인 방법이다. 7. 독이 든 술단지 임금의 창고에는 매우 많은 술단지가 있는 상황을 가정한다. 그런데, 술단지 중 하나에 독이 들어가게 되었다.눈으로는 독이 들어간 술을 식별할 수 없다. 또한, 독이 든 술의 특징은 조금만 마셔도 정확히 일주일 뒤에 죽는다는 것이다.임금은 독이 든 술단지를 일주일 만에 찾아내라고 신하들에게 명령을 내렸다.어떻게하면 희생되는 신하의 수를 줄일 수 있을 것인가? 이러한 문제 해결의 핵심은 적은 수의 술단지에 대하여 우선 생각해 보는 것이다.술단지의 수를 늘려가면서 일반적인 규칙을 찾는 것이 중요하다. 술단지가 2개 있다고 가정한다.한 명의 신하가 하나의 술단지의 술을 맛보고 일주일 후 살아 있으면 먹지 않은 술단지에 독이 있는 것이고, 죽는다면 맛본 술단지에 독이 들어 있는 것이다. 술단지가 4개 있다고 가정한다.술단지를 두그룹으로 나눈다.신하 2명이 각 그룹의 술단지 2개 중 하나만을 맛본다.그렇다면, 맛보지 않은 술단지가 2개가 되어 일주일 후, 신하 2명이 모두 살아 있을 경우, 독이 든 술단지가 무엇인지 알 수 없게 된다.따라서, 신하 2명이 맛보지 않은 2개의 술단지 중 하나를 또한 동시에 맛보게 한다.이 경우 4개의 결과가 생기게 된다. 아무도 시음하지 않은 단지에 독이 있으면, 일주일 후 두 신하 모두 살아있다. 신하 A가 혼자 시음한 단지에 독이 있으면, 일주일 후 A만 죽는다. 신하 B가 혼자 시음한 단지에 독이 있으면, 일주일 후 B만 죽는다. A,B 둘 다 시음한 단지에 독이 있으면, 일주일 후 둘 다 죽는다. 그렇다면 술 단지 숫자가 많은 경우에는 어떻게 하여야 하는가?술단지에 ‘2진수’를 부여한다. 다음은 술단지가 8개일 때, 2진수 부여 및 술단지를 맛보는 신하들을 설정한 그림이다. 각 술단지의 번호에서 신하 A는 첫 번째 자리, 신하 B는 두 번째 자리, 신하 C는 세 번째 자리를 담당한다.그리고 술을 맛볼 경우 1로 표시, 그렇지 않을 경우 0으로 표시한다.이렇게 하여 단, 3명의 신하만을 이용하여 일주일 만에 독이 든 술단지가 무엇인지를 알 수 있다. 즉, 술단지를 2진수로 표현한 뒤, 각 비트당 한 명의 신하를 할당하는 방법이다.일반적으로 n개의 단지가 있으면, lob2n명의 신하만이 필요하다.일주일 후에 반드시 독이 든 술단지를 찾을 수 있고, 최소 희생자는 0명, 최대는 log2n명이다. Reference 양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/categories/Algorithm/"},{"name":"Base","slug":"Algorithm/Base","permalink":"http://dudri63.github.io/categories/Algorithm/Base/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://dudri63.github.io/tags/Algorithm/"}]}]}