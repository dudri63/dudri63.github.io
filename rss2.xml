<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Seo&#39;s Blog</title>
    <link>http://dudri63.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 04 Feb 2019 09:14:51 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[DataBase] ER model</title>
      <link>http://dudri63.github.io/2019/02/04/db4/</link>
      <guid>http://dudri63.github.io/2019/02/04/db4/</guid>
      <pubDate>Mon, 04 Feb 2019 08:37:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. ER model&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ER model : Entity-Relationship data model&lt;ul&gt;
&lt;li&gt;high-levl(con
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. </a></p><hr><p><a name="1">1. ER model</a></p><ul><li>ER model : Entity-Relationship data model<ul><li>high-levl(conceptual) data model 중 가장 대중적인 모델</li><li>구성요소 : Entity, Attribute, Relationship, Constraint</li><li>ex. 회사의 ER data model<br><img src="/image/db4-1.png"></li></ul></li><li>Entity : 현실세계에서 독립적인 실체로 존재하는 것</li><li>Attribute : Entity를 묘사하는 특징들<ul><li>동그라미로 표현</li><li>type<ul><li>composite or simple, composite은 하나의 동그라미에 또다른 동그라미가 달린 형태</li><li>single-valued of multivalued(이중타원)</li><li>stored or derived(테우리가 점선)</li><li>NULL values</li><li>Complex attributes</li></ul></li></ul></li><li>Entity type : 같은 attribute를 가지는 entity들의 집합<ul><li>네모로 표현</li><li>보통 entity가 하나로만 구성된 entity type은 만들지 않는다.(예외는 있음)</li><li>key attribute : 같은 Entity type 내에서 각 entity들이<br>&lt;추후 내용 추가 예정&gt;</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>*</p>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/db4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] DB Design</title>
      <link>http://dudri63.github.io/2019/02/04/db3/</link>
      <guid>http://dudri63.github.io/2019/02/04/db3/</guid>
      <pubDate>Mon, 04 Feb 2019 07:54:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. DB Design&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Procedure of DB Design&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. DB Design&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DB desi
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. DB Design</a><br><a href="#2">2. Procedure of DB Design</a></p><hr><p><a name="1">1. DB Design</a></p><ul><li>DB design<ul><li>데이터베이스 스키마를 결정하는 것</li><li>다양한 디자인 방법론들이 존재한다.</li><li>본 포스팅에서는 여러 유저들과 애플리케이션에 의해 공유, 조직에 중요한 데이터베이스임을 가정한다.</li></ul></li><li>Information System<ul><li>특정 기관을 위해 데이터를 수집, 조직하여 저장된 정보를 생성하고 분배하는 수단</li><li>DBS를 이용하기 위해 조직상황을 제공</li><li>DB designer는 제공받은 Information System을 이용하여 Design</li><li>오늘날 micro life cycle</li></ul></li><li>DB design 목표<ul><li>한 개 또는 그 이상의 데이터베이스의 logical, physical design</li><li>현실 세계의 필요 사항을 정확하게 반영</li><li>정확한 평가가 어려움</li><li>정확도, 성능, 자연스러움 중요</li></ul></li><li>DB design 절차<ol><li>요구 수집, 분석</li><li>Conceptual DB design</li><li>DBMS 선택</li><li>Logical design</li><li>Physical design</li><li>시스템 구현 및 튜닝<div align="center"><br><img src="/image/db3-1.png"><br></div></li></ol></li></ul><hr><p><a name="2">2. Procedure of DB Design</a></p><ul><li>Phase 1 : 요구 수집, 분석<ul><li>정보를 수집한 뒤 분석</li><li>요구되는 기술들을 학습 또는 분석</li><li>현재의 기능 환경을 이해</li><li>ex. 회사 DB design을 위한 요구 수집, 분석<br><img src="/image/db3-2.png"><br><img src="/image/db3-3.png"></li></ul></li><li>Phase 2 : Conceptual DB design<ul><li>Conceptual 스키마 디자인 (ER dadta mdoel 등을 이용)</li><li>접근법<ul><li>Centralized(one shot) schema design approach (good option)</li><li>View integration approach (bad option)</li></ul></li><li>전략<ul><li>Top-dwon</li><li>Bottom-up</li></ul></li><li>ex. 회사 DB design을 위한 Coceptual DB design<br><img src="/image/db3-4.png"></li></ul></li><li>Phase 3 : DBMS 선택<ul><li>기술적, 경제적 문제를 고려하여 DBMS를 선택</li><li>DBMS마다 지원하는 데이터 타입이 다름, 하드웨어 타입에 따른 DBMS 이식성이 다름을 유의</li></ul></li><li>Phase 4 : Logical design<ul><li>data moel mapping (conceptual data model -&gt; representaion data model)</li><li>ex. 회사 DB design을 위한 Logical design<br><img src="/image/db3-5.png"></li></ul></li><li>Phase 5 : Physical design<ul><li>특정 파일 구조, 데이터베이스 access path를 선정</li><li>response time, space utilization, transaction throughput 등이 고려됨</li><li>이 과정은 DBMS에 의해 결정됨</li></ul></li><li>Phase 6 : 시스템 구현 및 튜닝</li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/db3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정정 커버 문제 (근사)</title>
      <link>http://dudri63.github.io/2019/02/04/algo36/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo36/</guid>
      <pubDate>Mon, 04 Feb 2019 06:48:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 정점 커버 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 정점 커버 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 정점 커버 문제</a></p><p><strong>‘정점 커버(Vertex Cover)’</strong> 문제는 주어진 그래프 G=(V,E)에서 각 선분의 양 끝점들 중에서 적어도 하나의 끝점을 포함하는 점들의 집합들 중에서 최소 크기의 집합을 찾는 문제이다.<br>정점 커버를 살펴보면, 그래프의 모든 선분이 정점 커버에 속한 점에 인접해 있다.<br>즉 정점 커버는 점들의 집합인데, 그래프의 모든 선분들이 집합내 점들 중 어느 하나라도 연결이 되있어야 한다.</p><p>구체적인 예는 다음과 같다.</p><div align="center"><br><img src="/image/algo36-1.png"><br></div><p>그래프 G에서 정점 커버는 다음과 같다.<br>{1,2,3}, {1,2}, {1,3}, {2,3}, {1}<br>{2}, {3}은 정점 커버가 아니다. 왜냐하면 선분(1,3)과 선분(1,2)를 각각 커버하지 못하기 때문이다.<br>정점 커버 문제는 최소 크기의 집합을 찾는 것이므로 해는 {1}이다.</p><p>주어진 그래프의 모든 선분을 커버하려면 일단 어떤 점을 선택해야 하는지 고려해야 한다.<br>우선 차수(degree)가 높은 점을 우선 선택하면 많은 수의 선분이 커버될 수 있다.<br>이 전략은 <a href="https://dudri63.github.io/2019/01/25/algo15/">‘집합 커버문제’</a>의 근사 알고리즘에서 사용된 것이다. 이 때의 근사 비율은 logn이다.</p><p>또 다른 방법은 점을 선택하는 대신에 선분을 선택하는 것이다.<br>선분을 선택하면 선택된 선분의 양 끝점에 인접한 선분이 모두 커버된다.<br>이 때 정점 커버는 선택된 각 선분의 양 끝점들로 이루어진 집합이다.</p><p>본 포스팅에서는 후자의 방법을 선택하여 정점 커버 문제를 해결한다.</p><p>정점 커버를 만들어가는 과정에서, 새로운 선분은 자신의 양 끝점들이 이미 선택된 선분의 양 끝점들의 집합에 포함되지 않을 때에만 중복을 피하기 위해 선택된다.</p><div align="center"><br><img src="/image/algo36-2.png"><br></div><br>예를 들어, 위 G 그래프에서 1개의 선분이 임의로 선택되었을 때, 선택된 선분 주변의 6개의 선분(점선으로 표시된 선분)은 정점 커버를 위한 선분으로서 선택되지 않는다. 왜냐하면 이미 선택된 선분(파란색 선분)의 양끝점(파란색 점)들이 점선으로 표시된 선분을 모두 커버하기 때문이다.<br><br>이러한 방식으로 선분을 선택하다가 더 이상 선분을 추가할 수 없을 때 중단한다.<br>이렇게 선택된 선분의 집합을 ‘극대 매칭(Maximal Matching)’이라고 한다.<br>매칭(matching)이란 각 선분의 양 끝점들이 중복되지 않는 선분의 집합이다.<br>극대 매칭은 이미 선택된 서분에 기반을 두고 새로운 선분을 추가하려 해도 더 이상 추가할 수 없는 매칭이다.<br><br><strong>**</strong><br><br><a name="2">2. 알고리즘</a><br><br>다음은 극대 매칭을 이용한 정점 커버를 위한 근사 알고리즘이다.<br><br>Approx_Matching_VC<br>입력: 그래프 G=(V,E)<br>출력: 정점 커버<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">입력 그래프에서 극대 매칭 M을 찾는다.</span><br><span class="line">return 매칭 M의 선부의 양 끝점들의 집합</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/image/algo36-3.png"><br></div><p>위 그림에서는 극대 매칭으로서 선분 a, b, c, d, e, f가 선택되었다.<br>근사해는 선분 a, b, c, d, e, f의 양 끝점들의 집합이다.<br>이 경우 12개의 점이다.<br>오른쪽 그래프는 최적해로서 7개의 점으로 구성되어 있다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>Approx_Matching_VC 알고리즘의 시간복잡도는 주어진 그래프에서 극대 매칭을 찾는 과정의 시간복잡도와 같다.<br>극대 매칭을 찾기 위해 하나의 선분 e를 선택한 후 e의 양 끝점들 중 적어도 하나가 이미 선택된 선분의 끝점이라면 e를 그래프에서 제거, 그렇지 않으면 e를 매칭에 추가한다.<br>이 후 e의 양 끝점에 인접한 모든 선분들을 그래프에서 제거해야 한다.<br>따라서 O(n) 시간이 걸린다.<br>입력 그래프의 선분수가 m이면, 각 선분에 대해서 O(n) 시간이 걸리므로, Approx_Matching_VC 알고리즘의 시간복잡도는 O(n)*m = O(nm))이다.</p><hr><p><a name="4">4. 근사 비율</a></p><p>Approx_Matching_VC 알고리즘의 근사 비율을 계산하기 위해 극대 매칭을 ‘간접적인’ 최적해로 사용한다.</p><p>Approx_Matching_VC 알고리즘은 극대 매칭의 각 선분의 양 끝점들의 집합을 정점 커버의 근사해로서 리턴, 근사해의 값은 극대 매칭의 선분 수의 2배이다.<br>(극대 매칭의 선분의 양 끝점들의 수) / (극대 매칭의 선분 수) = 2</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 여행자 문제 (근사)</title>
      <link>http://dudri63.github.io/2019/02/04/algo35/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo35/</guid>
      <pubDate>Mon, 04 Feb 2019 05:52:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 여행자 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 여행자 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 여행자 문제</a></p><p><strong>‘여행자 문제(Traveling Salesman Problem, TSP)’</strong>는 여행자가 임의의 한 도시에서 출발하여 다른 모든 도시를 1회씩만 방문하고 다시 출발했던 도시로 돌아오는 여행 경로의 거리를 최소하하는 문제이다.<br>여기서 다루는 여행자 문제의 조건은 다음과 같다.</p><ul><li>도시 A에서 도시 B로 가는 거리 = 도시 B에서 도시 A로 가는 거리 (대칭성)</li><li>도시 A에서 도시 B로 가는 거리 &lt; 도시 A에서 도시 C를 경유하여 도시 B로 가는 거리 (삼각 부등식 특성)</li></ul><p>TSP를 위한 근사 알고리즘을 고안하려면, 먼저 다항식 시간 알고리즘을 가지면서 유사한 특성을 가진 문제를 찾아서 활용해보는 것이 좋다.<br>이전에 다룬 <a href="https://dudri63.github.io/2019/01/21/algo12/">‘최소 신장 트리 문제(MST)’</a>가 TSP와 유사한 특정을 가진다.<br>최소 신장 트리는 모든 점을 사이클 없이 연결하는 트리 중에서 트리 선분의 가중치의 합이 최소인 트리이다.<br>따라서 모든 점을 연결하고, 선분의 가중치의 합이 최소인 최소 신장 트리의 특서을 응용, 시작도시를 제외한 다른 모든 도시를 트리 선분을 따라 1번씩 방문하도록 경로를 찾는다.</p><p>이러한 과정을 아래의 그림을 이용하여 이해할 수 있다.</p><div align="center"><br><img src="/image/algo35-1.png"><br></div><p>그래프 G에서 크러스컬 또는 프림 알고리즘을 이용하여 최소 신장 트리를 찾는다.<br>임의의 도시(그림에서는 1번)에서 출발하여 트리의 선분을 따라서 모든 도시를 방문하고 돌아오는 도시의 방문 순서를 구한다.<br>[1 2 4 3 4 5 4 6 7 6 4 2 1]<br>마지막으로 이 순서를 따라서 도시를 방문하되 중복 방문하는 도시를 순서에서 제거, 여행자 문제의 근사해를 구한다.<br>단, 출발 도시와 도착 도시는 같으므로 중복을 허용한다.<br>[1 2 4 3 5 6 7 1]</p><p>중복하여 방문하는 도시를 제거하는 과정이 삼각형 부등식 원리가 적용된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 최소 신장 트리에 기반한 여행자 문제의 근사 알고리즘이다.</p><p>Approx_MST_TSP<br>입력: n개의 도시, 각 도시 간의 거리<br>출력: 출발 도시에서 각 도시를 1번씩만 방문, 출발 도시로 돌아오는 도시 순서<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">입력에 대해서 최소 신장 트리를 찾는다.</span><br><span class="line">최소 신장 트리에서 임의의 도시로부터 출발하여 트리의 선분을 따라서 모든 도시를 방문하고 다시 출발했던 도시로 돌아오는 도시 방문 순서를 찾는다.</span><br><span class="line">return 이전 단계에서 찾은 도시 순서에서 중복되어 나타는 도시레르 제거한 도시 순서</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간복잡도</a></p><p>line 1 : 최소 신장 트리를 찾음. 크러스컬이나 프림 알고리즘의 시간 복잡도<br>line 2 : 트리 선분을 따라서 도시 방문 순서를 찾는데 O(n) 시간이 걸림. 왜냐하면 트리의 선분 수가 (n-1)이기 때문이다.<br>(추후 논의 필요)<br>line 3 : line 2에서 찾은 도시 방문 순서를 따라가며, 중복된 도시를 제거 O(n) 시간.</p><p>따라서 크러스컬이나 프림 알고리즘의 시간복잡도와 같다.</p><hr><p><a name="4">4. 근사비율</a></p><p>여행자 문제의 최적해를 실질적으로 알 수는 없다.<br>‘간접적인’ 최적해인 최소 신장 트리 선분의 가중치의 합(M)을 최적해의 값으로 활용한다.<br>실제의 최적해의 값은 M보다 항상 크다.</p><p>line 2 : 최소 신장 트리의 선분을 따라서 도시 방문 순서를 찾을 때 각 선분이 2번 사용된다. 경로의 총 길이는 2M<br>line 3 : 삼각 부등식의 원리 이용, 새로운 도시 방문 순서를 만듬. 경로의 길이가 짧아짐</p><p>알고리즘의 근사비율은 2M/M=2보다 크지 않다.<br>즉, 근사해의 값이 최적해의 값의 2배를 넘지 않는다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 근사 알고리즘</title>
      <link>http://dudri63.github.io/2019/02/04/algo34/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo34/</guid>
      <pubDate>Mon, 04 Feb 2019 05:45:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;NP-완전 문제들은 실생활의 광범위한 영역에 활용되지만, 불행히도 이 문제들을 다항식 시간에 해결할 수 있는 알고리즘이 아직 발견되지 않았다.&lt;br&gt;또한 그렇다고 해서 이 문제들을 다항식 시간에 해결할 수 없다고 증명이 되지도 않았다.&lt;br&gt;그러
        
      
      </description>
      
      <content:encoded><![CDATA[<p>NP-완전 문제들은 실생활의 광범위한 영역에 활용되지만, 불행히도 이 문제들을 다항식 시간에 해결할 수 있는 알고리즘이 아직 발견되지 않았다.<br>또한 그렇다고 해서 이 문제들을 다항식 시간에 해결할 수 없다고 증명이 되지도 않았다.<br>그러나 대부분의 학자들은 다항식 시간 알고리즘으로 NP-완전 문제를 해결할 수 없을 것이라고 생각한다.<br>NP-완전 문제들을 해결하려면 보통 다음의 세 가지 중 하나를 포기한다.</p><ul><li>다항식 시간에 해를 찾는 것</li><li>모든 입력에 대해 해를 찾는 것</li><li>최적 해를 찾는 것</li></ul><p><strong>‘근사(Approximation) 알고리즘’</strong>은 세 번째 것을 포기한다.<br>즉, 최적해에 근사한 해를 찾는 대신 다항식 시간의 복잡도를 가진다.<br>그러나 근사 알고리즘은 최적해를 구하는 것이 아니기 때문에 근사해가 최적해에 얼마나 근사한 것인지를 나타내는 <strong>근사 비율(Approximaton ratio)</strong>을 알고리즘과 함께 제시하여야 한다.</p><p>근사 비율은 근사해의 값과 최적해의 값의 비율로서, 1.0에 가까울수록 정확도가 높은 것이 된다.<br>그런데 근사 비율을 계산하려면 최적해를 알아야 하는 모순이 또한 발생한다.<br>따라서 최적해를 대신할 수 있는 <strong>간접적인</strong> 최적해를 찾고, 이를 최적해로 삼아서 근사 비율을 계산한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] NP-완전 문제</title>
      <link>http://dudri63.github.io/2019/02/04/algo33/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo33/</guid>
      <pubDate>Mon, 04 Feb 2019 04:26:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;‘NP-완전(Nondeterministic Polynomial-Complete)’&lt;/strong&gt; 문제는 &lt;strong&gt;다항식 시간(Polynomial time)&lt;/stron
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1.</a></p><hr><p><strong>‘NP-완전(Nondeterministic Polynomial-Complete)’</strong> 문제는 <strong>다항식 시간(Polynomial time)</strong>의 알고리즘이 아직 발견되지 않은 문제이다.</p><hr><p><a name="1">1. 문제 분류</a></p><p>컴퓨터로 풀 수 있는 모든 문제는 문제를 해결하는 알고리즘의 시간복잡도에 따라 분류될 수 있다.</p><ul><li>다항식 시간복잡도를 가진 알고리즘으로 해결되는 P(plynomial) 문제 집합</li><li>다항식보다 큰 시간복잡도를 가진 알고리즘으로 해결되는 문제 집합</li></ul><p>대부분의 문제들은 <strong>P 문제 집합</strong>에 속한다<br>왜냐하면 문제들을 위한 알고리즘의 시간복잡도가 O(logn), O(n), O(nlogn), O(n<sup>2</sup>), O(n<sup>3</sup>)등이고, 이러한 시간복잡도는 접근적 표기법에 따르면 O(n<sup>k</sup>)에 포함되기 때문이다.</p><p>다항식보다 큰 시간복잡도를 가진 알고리즘으로 해결되는 문제 집합은 다시 여러가지 문제 집합으로 분류된다.<br>그 중 하나가 <strong>NP-완전 문제 집합</strong>이다.<br>NP-완전 문제의 알고리즘 시간복잡도는 지수 시간(exponential time)이다.<br>(ex. O(2<sup>n</sup>, O(n<sup>n</sup>)<br>NP-완전 문제의 특성은 어느 하나의 NP-완전 문제에 대해서 다항식 시간의 알고리즘을 찾아내면, 즉 다항식 시간에 해를 구할 수 있으면, 모든 다른 NP-완전 문제도 다항식 시간에 해를 구할 수 있다는 것이다.</p><p>P 문제 집합과 NP-완전 문제 집합을 모두 포함하는 문제 집합인 <strong>NP 문제 집합</strong>이 있다.<br>NP 문제는 비결정적 다항식 시간 알고리즘을 가진 문제이다.<br>일반적으로 비결정적 다항식 시간 알고리즘을 NP 알고리즘이라고 하는데, NP 알고리즘의 정의는 다음과 같다.</p><p>NP 알고리즘은<br>첫 번째 단계에서 주어진 입력에 대해서 하나의 해를 ‘추측’하고,<br>두 번째 단계에서 그 해를 다항식 시간에 확인, 그 해가 ‘맞다’라고 답한다.<br>즉 해가 맞는지 아닌지를 다항시간 내에 판별할 수 있다.</p><p>NP 알고리즘은 해를 찾는 알고리즘이 아니라, 해를 다항식 시간에 확인하는 알고리즘이다.</p><p>다음은 NP 문제, NP-완전 문제, P 문제 집합 시아의 관계이다.</p><div align="center"><br><img src="/image/algo33-1.png"><br></div><p>P 문제 집합이 NP 문제 집합에 속하는 이유는 P 문제를 해결하는 데 다항식 시간이 걸리므로 이를 NP 알고리즘이 문제의 해를 다항식 시간에 확인하는 것과 대응시킬 수 있기 때문이다. 단, P 문제 집합의 경우는 해를 추측하는 단계가 생략된다.</p><p>&lt;포스팅 작성 중단, 추후 내용 추가 예정&gt;</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>*</p>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] 데이터 모델, DBMS 구조</title>
      <link>http://dudri63.github.io/2019/02/03/db2/</link>
      <guid>http://dudri63.github.io/2019/02/03/db2/</guid>
      <pubDate>Sun, 03 Feb 2019 10:23:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Data Abstraction&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Data model&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. Data Schema, Instance&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 3-
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Data Abstraction</a><br><a href="#2">2. Data model</a><br><a href="#3">3. Data Schema, Instance</a><br><a href="#4">4. 3-level arcitecture, Data independence</a><br><a href="#5">5. DB language</a></p><hr><p><a name="1">1. Data Abstraction</a></p><ul><li>데이터 추상화<ul><li>현실세계의 사물을 개념화, 단순화하고 데이터적인 측면과 기능적인 측면으로 분리 정의</li><li>데이터에 대한 조작을 효과적으로 수행할 수 있는 수단을 제공해주는 작업 또는 기능</li><li>데이터 필수 특징 강조</li><li>프로그램-데이터 독립 허가</li><li>DBMS가 제공하는 기능</li></ul></li></ul><hr><p><a name="2">2. Data model</a></p><ul><li>데이터 모델<ul><li>데이터베이스의 구조를 묘사하는 개념들의 집합</li><li>데이터 추상화가 그 목적</li><li>데이터 구조를 결정</li><li>연산에 대한 내용도 포함</li></ul></li><li>데이터 모델 목록<ul><li>High-level (Conceptual Data model)<ul><li>E-R data moel (Entity-Relationship)이 가장 대중적이다.</li><li>E-R data model : Entity - 현실 세계의 개념이나 사물, Attribute - entitiy의 속성,성질, Relationship - 둘 이상의 entity간의 관계 </li></ul></li><li>Low-level (Pyhsical Data Model)<ul><li>data가 어떻게 file로서 저장되는 지를 묘사한다.(데이터 저장 방법)</li><li>포맷, 순서, 접근 경로 등을 기술</li></ul></li><li>Representation data model<ul><li>Relational data moel 이 가장 대중적이다.</li><li>Relational data moel : 대부분의 DBMS에서 사용, 모든 정보를 ‘표’로 표현</li><li>hierarchical data moel, network data model 등도 있다.</li></ul></li><li>Object-oriented data model<ul><li>conceptual data model에 가까운 새로운 data model</li><li>객체 지향 특성을 가진다.</li></ul></li></ul></li></ul><hr><p><a name="3">3. Database Schema, Instance</a></p><ul><li>데이터베이스 스키마<ul><li>데이터베이스의 묘사(meta db에 포함되어 있음)</li><li>데이터베이스의 구조, 데이터 타입, 제약 조건 등을 포함</li><li>데이터베이스 카탈로그에 저장된다.(meta db는 catalog 형태로 저장됨)</li><li>DDL을 이용하여 DB designer가 변경</li><li>자주 변경되지 않는 편이 좋다.<br><div align="center"><br><img src="/image/db2-1.png"></div></li></ul></li></ul><p></p><ul><li>데이터베이스 인스턴스<ul><li>특정 순간에 데이터베이스에 있는 데이터들</li><li>DML의 update 기능에 의해 자주 변경됨</li><li>현실 세계의 변화 반영이 필수적이다.</li><li>= database state, snapshot<div align="center"><br><img src="/image/db2-2.png"><br></div></li></ul></li></ul><hr><p><a name="4">4. 3-level architecture, Data Independence</a></p><ul><li>3-level architecture<ul><li>DBMS의 특징을 지원하게 위해 고안되었다.<ul><li>프로그램과 데이터 격리</li><li>데이터의 다중뷰 지원</li></ul></li><li>데이터를 3단계(internal level, conceptual level, external level)로 관리<ul><li>이 때 관리를 받는다는 것은 DBMS에 의한 것이다.</li><li>Internal level : 데이터베이스의 물리적인 저장소 구조를 묘사</li><li>Conceptual level : 유저들을 위한 전체 데이터베이스 구조를 묘사</li><li>External level : 특정 그룹의 유저들이 관심있는 데이터베이스의 일부분을 묘사</li></ul></li></ul></li><li>데이터 독립성<ul><li>Data Independence</li><li>3-level arichitecture에 의해 상위 level에 영향을 주지 않고, 해당 level이 바뀔 수 있는 것</li><li>Logical data independece : conceptual level의 변화가 external level에 영향을 주지 않음</li><li>Physical data independence : physical levle의 변화가 conceptual level에 영향을 주지 않음<div align="center"><br><img src="/image/db2-3.png"><br></div></li></ul></li></ul><p>cf. Data model : DB Designer에게 필요한 내용, 3-level arichitecture : DBMS에게 필요한 내용</p><hr><p><a name="5">5. DB language</a></p><ul><li>DDL (Data Definition Language)<ul><li>Schema를 정의(define)하기 위해 이용된다.</li><li>주로 DB designer에 의해 이용</li></ul></li><li>DML (Data Manipulation Language)<ul><li>DB로의 검색, 삽입, 삭제, 업데이트 등을 가능하게 한다.</li><li>DML Commands는 host language에 내장 가능</li><li>Application programmer에 의해 주로 이용된다.</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/db2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] DBS, DB, DBMS, 이용자, DB approach</title>
      <link>http://dudri63.github.io/2019/02/03/db1/</link>
      <guid>http://dudri63.github.io/2019/02/03/db1/</guid>
      <pubDate>Sun, 03 Feb 2019 07:19:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Database System&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Database&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. DBMS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. Database Users&lt;/a&gt;&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Database System</a><br><a href="#2">2. Database</a><br><a href="#3">3. DBMS</a><br><a href="#4">4. Database Users</a><br><a href="#5">5. DB Approach</a></p><hr><p><a name="1">1. Database System</a></p><ul><li>DBS(데이터베이스 시스템) : 자료를 데이터베이스에 저장, 관리하며 필요한 정보를 제공하는 컴퓨터 기반 시스템이다.</li><li>DBS 구성요소 :<ul><li>Database (DB)</li><li>Database management system (DBMS)</li><li>Database users</li></ul></li></ul><hr><p><a name="2">2. Database</a></p><ul><li>데이터베이스<ul><li>상호 관련있는 데이터들의 집합<ul><li>데이터란 의미가 있고, 저장할 수 있는 것이다.</li></ul></li><li>현실 세계의 정보들을 나타낸다.</li><li>특정한 목적을 위하여 설계된다.</li><li>현실 세계의 정보인 sotred data와 stored data를 위한 데이터인 meta data가 저장된다.</li><li>데이터베이스의 예 :<ul><li>University database</li><li>Company database</li></ul></li></ul></li></ul><hr><p><a name="3">3. DBMS</a></p><ul><li>DBMS (Database Management System)<ul><li>데이터베이스를 관리하는 프로그램</li><li>데이터베이스 이용자(user)와 데이터베이스간의 Interface<ul><li>DBMS를 이용하여 이용자는 쉽게 데이터베잇를 생성 및 유지할 수 있다.</li></ul></li></ul></li><li>DBMS의 주요 기능<ul><li>정의 : 데이터에 대한 형식, 구조, 제약조건들을 명세<ul><li>이 때, 데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.(meta data)</li></ul></li><li>구축 : DBMS가 관리하는 기억 장치에 데이터를 저장</li><li>조작 : 특정한 데이터를 검색하기 위한 질의, 데이터 갱신, 보고서 생성 기능 등</li><li>공유 : 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능</li><li>보호 : 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호</li><li>유지보수 : 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능</li></ul></li></ul><hr><p><a name="4">4. Database Users</a></p><ul><li>End Users : application programmer에 의해 개발된 application program을 통해 database에 접근하는 사람들</li><li>Application Programmers : 애플리케이션 개발자<ul><li>시스템 분석에 관한 지식, host language(ex. JSP, ASP)를 알고 있어야 한다.</li><li>SQL의 DML(Data Manipulation Language)을 알아야 한다.</li></ul></li><li>Database designers<ul><li>database를 설계하기 위한 현실 세계의 요구사항들을 파악한다.</li><li>저장될 데이터, 적절한 구조를 선정</li><li>SQL의 DDL(Data definition Language)을 알아야 한다.</li></ul></li><li>DBA (Database Administrators)<ul><li>데이터베이스 접근 권한을 설정한다.</li><li>데이터베이스 운영, 관리를 책임진다.</li></ul></li></ul><div align="center"><br><img src="/image/db1-1.png"><br></div><hr><p><a name="5">5. DB Approach</a></p><ul><li>DB Approach<ul><li>data를 유지하는 저장소는 한 개 있다.(여러 저장소를 사용하지 않는다.)</li><li>저장소는 다양한 유저들에 의해 접근될 수 있다.</li></ul></li><li>DB Approach 특징<ul><li>자기기술성(Self-describing nature of a database system)</li><li>프로그램과 데이터 격리(Insulation between programs and data)</li><li>데이터 추상화(Data abstraction)</li><li>데이터의 다중뷰(multiple view) 지원</li><li>data 공유 &amp; 멀티유저(multi user)</li></ul></li></ul><hr><ul><li>자기기술성<ul><li>데이터베이스 시스템은 데이터베이스에 포함된 데이터 + 설명(meta)</li><li>파일 시스템과 구별되는 특징</li><li>데이터베이스 카탈로그(meta database)는 stored database와 같은 방식으로 접근할 수 있다.</li><li>DBMS가 데이터의 삽입 및 삭제를 데이터/구조적 종속 없이 가능하게 해준다.</li></ul></li><li>프로그램과 데이터 격리<ul><li>단일한 응용 프로그램 내에서 데이터를 개별적으로 관리하는 방식은 데이터 구조 등이 변경되면 응용 프로그램도 수정되어야 한다.</li><li>하지만 데이터베이스는 저장 구조 등을 수정하는 것이 응용 프로그램에 영향을 미치지 않는다.</li></ul></li><li>데이터 추상화 <ul><li>복잡한 데이터베이스의 구조에 대한 정보를 감추고, 각 사용자에게는 ‘뷰’를 제공한다.</li><li>실제로는 복잡한 구조지만 상부 이용자에게는 간단하게 보이도록 한다.</li></ul></li><li>데이터 다중뷰 지원<ul><li>뷰 : 데이터베이스의 subset</li><li>이용자마다 다른 목적을 커버 가능하다.</li><li>각 이용자에게 필요한 것만 보이게 함으로써 보안성을 높일 수 있다.</li><li>처리 시간이 걸린 다는 단점이 있다.</li></ul></li><li>data 공유 &amp; 멀티유저(multi user)<ul><li>DBMS는 다수 유저의 동시 접근을 허가한다.</li><li>‘동시성 제어’</li></ul></li></ul><hr><p>cf. 데이터베이스의 추가적인 특징</p><ul><li>데이터베이스는 동일한 내용의 데이터가 중복되어 있지 않아야 하고, 다양한 접근 방식이 마련되어 있어야 하며, 검색이나 갱신이 효율적으로 이루어질 수 있도록 해야 한다.</li><li>RAM, ROM 같은 주기억장치가 아닌 컴퓨터에서 사용할 수 있는 보조기억장치에 저장된다.</li></ul><p>cf. 파일 시스템</p><p>데이터 독립성, 데이터 중복성, 무결성 보장, 동시 접근 등에 문제가 있음<br>-&gt; DB approach의 장점과 대비</p><hr><ul><li>DB Approach의 장점<ul><li>중복 최소화</li><li>권한 없는 접근 제한</li><li>storage stucture 제공 및 효율적인 검색 프로세싱 가능(Indexes, Buffering, Caching, etc.)</li><li>Backup, Recovery</li><li>다양한 이용자 interface를 제공</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li><li>데이터베이스, 위키피디아, 2019. 2. 3, <a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C" rel="external nofollow noopener noreferrer" target="_blank">https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C</a></li><li>데이터베이스, 나무위키, 2019. 2. 3, <a href="https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2" rel="external nofollow noopener noreferrer" target="_blank">https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/db1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 외부 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo32/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo32/</guid>
      <pubDate>Sun, 03 Feb 2019 06:17:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 외부 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 외부 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 외부 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 외부 정렬</a></p><p><strong>‘외부 정렬(External Sort)’</strong>은 입력 크기가 매우 커서 읽고 쓰는 시간이 오래 걸린느 보조 기억 장치에 입력을 저장할 수 밖에 없는 상태에서 수행되는 정렬을 일컫는다.<br>예를 들어, 컴퓨터의 주기억 장치의 용량이 1GB이고, 정렬할 입력의 크기가 100GB이면, 어떤 내부정렬 알고리즘으로도 정렬할 수 없다.</p><p>외부 정렬은 입력을 분할, 주기억 장치에서 수용할 만큼의 데이터에 대해서만 내부정렬을 수행, 그 결과를 보조 기억 장치에 저장한다.<br>예를 들어, 100GB의 데이터를 1GB만큼씩 주기억 장치로 읽어 들이고, 퀵 정렬과 같은 내부정렬 알고리즘을 이용하여 정렬, 이 후, 다른 보조 기억 장치에 저장한다.<br>이것을 반복하면 원래의 입력 100GB가 100개씩 정렬된 블록으로 분할되어 보조 기억 장치에 저장된다.</p><div align="center"><br><img src="/image/algo32-1.png"><br></div><p>그 다음으로 정렬된 블록들을 하나의 정렬된 거대한 블록(100GB)으로 만들어야 한다.<br>이를 위해 합병(merge)를 반복 수행한다.<br>즉, 블록들을 부분적으로 주기억 장치에 읽어 들여서, 합병을 수행, 부분적으로 보조 기억 장치에 쓰는 과정을 반복한다.</p><p>다음은 1GB 블록 2개가 2GB 블록 1개로 합병되는 과정이다.</p><div align="center"><br><img src="/image/algo32-2.png"><br><img src="/image/algo32-3.png"><br></div><p>2개의 블록을 부분적으로 주기억 장치로 읽어들인다.</p><p>나머지 98개의 블록에 대해서 위 과정을 49회 추가로 반복하면, 2GB 블록 50개가 만들어진다.<br>그 다음에는 2GB 블록 2개씩 짝을 지워 합병시키는 과정을 25회 반복하여, 4GB 블록 25개가 만들어진다.<br>이러한 방식으로 계속 합병을 진행하면, 블록 크기가 2배씩 커지고, 블록의 수는 1/2씩 줄어들어 결국 100GB 블록 1개만 남는다.</p><p>외부정렬 알고리즘은 보조 기억 장치에서의 읽고 쓰기를 최소화하는 것이 중요하다.<br>왜냐하면 보조 기억 장치의 접근시간(access time)이 오래 걸리기 때문이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>ExternalSort<br>입력: 입력 데이터 저장된 입력 HDD<br>출력: 정렬된 데이터가 저장된 출력 HDD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">입력 HDD에 저장된 입력을 크기가 M만큼씩 주기억 장치에 읽어 들인 후 내부 정렬 알고리즘으로 정렬하여 별도의 HDD에 저장한다. 다음 단계에서는 별도의 HDD는 입렬 HDD로 사용, 입력HDD는 출력 HDd로 사용된다.</span><br><span class="line">while (입력 HDD에 저장된 블록 수 &gt; 1) &#123;</span><br><span class="line">  입력 HDD에 저장된 블록을 2개씩 선택, 각각의 블록으로부터 데이터를 부분적으로 주기억 장치에 읽어 들여서 합병을 수행한다. 이때 합병된 결과는 출력 HDD에 저장한다. 단, 입력 HDD가 저장된 블록 수가 홀수일 때에는 마지막 블록은 그대로 출력 HDD에 저장한다.</span><br><span class="line">&#125;</span><br><span class="line">return 출력 HDD</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>외부정렬은 전체 데이터를 몇 번 처리하는가를 가지고 시간복잡도를 측정한다.<br>전체 데이터를 읽고 쓰는 것을 <strong>패스(pass)</strong>라고 한다.</p><p>위 알고리즘의 경우, while-루프를 마치면 1 패스가 수행된 것이다.<br>그러므로 while-루프가 수행된 횟수가 알고리즘의 시간복잡도가 된다.</p><p>입력 크기가 N, 메모리 크기가 m이면, line 3이 한번 수행될 때마다 블록 크기가 2M,4M, 2<sup>k</sup>M으로 증가한다. 만일 마지막에 만들어진 블록 1개의 크기가 2<sup>k</sup>M이면, 이 블록은 입력 전체가 합병된 결과를 가지고 있다. 즉, 2<sup>k</sup>M = N이다.<br>따라서 k = log<sub>2</sub>(N/M)이고, k는 while-루프가 수행된 횟수이다.<br>그러므로 외부정렬의 시간복잡도는 O(log(N/M))이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 기수 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo31/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo31/</guid>
      <pubDate>Sun, 03 Feb 2019 05:53:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 기수 정렬&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 기수 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;‘&lt;strong&gt;기수 정렬(Radix Sort)’&lt;/strong&gt;이란 비교정렬이 아니고, 숫자를 부분적으로 비교하는 정렬
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 기수 정렬</a></p><hr><p><a name="1">1. 기수 정렬</a></p><p>‘<strong>기수 정렬(Radix Sort)’</strong>이란 비교정렬이 아니고, 숫자를 부분적으로 비교하는 정렬이다.<br><strong>‘기(Radix)’</strong>는 특정 진수를 나타내는 숫자들이다.<br>예를 들어, 10진수의 기는 0,1,2,…,9이고, 2진수의 기는 0,1이다.</p><p>기수 정렬은 제한적인 범위 내에 있는 숫자에 대해서 각 자릿수별로 정렬하는 알고리즘이다.<br>기수 정렬의 가장 큰 장점은 어느 비교정렬 알고리즘보다 빠르다는 것이다.</p><p>아래의 예제는 5개의 3자리 십진수가 입력으로 들어왔을 때의 기수 정렬이다.</p><div align="center"><br><img src="/image/algo31-1.png"><br></div><p>먼저 각 숫자의 1의 자리만 비교하여 작은 수부터 큰 수로 정렬한다.<br>이 후, 10의 자리만을 각각 비교하여 정렬한다.<br>단, 10의 자리 숫자가 같을 경우 1의 자리 숫자가 작은 것이 위로 향하도록 한다.</p><p>입력에 중복된 숫자가 있을 때, 정렬된 후에도 중복된 숫자의 순서가 입력에서의 순서와 동일하면 정렬 알고리즘이 ‘안정성(Stability)’을 갖는다.<br>안정한 정렬 알고리즘은 중복된 숫자에 대해 앞서 있던 숫자가 정렬된 후에도 앞서 있고,<br>불안정한 정렬 알고리즘은 정렬 후에 그 순서가 반드시 지켜지지는 않는다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>RadixSort<br>입력: n개의 r진수의 k자리 숫자<br>출력: 정렬된 숫자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to k</span><br><span class="line">  각 숫자의 i자리 숫자에 대해 안정한 행렬을 수행한다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>for-루프가 k번 반복한다.<br>한 번 루프가 수행될 때 n개의 숫자의 i자릿수를 읽으며, r개로 분류하여 개수를 세고, 그 결과에 따라 숫자가 이동하므로 O(n+r)이 된다.<br>따라서 총 시간복잡도는 O(k(n+r)) = O(n)이다.<br>(통상적으로 k나 r은 n보다 매우 작다.)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정렬 문제의 하한 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo30/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo30/</guid>
      <pubDate>Sun, 03 Feb 2019 03:22:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;합병 정렬, 퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 힙 정렬의 공통점은 숫자의 비교가 부분적이 아닌 숫자 대 숫자로 이루어진다는 것이다.&lt;br&gt;이러한 정렬을 &lt;strong&gt;비교 정렬(Comparison Sort)&lt;/strong
        
      
      </description>
      
      <content:encoded><![CDATA[<p>합병 정렬, 퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 힙 정렬의 공통점은 숫자의 비교가 부분적이 아닌 숫자 대 숫자로 이루어진다는 것이다.<br>이러한 정렬을 <strong>비교 정렬(Comparison Sort)</strong>이라고 한다.<br>비교 정렬의 경우에 한해서 문제를 해결하기 위해 필요한 최소 비교 횟수는 어떻게 알 수 있는가?</p><p>어떤 주어진 문제에 대하여 시간복잡도의 <strong>하한(Lower Bound)</strong>이라 함은 어떠한 알고리즘도 문제의 하한보다 빠르게 해를 구할 수 없음을 의미한다.<br>구체적으로 어떤 문제가 가지고 있는 고유한 특성 때문에 어떠한 알고리즘일지라도 해를 구하려면 적어도 하한의 시간복잡도만큼 필요하다는 뜻이다.</p><hr><ol><li>n개의 숫자가 저장된 배열에서 최댓값을 찾는 문제의 하한을 고려한다.<br>즉, 최댓값을 찾기 위해 숫자들을 적어도 몇 번 비교해야 하는지 파악하는 것이다.</li></ol><p>이 문제는 어떤 알고리즘을 이용하여 탐색하던지 간에 적어도 (n-1)번의 비교가 필요하다.<br>왜냐하면 어떤 방식이라도 각 숫자를 적어도 한 번 비교해야 하기 때문이다.</p><ol start="2"><li>n개의 숫자를 비교정렬하는 데 필요한 최소의 비교 횟수, 즉 정렬 문제의 하한을 고려한다.</li></ol><p>예를 들어, 서로 다른 숫자 x,y,z에 대하여 정렬에 필요한 모든 경우의 숫자 대 숫자 비교는 다음 그림과 같다.</p><div align="center"><br><img src="/image/algo30-1.png"><br></div><p>비교 결과가 ‘참’이면 왼쪽으로, ‘거짓’이면 오른쪽으로 분기된다.<br>각 leaf 노드에는 루트로부터의 비교 결과에 따른 정렬된 결과가 저장된다.<br>이러한 트리를 <strong>‘결정 트리(Decision Tree)’</strong>라고 한다.<br>결정 트리의 특징은 다음과 같다.</p><ul><li>leaf 노드의 수는 3!=6이다.</li><li>결정 트리는 이진트리(Binary Tree)이다.</li><li>결정트리에는 정렬을 함에 있어 불필요한 내부 노드가 없다.</li></ul><p>leaf 노드의 수가 3!인 이유는 서로 다른 숫자 3개가 정렬되는 모든 경우의 수가 3!이기 때문이다.<br>결정트리는 각 내부 노드의 비교가 ‘참’일 때와 ‘거짓’일 때 각각 1개의 자식 노드를 가지기 때문에 이진트리이다.<br>또한, 중복 비교를 하는 노드들이 있으나 모두 필요한 내부 노드이다.</p><p>따라서 서로 다른 3개의 숫자들을 비교정렬하기 위해서는 적어도 3번 비교해야 한다.<br>즉, n개의 서로 다른 숫자들을 정렬하기 위해서는 적어도 n번 비교해야 한다.<br>n개의 서로 다른 숫자들을 비교졍렬하는 결정 트리의 높이가 비교 정렬의 하한이 된다.<br>비교 정렬의 하한은 O(nlogn)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 힙 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo29/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo29/</guid>
      <pubDate>Fri, 01 Feb 2019 12:48:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 힙 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 힙 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘힙(
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 힙 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 힙 정렬</a></p><p><strong>‘힙(Heap)’</strong>은 <strong>힙 조건</strong>을 만족하는 <strong>완전 이진 트리(Complete Binary Tree)</strong>이다.</p><p>힙 조건이란 각 노드의 값이 자식 노드의 값보다 커야 한다는 것을 말한다.<br>노드의 값은 <strong>‘우선순위(Priority)’</strong>라고 일컫는다.<br>따라서 힙의 루트에는 가장 높은 우선순위(가장 큰 값)가 저장되어 있다.<br>(단, 값이 작을수록 우선순위가 높은 경우도 있다.)</p><p>완전 이진트리란 마지막 레벨을 제외하고 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 채워지는 이진 트리이다.<br>n개의 노드를 가진 힙은 완전 이진 트리이므로, 힙의 노드가 log<sub>2</sub>n이다.</p><p>아래 그림은 힙의 노드들이 배열에 저장된 모습을 보여준다.</p><div align="center"><br><img src="/image/algo29-1.png"><br></div><p>배열 A에 힙을 저장한다면, A[0]은 비워 두고, A[1]부터 A[n]까지에 힙 노드들을 층별로 왼쪽부터 저장한다.이런 방식으로 저장하면, 트리에서 부모 노드와 자식 노드의 관계를 배열의 인덱스로 쉽게 표현할 수 있다.</p><ul><li>A[i]의 부모 노드 : A[i/2], ex. A[7]=10의 부모 노드 -&gt; A[7/2]=A[3]=80</li><li>A[i]의 왼쪽 자식 노드 : A[2i], ex. A[4]=50의 왼쪽 자식 노드 -&gt; A[4*2]=A[8]=20</li><li>A[i]의 오른쪽 자식 노드 : A[2i+1], ex. A[4]=50의 오른쪽 자식 노드 -&gt; A[4*2+1]=A[9]=40</li></ul><p><strong>‘힙 정렬(Heap Sort)’</strong>은 힙 자료 구조를 이용하는 정렬 알고리즘이다.<br>오름차순의 정렬을 위해 입력 배열을 큰 숫자가 높은 우선순위를 가지는 <strong>최대힙(Maximum heap)</strong>을 만든다.<br>루트에 저장된 가장 큰 수를 배열의 가장 끝으로 이동시킨다.<br>그리고 루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하며 힙 조건을 만족시키고, 힙 크기를 1개 줄인다.<br>이 과정을 반복하여 나머지 숫자들을 정렬하는 것이 힙 정렬 알고리즘이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>HeapSort<br>입력: 입력이 A[1]부터 A[n]까지 저장된 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">배열 A의 숫자에 대해서 힙 자료 구조를 만든다.</span><br><span class="line">heapSize = n// 힙의 크기를 조절</span><br><span class="line">for i=1 to n-1</span><br><span class="line">  A[1] &lt;-&gt; n-1// 루트와 힙의 마지막 노드를 교환한다.</span><br><span class="line">  heapSize = heapSize - 1// 힙의 크기를 1 감소시킨다.</span><br><span class="line">  DownHeap()// 위배된 힙 조건을 만족시킨다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><ul><li>line 1 : 배열 A를 힙으로 만든다.</li><li>line 2 : 현재의 힙의 크기를 나타내는 변수인 heapSize를 n으로 초기화시킨다.</li><li>line 3~6 : for루프가 (n-1)번 수행된다. (n-1)번 수행하는 루프가 종료된 후 루트인 A[1] 홀로 힙을 구성, A[1]에 있는 숫자가 가장 작은 수이므로 루프를 수행할 필요가 없기 때문이다.</li><li>line 4 : 루트와 힙의 마지막 노드와 교환, 루트에는 힙에서 가장 큰 수가 저장되어 있었음.</li><li>line 5 : 힙의 크기를 1 줄인다.</li><li>line 4에서 힙의 마지막 노드와 힙의 루트를 바꾸어 놓았기 때문에 새로이 루트에 저장된 값이 자식 노드의 값보다 작아서 힙 조건이 위배된다.</li><li>line 6 : DownHeap을 수행, 위배된 힙 조건을 해결한다.</li></ul><p>위 과정은 아래 그림으로 설명할 수 있다.</p><div align="center"><br><img src="/image/algo29-2.png"><br></div><p>우선 위 그림은 line 4에서 힙의 루트(90)와 마지막 노드(40)를 바꾸고, 힙의 노드 수를 1개 줄이는 과정이다.<br>이 작업이 끝나면 힙 조건이 위배되고, 이를 해결하기 위해 DownHeap을 수행한다.<br>DownHeap 수행 과정은 아래와 같다.</p><div align="center"><br><img src="/image/algo29-3.png"><br></div><p>새로이 루트에 저장된 40이 루트의 자식 노드들(60,80)보다 작아서 힙 조건 위배, 자식 노드들 중에서 가장 큰 자식인 80과 루트 40을 교환한다.</p><div align="center"><br><img src="/image/algo29-4.png"><br></div><p>40은 또다시 자식 노드들중 하나인 70보다 작기 때문에 힙 조건에 위배, 70과 40을 교환한다.</p><div align="center"><br><img src="/image/algo29-5.png"><br></div><p>힙 조건을 만족하므로 DownHeap을 종료한다.</p><div align="center"><br><img src="/image/algo29-6.png"><br></div><p>힙의 루트(80)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-7.png"><br></div><p>힙의 루트(70)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-8.png"><br></div><p>힙의 루트(60)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-9.png"><br></div><p>힙의 루트(50)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-10.png"><br></div><p>힙의 루트(40)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-11.png"><br></div><p>힙의 루트(30)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-12.png"><br></div><p>힙의 루트(20)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.<br>힙의 크기가 1이 되었으므로 힙 정렬을 마친다.<br>결과로서 배열이 정렬되었음 확인할 수 있다.</p><p>for-루프를 반복할 때마다 힙에서 가장 큰 수를 힙의 마지막 노드와 교환한다.<br>선택 정렬에서 최솟값을 찾는 대신에 최댓값을 찾아서 배열의 뒷부분으로부터 정렬하는 것과 같다.<br>또한 선택정렬은 순차탐색으로 최솟값을 찾는 것에 비해 힙 정렬은 힙 자료구조를 이용하여 최댓값을 찾는다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1에서 힙을 만드는데 O(n) 시간이 걸린다.<br>line 2는 변수를 초기화, O(1) 시간이 걸린다.<br>line 3~6은 for-루프가 (n-1)번 수행, 루프 내부에서 line 4~5에서 O(1)시간이 걸리고, DownHeap은 O(log<sub>2</sub>n) 시간이 거린다.<br>(힙의 높이는 log<sub>2</sub>n을 넘지 않음, 최악의 경우 leaf 노드까지 내려가며 교환한 경우를 가정한다.)<br>힙 정렬의 시간복잡도는 O(n) + (n-1)*O(logn) = O(nlogn)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 쉘 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo28/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo28/</guid>
      <pubDate>Fri, 01 Feb 2019 10:23:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 쉘 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 쉘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 쉘 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 쉘 정렬</a></p><p>버블 정렬이나 삽입 정렬이 수행되는 과정을 살펴보면, 이웃하는 원소의 숫자들끼리의 자리를 이동함으로써 정렬이 이루어진다.<br>그렇기 때문에 위 두 정렬의 경우, 배열되는 과정이 굉장히 느리다.<br>특히 삽입 정렬은 배열의 마지막 원소가 입력에서 가장 작은 숫자라면, 그 숫자가 배열의 맨 앞으로 이동할 때, 다른 모든 숫자들이 1칸씩 오른쪽으로 이동하여야 한다.</p><p><strong>‘쉘 정렬(Shell Sort)’</strong>은 이러한 단점을 보완하기 위해서 삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자을 앞부분으로 ‘빠르게’ 이동시키고, 동시에 앞부분의 큰 숫자는 뒷부분으로 이동시키며, 가장 마지막에는 삽입 정렬을 수행한다.</p><p>다음 예제를 통해 쉘 정렬의 아이디어를 이해한다.</p><div align="center"><br><img src="/image/algo28-1.png"><br><br></div><ul><li>먼저 간격(gap)이 5가 되는 숫자끼리 그룹을 만든다. 만들어지는 그룹은 다음과 같다.<br>[30,80,50], [60,40,30], [90,20,40], [10,10,90], [40,60,80]</li></ul><p><img src="/image/algo28-2.png"></p><ul><li>각 그룹내에서 정렬된 결과를 1줄에 나열하면 다음과 같다.</li></ul><p><img src="/image/algo28-3.png"></p><p><img src="/image/algo28-4.png">  </p><ul><li><p>완벽하지는 않지만 대체로 큰 수가 뒤로, 작은 수가 앞으로 이동하였음을 확인할 수 있다.</p></li><li><p>이 후, 간격을 5보다 작게 하여 또 다시 그룹별로 삽입 정렬을 수행한다.</p></li><li><p>마지막에는 간격(gap)을 1로 하여 수행한다. 이는 삽입 정렬 그 자체이다.</p></li></ul><hr><p><a name="2">2. 알고리즘</a></p><p>ShellSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for each gap h = [h0 &gt; h1 &gt; ... &gt; hk = 1]// 큰 gap부터 차례로</span><br><span class="line">  for i = h to n-1</span><br><span class="line">    CurrentElement = A[i];</span><br><span class="line">    j = i;</span><br><span class="line">    while (j&gt;=h) and (A[j-h] &gt; CurrentElement) &#123;</span><br><span class="line">      A[j] = A[j-h];</span><br><span class="line">      j = j - h;</span><br><span class="line">    &#125;</span><br><span class="line">  A[j] = CurrentElement;</span><br><span class="line">&#125;</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>앞의 예제에 위 알고리즘을 적용하여 쉘 정렬의 과정을 살핀다.</p><ol><li>h = 5 (간격이 5일 때)</li></ol><ul><li>i = 5,6,7,8,9일 때</li></ul><p><img src="/image/algo28-5.png"> </p><ul><li>i = 10,11,12,13,14일 때</li></ul><p><img src="/image/algo28-6.png"> </p><p><img src="/image/algo28-7.png"> </p><ol start="2"><li>h = 3 (간격이 3일 때)</li></ol><ul><li>3개의 그룹으로 나뉘어지고, 각 그룹의 원소는 5개씩이다.</li></ul><p><img src="/image/algo28-8.png"> </p><p><img src="/image/algo28-9.png"> </p><ol start="3"><li>h = 1 (간격이 1일 때, 삽입 정렬과 동일)</li></ol><p><img src="/image/algo28-10.png"> </p><p>쉘 정렬의 수행 속도는 간격 선정에 따라서 좌우된다.<br>지금까지 알려진 가장 좋은 성능을 보이는 간격은 1, 4, 10, 23, 57, 132, 301, 701이다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>쉘 정렬의 최악 경우의 시간 복잡도는 O(n<sup>2</sup>)이다.<br>히바드(Hibbard) 간격 2<sup>k</sup>-1을 사용하면 쉘 정렬의 시간복잡도는 O(n<sup>1.5</sup>)이다.<br>또한 다양한 실험을 통해 쉘 정렬의 시간복잡도는 O(n<sup>1.25</sup>)까지 줄일 수 있다고 알려져 있다.</p><hr><p><a name="4">4. 응용</a></p><p>쉘 정렬은 입력 크기가 매우 크지 않은 경우에 매우 좋은 성능을 보인다.<br>쉘 정렬은 임베디드(Embedded) 시스템에서 주로 사용되는데, 쉘 정렬의 특징인 간격에 따른 그룹별 정렬 방식이 하드웨어로 정렬 알고리즘을 구현하는 데 매우 적합하기 때문이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 삽입 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo27/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo27/</guid>
      <pubDate>Fri, 01 Feb 2019 09:22:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 삽입 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 삽입 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 삽입 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 삽입 정렬</a></p><p><strong>‘삽입 정렬(Insertion Sort)’</strong>은 배열을 정렬된 부분(앞부분)과 정렬이 안 된 부분(뒷부분)으로 나누고, 정렬이 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬되도록 하는 과정을 반복한다.</p><p>정렬이 안 된 부분의 숫자 하나가 정렬된 부분에 ‘삽입’됨으로써, 정렬된 부분의 원소 수가 1개 늘어나고, 정렬이 안 된 부분의 원 소 수는 1개 줄어든다.<br>이를 반복하여 수행, 마지막에는 정렬이 안 된 부분에 원소가 아무것도 남지 않게 된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>InsertionSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to n-1 &#123;// A[0]는 정렬이 된 상태로 본다</span><br><span class="line">  CurrentElement = A[i] // 정렬이 안된 부분의 가장 왼쪽 원소</span><br><span class="line">  j &lt;- i-1// 정렬이 된 부분의 가장 오른쪽 원소를 지칭</span><br><span class="line">  while (j &gt;=0) and (A[j] &gt; CurrentElement) &#123; // CurrentElement가 더 작으면</span><br><span class="line">    A[j+1] = A[j] // 정렬이 된 부분의 가장 오른쪽 원소를 오른쪽으로 한칸 이동</span><br><span class="line">    j &lt;- j-1</span><br><span class="line">  &#125;</span><br><span class="line">  A[j+1] &lt;- CurrentElement// 비어있는 부분으로 CurrentElement 이동</span><br><span class="line">&#125;</span><br><span class="line">return A</span><br></pre></td></tr></table></figure></p><p>다음의 배열에 대해 삽입 정렬이 수행되는 과정을 확인한다.</p><div align="center"><br><img src="/image/algo27-1.png"><br><br></div><ul><li><p>i=1, CurrentElement = A[1] = 10, j = i-1 = 0<br><img src="/image/algo27-2.png"><br><img src="/image/algo27-3.png"><br>A[j]= A[0] = 40 &gt; CurrentElement = 10, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-4.png"><br>j=-1, while-문 만족하지 않음<br>A[j+1] = A[0]에 CurrentElement 저장</p></li><li><p>i=2, CurrentElement = A[2] = 50, j = i-1 = 1<br><img src="/image/algo27-5.png"><br>A[j] = A[1] = 40 &lt; CurrentElement = 50, while-문 만족하지 않음, 자리 이동 없음</p></li><li><p>i=3, CurrentElement = A[3] = 90, j = i-1 = 2<br><img src="/image/algo27-6.png"><br>A[j] = A[2] = 50 &lt; CurrentElement = 90, while-문 만족하지 않음, 자리 이동 없음</p></li><li><p>i=4, CurrentElement = A[4] = 20, j = i-1 = 3<br><img src="/image/algo27-7.png"><br><img src="/image/algo27-8.png"><br>A[j] = A[3] = 90 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-9.png"><br>A[j] = A[2] = 50 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-10.png"><br>A[j] = A[1] = 40 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-11.png"><br>A[j] = A[0] = 10 &lt; CurrentElement = 20, while-문 만족하지 않음<br>A[j+1] = A[1]에 CurrentElement 저장</p></li><li><p>i=5, CurrentElement = A[5] = 80,<br><img src="/image/algo27-12.png"></p></li><li><p>i=6, CurrentElement = A[6] = 30,<br><img src="/image/algo27-13.png"></p></li><li><p>i=7, CurrentElement = A[7] = 60,<br><img src="/image/algo27-14.png"></p></li></ul><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1 : for-루프가 (n-1)번 수행<br>line 4 : while-루프가 i=1일 때, 최대 1회 수행, i=2일 때, 최대 2회 수행, … i=n-1일 때, 최대 n-1회 수행<br>while-루프 내부의 수행시간은 O(1)</p><p>따라서, n(n-1)/2 * O(1) = O(n<sup>2</sup>)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 선택 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo26/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo26/</guid>
      <pubDate>Fri, 01 Feb 2019 08:53:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 선택 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 선택 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘선
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 선택 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간복잡도</a></p><hr><p><a name="1">1. 선택 정렬</a></p><p><strong>‘선택 정렬(Selection Sort)’</strong>은 입력 배열 전체에서 최솟값을 ‘선택’하여 배열의 0번 원소와 자리를 바꾸고, 다음에는 0번 원소를 제외한 나머지 원소에서 최솟값을 선택하여 배열의 1번 원소와 자리를 바꾼다. 이러한 방식으로 마지막에 2개의 원소 중에서 작은 값을 선택, 자리를 바꿈으로서 정렬을 마친다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>SelectionSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 to n-2 // 크기가 n인 배열은 n-1번 까지 있음. 마지막 칸은 제외하니 n-2까지 정렬시킨다.</span><br><span class="line">  min = i </span><br><span class="line">  for j = i+1 to n-1 &#123;  // A[i]보다 작은 값이 A[i+1]~A[n-1]까지 있으면, 그 중 가장 작은 값을 선택</span><br><span class="line">    if (A[j] &lt; A[min])</span><br><span class="line">      min = j</span><br><span class="line">  &#125;</span><br><span class="line">  A[i] &lt;-&gt; A[min]// A[i]와 가장 작은 값을 위치 변경</span><br><span class="line">&#125;</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>다음 배열이 선택 정렬 알고리즘에 의해 정렬되는 과정을 본다.</p><div align="center"><br><img src="/image/algo26-1.png"><br></div><ul><li>i=0, A[0]~A[7] 중 min=1</li></ul><p><img src="/image/algo26-2.png">  </p><ul><li>i=1, A[1]~A[7] 중 min=4</li></ul><p><img src="/image/algo26-3.png">  </p><ul><li>i=2, A[2]~A[7] 중 min=6</li></ul><p><img src="/image/algo26-4.png">  </p><p>…</p><ul><li>i=6, A[6]~A[7] 중 min=7</li></ul><p><img src="/image/algo26-5.png">  </p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1의 for-루프는 (n-1)번 수행된다.<br>line 3의 for-루프는 i=1,2,3,…일 때, 각각 (n-2), (n-2), (n-4), …번 수행된다.<br>루프 내부의 if-조건이 ‘참’일 때 자리바꿈 O(1) 시간이 걸린다.<br>따라서 시간복잡도는 n*(n-1)/2 * O(1) = O(n<sup>2</sup>)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 버블 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo25/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo25/</guid>
      <pubDate>Thu, 31 Jan 2019 16:37:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 버블 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 버블 벙렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 버블 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 버블 벙렬</a></p><p><strong>‘버블 정렬(Bubble Sort)’</strong>은 이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘이다.<br>배열을 좌우가 아니라 상하로 그리면 정렬하는 과정에서 작은 수가 ‘거품’처럼 위로 올라가는 것이 연상된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>BubbleSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for pass = 1 to n - 1</span><br><span class="line">  for i = 1 to n - pass</span><br><span class="line">    if (A[i-1] &gt; A[i])// 위의 원소가 아래의 원소보다 크면</span><br><span class="line">      A[i-1] &lt;-&gt; A[i] // 서로 자리를 바꾼다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>다음의 배열에 대해 버블 정렬이 수행되는 과정을 확인한다.</p><div align="center"><br><img src="/image/algo25-1.png"><br></div><ul><li>패스 1</li></ul><p><img src="/image/algo25-2.png">  </p><ul><li>패스 2</li></ul><p><img src="/image/algo25-3.png">  </p><ul><li>패스 3</li></ul><p><img src="/image/algo25-4.png">  </p><ul><li>패스 4</li></ul><p><img src="/image/algo25-5.png">  </p><ul><li>패스 5~7의 결과는 패스 4의 결과와 동일하다.</li></ul><p><strong>배열의 가장 아래부터 정렬되는 것을 확인할 수 있다.</strong></p><hr><p><a name="3">3. 시간복잡도</a></p><p>pass = 1이면 (n-1)번 비교, pass = 2이면 (n-2)번 비교, pass = (n-1)이면 1번 비교한다.<br>따라서 총 비교 횟수는 n(n-1)/2이다.<br>그리고 if-조건이 참일 경우 자리바꾸는 시간 O(1)이 걸린다.<br>최악의 경우를 가정하고 시간복잡도를 구하면, O(n<sup>2</sup>)이 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정렬 알고리즘</title>
      <link>http://dudri63.github.io/2019/02/01/algo24/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo24/</guid>
      <pubDate>Thu, 31 Jan 2019 15:39:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;정렬 알고리즘&lt;/strong&gt; 분류는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기본 정렬 알고리즘&lt;/strong&gt; : 버블 정렬, 선택 정렬, 삽입 정렬&lt;/li&gt;
&lt;li&gt;보다 &lt;strong&gt;효율적인 정렬 알고리즘&lt;/str
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>정렬 알고리즘</strong> 분류는 다음과 같다.</p><ul><li><strong>기본 정렬 알고리즘</strong> : 버블 정렬, 선택 정렬, 삽입 정렬</li><li>보다 <strong>효율적인 정렬 알고리즘</strong> : 쉘 정렬, 힙 정렬, 합병 정렬, 퀵 정렬, 기수 정렬</li></ul><p>특히 기수 정렬은 제한된 크기 이내의 숫자로 구성되어 있을 때 매우 효율적이다.</p><p>정렬 알고리즘은 또한 <strong>내부정렬(Internal Sort)</strong>과 <strong>외부 정렬(External Sort)</strong>로도 분류할 수 있다.</p><ul><li>내부 정렬 : 입력의 크기가 메인 메모리의 공간보다 크지 않은 경우 수행, 앞서 언급한 정렬 알고리즘들은 모두 내부 정렬 알고리즘들이다.</li><li>외부 정렬 : 입력의 크기가 메인 메모리의 공간보다 큰 경우 수행, 보조 기억 장치에 있는 입력을 여러 번에 나누어 주기억 장치에 읽어들인 후, 정렬하여 보조 기억 장치에 다시 저장하는 과정을 반복한다.</li></ul><p>앞으로 포스팅하는 모든 정렬 알고리즘은 오름차순으로 정렬하겠다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝/머신러닝] TensorFlow</title>
      <link>http://dudri63.github.io/2019/01/30/adl2/</link>
      <guid>http://dudri63.github.io/2019/01/30/adl2/</guid>
      <pubDate>Wed, 30 Jan 2019 13:14:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. TensorFlow&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. TensorFlow 예제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. TensorFlow 구조&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. placeholder&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. TensorFlow</a><br><a href="#2">2. TensorFlow 예제</a><br><a href="#3">3. TensorFlow 구조</a><br><a href="#4">4. placeholder</a><br><a href="#5">5. Tesnor, Ranks, Shapes, Types</a></p><hr><p><a name="1">1. TensorFlow</a></p><p><strong>텐서플로우(TensorFlow)</strong>는 구글에서 만든 오픈 소스 라이브러리이다.<br>텐서플로우는 데이터 플로우 그래프(Data Flow Graph)를 이용하여 수 계산(Numerical Computation)을 할 수 있다는 특징이 있다.<br>또한, ‘파이썬(Python)’ 언어를 이용하여 텐서플로우를 활용할 수 있다.</p><p>Data Flow Graph란 다음 그림과 같은 것이다.</p><div align="center"><br><img src="/image/ald2-1.png"><br></div><br>‘노드’와 노드간을 연결하는 ‘엣지’로 구성되어 있는 것을 그래프라고 한다.<br>Data Flow Graph에서 노드는 하나의 operation이다.<br>엣지는 데이터(tensor)이다.<br>데이터들은 연속적으로 연산하여 결과를 추출하는 것이 Data Flow Graph의 방식이다.<br><br><div align="center"><br><img src="/image/ald2-2.png"><br></div><p>리눅스 환경에서 텐서플로우를 설치한 후, 파이썬에서 텐서플로우 모듈을 import 및 버전 정보를 확인한 결과는 위와 같다.</p><hr><p><a name="2">2. TensorFlow 예제</a></p><div align="center"><br><img src="/image/ald2-3.png"><br></div><p>“Hello, TensorFlow!”라는 내용의 constant 노드를 만들고, 변수 hello에 이를 할당한다.<br>(computation 그래프 내에 노드 1개가 만들어진 형태이다.)<br>이 후, session을 만든 뒤 실행(run)시켰다.<br>(computation 그래프를 실행하기 위해서는 session을 만들어야 한다.)</p><p>(b’라는 문자열은 간단하게 byte string이라는 의미이다. 프로그램 동작과는 무관하다)</p><hr><div align="center"><br><img src="/image/ald2-5.png"><br><br><img src="/image/ald2-4.png"><br></div><p>a와 b라는 노드가 있고, ‘+’라는 노드로 연결되는 간단한 그래프를 만든 것이다.</p><p>node1은 ‘3’이라는 내용, data type은 float32인 constant 노드이다.<br>node2는 ‘4’라는 내용의 constant 노드이다. node2는 암묵적으로 node1과 마찬가지로 data type이 float32임을 유의한다.<br>node3은 node1, node2를 더하는 add 노드이다.</p><p>이 후, node1, node2, node3를 print() 함수를 이용하여 출력하면, 각각의 노드들은 Tensor이며, 그 내용들을 확인할 수 있다. 결과값을 확인할 수는 없다.</p><p>결과값을 확인하기 위해서 1. session을 만들고, 2. 해당 session에 원하는 노드들을 넣은 뒤 3. run한다.</p><hr><p><a name="3">3. TensorFlow 구조</a></p><div align="center"><br><img src="/image/ald2-6.png"><br></div><p>텐서플로우의 구조는 위와 같은데 기존의 프로그래밍과는 조금 다르다.</p><ol><li>먼저 그래프를 빌드한다.</li><li>session을 만든 뒤 run한다.</li><li>결과로 graph내의 값을 업데이트한다.</li></ol><hr><p><a name="4">4. plcaeholder</a></p><p>위에서는 그래프를 만들면서, 각 노드들의 숫자들을 지정하였다.<br>그렇다면, 그래프를 미리 만들어 놓고, 실행시키는 단계에서 값을 던지고 싶다면 어떻게 해야할까?</p><p>constant 노드가 아니라, <strong>placeholder</strong>라는 특별한 노드를 사용한다.</p><div align="center"><br><img src="/image/ald2-7.png"><br><img src="/image/ald2-8.png"><br></div><p>a, b, adder_node, 총 3개의 placeholder 노드를 만들었다.<br>이 후, session을 생성한 뒤, feed_dict로 a, b 노드에 값을 할당한 뒤 실행시킨다.<br>1개의 값이 아닌 여러개의 값을 넘겨줄 수도 있다.</p><hr><p><a name="5">5. Tensor, Ranks, Shapes, Types</a></p><p>5.1. Tensor</p><p>TensorFlow 프로그램은 모든 데이터를 <strong>tensor</strong> 데이터 구조를 사용해서 표현한다.<br>TensorFlow의 tensor는 n-차원 배열 또는 리스트라고 생각할 수 있다.<br>하나의 tesnor는 정적 타입, 동적 차원을 가지고 있다.<br>그리고 Computation 그래프의 노드들은 오직 tensor만을 전달할 수 있다.</p><p>5.2. Rank</p><p>TensorFlow 시스템에서 tensor는 <strong>rank</strong>라는 차원 단위로 표현된다.</p><div align="center"><br><img src="/image/ald2-9.png"><br></div><br>위 표는 rank에 따른 tensor의 형식이다.<br><br>5.3. Shape<br><br>TensorFlow 문서는 tensor 차원을 표현할 때, 세 가지 기호를 사용한다.<br>rank, shape, 차원수가 그것들이다.<br>다시 말하면, tensor의 차원을 알기 위해서 rank, shape, 차원수를 살펴볼 수 있다.<br><div align="center"><br><img src="/image/ald2-10.png"><br></div><p>5.4. Data Types</p><p>Tensor는 차원 말고도 <strong>데이터 타입</strong>을 갖는다. 아래의 데이터 타입을 tensor에 지정할 수 있다.</p><div align="center"><br><img src="/image/ald2-11.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>랭크, 크기, 타입-텐서플로우 문서 한글 번역본, 텐서플로우, 2019. 1. 30, <a href="https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\_types.html" rel="external nofollow noopener noreferrer" target="_blank">https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\_types.html</a></li><li>섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/30/adl2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝/머신러닝] 머신러닝이란</title>
      <link>http://dudri63.github.io/2019/01/30/adl1/</link>
      <guid>http://dudri63.github.io/2019/01/30/adl1/</guid>
      <pubDate>Wed, 30 Jan 2019 10:32:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 이세돌과 알파고&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 머신러닝이란&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 이세돌과 알파고&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 이세돌과 알파고</a><br><a href="#2">2. 머신러닝이란</a></p><hr><p><a name="1">1. 이세돌과 알파고</a></p><p>그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의 순간적인 직관이 매우 중요한 것으로 여겨졌다.<br>따라서 바둑이라는 종목에 한해서는 컴퓨터가 인간을 넘어서기 힘들 것으로 꽤 오랜 시간 간주되었다.<br>그러나 이세돌 9단이 알파고에게 4:1로 패배하였다.</p><div align="center"><br><img src="/image/ald1-1.png"><br></div><p>인공지능이란 무엇인가에 대하여 많은 이목이 쏠린 역사적인 사건이다.<br>인공지능은 과연 사람처럼 직관적인 의사결정을 할 수 있는 것인가?</p><div align="center"><br><img src="/image/ald1-2.png"><br></div><p>Dr.Andrew Ng에 의하면 오늘날의 시대를 살기 위해서는 머신러닝 학습이 필수적이라고 이야기한다.<br>또한, 머신러닝을 잘 활용하는 사람이 Super Power를 지닐 수 있다고 한다.</p><hr><p><a name="2">2. 머신러닝이란</a></p><p><strong>머신러닝(Machine Learning)</strong>이란 일종의 소프트웨어, 프로그램이다.<br>그러나 기존 프로그래밍 기법과는 차이점이 있다.</p><p>기존 explicit programming이란 개발자가 환경에 따라서 프로그램이 어떻게 반응할지를 정의한다.<br>그런데 explicit하게, 즉, 명확하게 프로그래밍하기 어려운 경우가 있다.<br>예를 들어, 스팸 메일을 필터링하는 프로그램을 작성할 때 모든 경우를 고려하여 스팸 or not을 결정하기가 어렵다.</p><p>머신러닝의 시작은 상황이 복잡할 때 모든 경우를 일일이 프로그래밍하지 않고, ‘어떤 현상이나 자료에서 자동적으로 배우는 것은 어떨까?’라는 생각이다.<br>즉, 머신러닝은 프로그램인데, 개발자가 모든 경우를 명확하게 프로그래밍 하지 않고, 프로그램이 스스로 학습하여 배운 뒤 처리할 수 있도록 하는 것이라고 할 수 있다.</p><div align="center"><br><img src="/image/ald1-3.png"><br></div><p>머신러닝은 학습하는 방법에 따라서 Supervised Learning, Unsupervised Learning으로 구분할 수 있다.<br>Supervised Learning은 정해져있는 데이터(labeled, training set)를 이용하여 학습하는 것이다.<br>예를 들어, 개나 고양이 사진들의 label을 각각 개, 고양이로 달고 학습을 시킬 수 있다.</p><div align="center"><br><img src="/image/ald1-4.png"><br></div><p>그런데, 모든 경우 label을 달 수 있는 것은 아니다.<br>Google news는 자동적으로 유사한 뉴스들을 grouping을 한다.<br>또한, 유사한 단어들을 grouping하는 것도 특정한 label을 달기 어렵다.<br>이 경우 Unsupervised Learning(학습)하여야 한다.</p><p>머신러닝에서 대부분의 문제들은 Supervised Learning으로 해결할 수 있다.<br>Supervised Learning의 예는 다음과 같다.</p><p><div align="center"><br><img src="/image/ald1-5.png"><br>X: feature, Y: label<br></div></p><ul><li>label이 정해져 있는 feature들을 가지고 학습을 한다.<br>(네모칸 안에 있는 표를 training data set이라고 한다.)</li><li>이 후, 내가 모르는 X<sub>test</sub>의 label을 물어보면, ML은 Y=3이라고 대답한다.</li></ul><p>알파고의 원리도 위와 다르지 않다.<br>기존 바둑 기사들이 둔 기보를 이용하여 학습한 뒤, 이세돌 9단과 대결할 때, 학습한 것을 바탕으로 각 수를 놓는 것이다.</p><p>Supervised Learning의 Type은 다음과 같다.</p><ol><li>공부한 시간에 따른 시험 성적(0~100) 예상 : regression</li><li>공부한 시간에 따른 시험 결과(pass or fail) 예상 : binary classification</li><li>공부한 시간에 따른 시험 성적(A,B,C,D,F) 예상 : multi-label classification</li></ol><p>ML을 이용한 공부한 시간에 따른 시험 성적(0~100) 예상이 어떻게 되는지는 다음과 같다.</p><p><div align="center"><br><img src="/image/ald1-6.png"><br>왼쪽 표는 training data set이다.<br></div><br>regression 모델을 왼쪽 표를 이용하여 training한다. 이 후, x=7(7시간)일 때, y(점수)를 물어보면, 학습한 것을 바탕으로 y=70을 내놓는다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/</a>, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/30/adl1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 클래스</title>
      <link>http://dudri63.github.io/2019/01/29/python8/</link>
      <guid>http://dudri63.github.io/2019/01/29/python8/</guid>
      <pubDate>Tue, 29 Jan 2019 12:31:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 클래스&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 클래스&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 클래스</a></p><hr><p><a name="1">1. 클래스</a></p><p>C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있다.<br>그러나 프로그램 작성 시 클래스를 사용하면 프로그래머가 얻을 수 있는 이점이 굉장히 많다.</p><p>클래스는 ‘과자틀’, 객체는 과자틀에 의해 만들어진 ‘과자’에 비유할 수 있다.<br>클래스란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고, 객체란 클래스에 의해서 만들어진 피조물을 뜻한다.</p><p>클래스에 의해서 만들어진 객체는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 동일한 클래스에 의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Cal:# Cal이라는 새로운 class를 정의</span><br><span class="line">    def __init__(self, v1, v2): # 생성자</span><br><span class="line">        self.v1 = v1</span><br><span class="line">        self.v2 = v2</span><br><span class="line"> </span><br><span class="line">    def add(self):# add 함수</span><br><span class="line">        return self.v1+self.v2</span><br><span class="line"> </span><br><span class="line">    def subtract(self):  # subtract 함수</span><br><span class="line">        return self.v1-self.v2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">c1 = Cal(10,10)# 객체 c1 생성 및 변수에 객체 할당</span><br><span class="line">print(c1.add())# 객체의 멤버에 접근</span><br><span class="line">print(c1.subtract()) # 객체의 멤버에 접근</span><br><span class="line">c2 = Cal(30,20)# 객체 c2 생성 및 변수에 객체 할당</span><br><span class="line">print(c2.add())# 객체의 멤버에 접근</span><br><span class="line">print(c2.subtract())# 객체의 멤버에 접근</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-1.png"><br></div><ul><li>__init__ : 생성자<br>객체를 생성할 때, 생성자의 self를 제외한 매개변수 숫자만큼 인자를 채워야 한다.<br>ex. __init(self,v1, v2)__ -&gt; c1 = Cal(v1,v2)</li><li>self : 객체의 인스턴스 그 자체, 파이썬에서는 클래스의 메소드를 정의할 때 self를 꼭 명시해야 한다.</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        self.value = v</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.value)</span><br><span class="line"> </span><br><span class="line">c1 = C(10)</span><br><span class="line">print(c1.value)# 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출 </span><br><span class="line">c1.value = 20# 객체 c1의 멤버 변수 value의 값을 변경</span><br><span class="line">print(c1.value)# 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출</span><br><span class="line">c1.show()# 객체 c1의 멤버 함수 show()를 호출, show() 함수는 value의 값을 인자로 print() 함수 호출</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-2.png"><br></div><hr><p>cf. 객체와 인스턴스</p><p>클래스에 의해서 만들어진 객체를 인스턴스라고도 한다. 그러나 객체와 인스턴스는 미묘하지만 차이점이 있다. 예를 들어 Cookie라는 클래스가 있다고 가정한다. a = Cookie() 로 만들어진 a는 객체이다. 그리고 a라는 객체는 Cookie의 인스턴스이다. 즉, 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 인스턴스” 보다는 “a는 객체”라는 표현이 어울리며, “a는 Cookie의 객체” 보다는 “a는 Cookie의 인스턴스”라는 표현이 훨씬 잘 어울린다.</p><hr><p>cf. 변수 </p><p>값을 넣을 수 있는 이름이 붙어있는 공간. 일반적으로 값을 변경할 수 있다. 값을 변경할 수 없을 경우 특별하게 ‘상수’라고 한다.</p><hr><p>cf. 인스턴스 변수와 클래스 변수</p><p>인스턴스 변수와 클래스 변수를 합쳐서 ‘멤버 변수’라고 한다. 인스턴스 변수는 객체를 생성할 때 생성된다. 각각의 인스턴스마다 다른 값을 가질 수 있다. 클래스 변수는 인스턴스 변수에 static이 붙은 형식이다. 인스턴스 변수는 각각 고유한 값을 가질 수 있는 것에 반해 클래스 변수는 모든 인스턴스가 동일한 값을 공유한다. 인스턴스 변수, 클래스 변수 모두 Class 내부에서 선언된다.</p><hr><p>cf. 캡슐화</p><p>캡슐화(Encapsulation)는 객체 지향 프로그래미에서 다음 2가지 측면이 있다.</p><ul><li>객체의 속성과 행위를 하나로 묶고,</li><li>실제 구현 내용을 외부에 감추어 은닉한다.</li></ul><p>외부로부터 영향을 받지 변경되지 않도록 기본적으로 캡슐화를 이용한다. 함수나 변수도 캡슐로 감싼 예 중 하나이다. 또한 함수들을 다시 묶어서 모듈로 감쌀 수도 있다. 접근 지정자를 따로 지정하여 외부에서 캡슐에 얼마나 접근할 수 있을지 설정하기도 한다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        self.value = v</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.value)</span><br><span class="line">    def getValue(self):# 인스턴스의 value를 반환</span><br><span class="line">        return self.value</span><br><span class="line">    def setValue(self, v):# 인스턴스의 value를 설정 </span><br><span class="line">        self.value = v</span><br><span class="line">c1 = C(10)# C의 인스턴스 c1 생성 </span><br><span class="line">print(c1.getValue())# c1의 value값을 받아온 뒤, print() 호출</span><br><span class="line">c1.setValue(20)# c1의 value값을 설정</span><br><span class="line">print(c1.getValue())# c1의 value값을 받아온 뒤, print() 호출</span><br></pre></td></tr></table></figure><p>set은 객체 내부의 데이터를 직접 바꾸기 위한 메소드,<br>get은 객체 내부의 데이터를 직접 받아오기 위한 메소드이다.</p><div align="center"><br><img src="/image/py8-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    bag = []# bag 속성(클래스 속성)</span><br><span class="line"> </span><br><span class="line">    def put_bag(self, stuff):</span><br><span class="line">        self.bag.append(stuff)</span><br><span class="line"> </span><br><span class="line">james = Person()</span><br><span class="line">james.put_bag(&apos;책&apos;)</span><br><span class="line"> </span><br><span class="line">maria = Person()</span><br><span class="line">maria.put_bag(&apos;열쇠&apos;)</span><br><span class="line"> </span><br><span class="line">print(james.bag)</span><br><span class="line">print(maria.bag)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-4.png"><br></div><p><strong>클래스 속성</strong>으로서 bag 속성을 만들었다. james 인스턴스에서 ‘책’을 넣었고, maria 인스턴스에서 ‘열쇠’를 넣었는데, james, maria 모두 bag 속성으로서 책과 열쇠를 모두 갖는다.<br>클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bag = []# bag 속성(인스턴스 속성)</span><br><span class="line"> </span><br><span class="line">    def put_bag(self, stuff):</span><br><span class="line">        self.bag.append(stuff)</span><br><span class="line"> </span><br><span class="line">james = Person()</span><br><span class="line">james.put_bag(&apos;책&apos;)</span><br><span class="line"> </span><br><span class="line">maria = Person()</span><br><span class="line">maria.put_bag(&apos;열쇠&apos;)</span><br><span class="line"> </span><br><span class="line">print(james.bag)</span><br><span class="line">print(maria.bag)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-5.png"><br></div><p><strong>인스턴스 속성</strong>으로서 bag 속성을 만들었다. 이 경우, 클래스 속성으로 만들었을 때와는 달리 각 인스턴스마다 고유한 속성을 갖게 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>05-1 클래스, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/28" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/28</a></li><li>35.1 크래스 속성과 인스턴스 속성 알아보기, 코딩도장, 2019. 1. 29, <a href="https://dojang.io/mod/page/view.php?id=2378" rel="external nofollow noopener noreferrer" target="_blank">https://dojang.io/mod/page/view.php?id=2378</a></li><li>객체와 변수, 생활코딩, 2019. 1. 29, <a href="https://opentutorials.org/course/1750/10000" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/10000</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/python8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
