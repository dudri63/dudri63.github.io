<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Seo&#39;s Blog</title>
    <link>http://dudri63.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 03 Feb 2019 03:17:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Algorithm] 힙 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo29/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo29/</guid>
      <pubDate>Fri, 01 Feb 2019 12:48:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 힙 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 힙 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘힙(
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 힙 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 힙 정렬</a></p><p><strong>‘힙(Heap)’</strong>은 <strong>힙 조건</strong>을 만족하는 <strong>완전 이진 트리(Complete Binary Tree)</strong>이다.</p><p>힙 조건이란 각 노드의 값이 자식 노드의 값보다 커야 한다는 것을 말한다.<br>노드의 값은 <strong>‘우선순위(Priority)’</strong>라고 일컫는다.<br>따라서 힙의 루트에는 가장 높은 우선순위(가장 큰 값)가 저장되어 있다.<br>(단, 값이 작을수록 우선순위가 높은 경우도 있다.)</p><p>완전 이진트리란 마지막 레벨을 제외하고 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 채워지는 이진 트리이다.<br>n개의 노드를 가진 힙은 완전 이진 트리이므로, 힙의 노드가 log<sub>2</sub>n이다.</p><p>아래 그림은 힙의 노드들이 배열에 저장된 모습을 보여준다.</p><div align="center"><br><img src="/image/algo29-1.png"><br></div><p>배열 A에 힙을 저장한다면, A[0]은 비워 두고, A[1]부터 A[n]까지에 힙 노드들을 층별로 왼쪽부터 저장한다.이런 방식으로 저장하면, 트리에서 부모 노드와 자식 노드의 관계를 배열의 인덱스로 쉽게 표현할 수 있다.</p><ul><li>A[i]의 부모 노드 : A[i/2], ex. A[7]=10의 부모 노드 -&gt; A[7/2]=A[3]=80</li><li>A[i]의 왼쪽 자식 노드 : A[2i], ex. A[4]=50의 왼쪽 자식 노드 -&gt; A[4*2]=A[8]=20</li><li>A[i]의 오른쪽 자식 노드 : A[2i+1], ex. A[4]=50의 오른쪽 자식 노드 -&gt; A[4*2+1]=A[9]=40</li></ul><p><strong>‘힙 정렬(Heap Sort)’</strong>은 힙 자료 구조를 이용하는 정렬 알고리즘이다.<br>오름차순의 정렬을 위해 입력 배열을 큰 숫자가 높은 우선순위를 가지는 <strong>최대힙(Maximum heap)</strong>을 만든다.<br>루트에 저장된 가장 큰 수를 배열의 가장 끝으로 이동시킨다.<br>그리고 루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하며 힙 조건을 만족시키고, 힙 크기를 1개 줄인다.<br>이 과정을 반복하여 나머지 숫자들을 정렬하는 것이 힙 정렬 알고리즘이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>HeapSort<br>입력: 입력이 A[1]부터 A[n]까지 저장된 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">배열 A의 숫자에 대해서 힙 자료 구조를 만든다.</span><br><span class="line">heapSize = n// 힙의 크기를 조절</span><br><span class="line">for i=1 to n-1</span><br><span class="line">  A[1] &lt;-&gt; n-1// 루트와 힙의 마지막 노드를 교환한다.</span><br><span class="line">  heapSize = heapSize - 1// 힙의 크기를 1 감소시킨다.</span><br><span class="line">  DownHeap()// 위배된 힙 조건을 만족시킨다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><ul><li>line 1 : 배열 A를 힙으로 만든다.</li><li>line 2 : 현재의 힙의 크기를 나타내는 변수인 heapSize를 n으로 초기화시킨다.</li><li>line 3~6 : for루프가 (n-1)번 수행된다. (n-1)번 수행하는 루프가 종료된 후 루트인 A[1] 홀로 힙을 구성, A[1]에 있는 숫자가 가장 작은 수이므로 루프를 수행할 필요가 없기 때문이다.</li><li>line 4 : 루트와 힙의 마지막 노드와 교환, 루트에는 힙에서 가장 큰 수가 저장되어 있었음.</li><li>line 5 : 힙의 크기를 1 줄인다.</li><li>line 4에서 힙의 마지막 노드와 힙의 루트를 바꾸어 놓았기 때문에 새로이 루트에 저장된 값이 자식 노드의 값보다 작아서 힙 조건이 위배된다.</li><li>line 6 : DownHeap을 수행, 위배된 힙 조건을 해결한다.</li></ul><p>위 과정은 아래 그림으로 설명할 수 있다.</p><div align="center"><br><img src="/image/algo29-2.png"><br></div><p>우선 위 그림은 line 4에서 힙의 루트(90)와 마지막 노드(40)를 바꾸고, 힙의 노드 수를 1개 줄이는 과정이다.<br>이 작업이 끝나면 힙 조건이 위배되고, 이를 해결하기 위해 DownHeap을 수행한다.<br>DownHeap 수행 과정은 아래와 같다.</p><div align="center"><br><img src="/image/algo29-3.png"><br></div><p>새로이 루트에 저장된 40이 루트의 자식 노드들(60,80)보다 작아서 힙 조건 위배, 자식 노드들 중에서 가장 큰 자식인 80과 루트 40을 교환한다.</p><div align="center"><br><img src="/image/algo29-4.png"><br></div><p>40은 또다시 자식 노드들중 하나인 70보다 작기 때문에 힙 조건에 위배, 70과 40을 교환한다.</p><div align="center"><br><img src="/image/algo29-5.png"><br></div><p>힙 조건을 만족하므로 DownHeap을 종료한다.</p><div align="center"><br><img src="/image/algo29-6.png"><br></div><p>힙의 루트(80)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-7.png"><br></div><p>힙의 루트(70)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-8.png"><br></div><p>힙의 루트(60)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-9.png"><br></div><p>힙의 루트(50)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-10.png"><br></div><p>힙의 루트(40)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-11.png"><br></div><p>힙의 루트(30)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-12.png"><br></div><p>힙의 루트(20)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.<br>힙의 크기가 1이 되었으므로 힙 정렬을 마친다.<br>결과로서 배열이 정렬되었음 확인할 수 있다.</p><p>for-루프를 반복할 때마다 힙에서 가장 큰 수를 힙의 마지막 노드와 교환한다.<br>선택 정렬에서 최솟값을 찾는 대신에 최댓값을 찾아서 배열의 뒷부분으로부터 정렬하는 것과 같다.<br>또한 선택정렬은 순차탐색으로 최솟값을 찾는 것에 비해 힙 정렬은 힙 자료구조를 이용하여 최댓값을 찾는다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1에서 힙을 만드는데 O(n) 시간이 걸린다.<br>line 2는 변수를 초기화, O(1) 시간이 걸린다.<br>line 3~6은 for-루프가 (n-1)번 수행, 루프 내부에서 line 4~5에서 O(1)시간이 걸리고, DownHeap은 O(log<sub>2</sub>n) 시간이 거린다.<br>(힙의 높이는 log<sub>2</sub>n을 넘지 않음, 최악의 경우 leaf 노드까지 내려가며 교환한 경우를 가정한다.)<br>힙 정렬의 시간복잡도는 O(n) + (n-1)*O(logn) = O(nlogn)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 쉘 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo28/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo28/</guid>
      <pubDate>Fri, 01 Feb 2019 10:23:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 쉘 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 쉘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 쉘 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 쉘 정렬</a></p><p>버블 정렬이나 삽입 정렬이 수행되는 과정을 살펴보면, 이웃하는 원소의 숫자들끼리의 자리를 이동함으로써 정렬이 이루어진다.<br>그렇기 때문에 위 두 정렬의 경우, 배열되는 과정이 굉장히 느리다.<br>특히 삽입 정렬은 배열의 마지막 원소가 입력에서 가장 작은 숫자라면, 그 숫자가 배열의 맨 앞으로 이동할 때, 다른 모든 숫자들이 1칸씩 오른쪽으로 이동하여야 한다.</p><p><strong>‘쉘 정렬(Shell Sort)’</strong>은 이러한 단점을 보완하기 위해서 삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자을 앞부분으로 ‘빠르게’ 이동시키고, 동시에 앞부분의 큰 숫자는 뒷부분으로 이동시키며, 가장 마지막에는 삽입 정렬을 수행한다.</p><p>다음 예제를 통해 쉘 정렬의 아이디어를 이해한다.</p><div align="center"><br><img src="/image/algo28-1.png"><br><br></div><ul><li>먼저 간격(gap)이 5가 되는 숫자끼리 그룹을 만든다. 만들어지는 그룹은 다음과 같다.<br>[30,80,50], [60,40,30], [90,20,40], [10,10,90], [40,60,80]</li></ul><p><img src="/image/algo28-2.png"></p><ul><li>각 그룹내에서 정렬된 결과를 1줄에 나열하면 다음과 같다.</li></ul><p><img src="/image/algo28-3.png"></p><p><img src="/image/algo28-4.png">  </p><ul><li><p>완벽하지는 않지만 대체로 큰 수가 뒤로, 작은 수가 앞으로 이동하였음을 확인할 수 있다.</p></li><li><p>이 후, 간격을 5보다 작게 하여 또 다시 그룹별로 삽입 정렬을 수행한다.</p></li><li><p>마지막에는 간격(gap)을 1로 하여 수행한다. 이는 삽입 정렬 그 자체이다.</p></li></ul><hr><p><a name="2">2. 알고리즘</a></p><p>ShellSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for each gap h = [h0 &gt; h1 &gt; ... &gt; hk = 1]// 큰 gap부터 차례로</span><br><span class="line">  for i = h to n-1</span><br><span class="line">    CurrentElement = A[i];</span><br><span class="line">    j = i;</span><br><span class="line">    while (j&gt;=h) and (A[j-h] &gt; CurrentElement) &#123;</span><br><span class="line">      A[j] = A[j-h];</span><br><span class="line">      j = j - h;</span><br><span class="line">    &#125;</span><br><span class="line">  A[j] = CurrentElement;</span><br><span class="line">&#125;</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>앞의 예제에 위 알고리즘을 적용하여 쉘 정렬의 과정을 살핀다.</p><ol><li>h = 5 (간격이 5일 때)</li></ol><ul><li>i = 5,6,7,8,9일 때</li></ul><p><img src="/image/algo28-5.png"> </p><ul><li>i = 10,11,12,13,14일 때</li></ul><p><img src="/image/algo28-6.png"> </p><p><img src="/image/algo28-7.png"> </p><ol start="2"><li>h = 3 (간격이 3일 때)</li></ol><ul><li>3개의 그룹으로 나뉘어지고, 각 그룹의 원소는 5개씩이다.</li></ul><p><img src="/image/algo28-8.png"> </p><p><img src="/image/algo28-9.png"> </p><ol start="3"><li>h = 1 (간격이 1일 때, 삽입 정렬과 동일)</li></ol><p><img src="/image/algo28-10.png"> </p><p>쉘 정렬의 수행 속도는 간격 선정에 따라서 좌우된다.<br>지금까지 알려진 가장 좋은 성능을 보이는 간격은 1, 4, 10, 23, 57, 132, 301, 701이다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>쉘 정렬의 최악 경우의 시간 복잡도는 O(n<sup>2</sup>)이다.<br>히바드(Hibbard) 간격 2<sup>k</sup>-1을 사용하면 쉘 정렬의 시간복잡도는 O(n<sup>1.5</sup>)이다.<br>또한 다양한 실험을 통해 쉘 정렬의 시간복잡도는 O(n<sup>1.25</sup>)까지 줄일 수 있다고 알려져 있다.</p><hr><p><a name="4">4. 응용</a></p><p>쉘 정렬은 입력 크기가 매우 크지 않은 경우에 매우 좋은 성능을 보인다.<br>쉘 정렬은 임베디드(Embedded) 시스템에서 주로 사용되는데, 쉘 정렬의 특징인 간격에 따른 그룹별 정렬 방식이 하드웨어로 정렬 알고리즘을 구현하는 데 매우 적합하기 때문이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 삽입 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo27/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo27/</guid>
      <pubDate>Fri, 01 Feb 2019 09:22:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 삽입 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 삽입 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 삽입 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 삽입 정렬</a></p><p><strong>‘삽입 정렬(Insertion Sort)’</strong>은 배열을 정렬된 부분(앞부분)과 정렬이 안 된 부분(뒷부분)으로 나누고, 정렬이 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬되도록 하는 과정을 반복한다.</p><p>정렬이 안 된 부분의 숫자 하나가 정렬된 부분에 ‘삽입’됨으로써, 정렬된 부분의 원소 수가 1개 늘어나고, 정렬이 안 된 부분의 원 소 수는 1개 줄어든다.<br>이를 반복하여 수행, 마지막에는 정렬이 안 된 부분에 원소가 아무것도 남지 않게 된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>InsertionSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to n-1 &#123;// A[0]는 정렬이 된 상태로 본다</span><br><span class="line">  CurrentElement = A[i] // 정렬이 안된 부분의 가장 왼쪽 원소</span><br><span class="line">  j &lt;- i-1// 정렬이 된 부분의 가장 오른쪽 원소를 지칭</span><br><span class="line">  while (j &gt;=0) and (A[j] &gt; CurrentElement) &#123; // CurrentElement가 더 작으면</span><br><span class="line">    A[j+1] = A[j] // 정렬이 된 부분의 가장 오른쪽 원소를 오른쪽으로 한칸 이동</span><br><span class="line">    j &lt;- j-1</span><br><span class="line">  &#125;</span><br><span class="line">  A[j+1] &lt;- CurrentElement// 비어있는 부분으로 CurrentElement 이동</span><br><span class="line">&#125;</span><br><span class="line">return A</span><br></pre></td></tr></table></figure></p><p>다음의 배열에 대해 삽입 정렬이 수행되는 과정을 확인한다.</p><div align="center"><br><img src="/image/algo27-1.png"><br><br></div><ul><li><p>i=1, CurrentElement = A[1] = 10, j = i-1 = 0<br><img src="/image/algo27-2.png"><br><img src="/image/algo27-3.png"><br>A[j]= A[0] = 40 &gt; CurrentElement = 10, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-4.png"><br>j=-1, while-문 만족하지 않음<br>A[j+1] = A[0]에 CurrentElement 저장</p></li><li><p>i=2, CurrentElement = A[2] = 50, j = i-1 = 1<br><img src="/image/algo27-5.png"><br>A[j] = A[1] = 40 &lt; CurrentElement = 50, while-문 만족하지 않음, 자리 이동 없음</p></li><li><p>i=3, CurrentElement = A[3] = 90, j = i-1 = 2<br><img src="/image/algo27-6.png"><br>A[j] = A[2] = 50 &lt; CurrentElement = 90, while-문 만족하지 않음, 자리 이동 없음</p></li><li><p>i=4, CurrentElement = A[4] = 20, j = i-1 = 3<br><img src="/image/algo27-7.png"><br><img src="/image/algo27-8.png"><br>A[j] = A[3] = 90 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-9.png"><br>A[j] = A[2] = 50 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-10.png"><br>A[j] = A[1] = 40 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-11.png"><br>A[j] = A[0] = 10 &lt; CurrentElement = 20, while-문 만족하지 않음<br>A[j+1] = A[1]에 CurrentElement 저장</p></li><li><p>i=5, CurrentElement = A[5] = 80,<br><img src="/image/algo27-12.png"></p></li><li><p>i=6, CurrentElement = A[6] = 30,<br><img src="/image/algo27-13.png"></p></li><li><p>i=7, CurrentElement = A[7] = 60,<br><img src="/image/algo27-14.png"></p></li></ul><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1 : for-루프가 (n-1)번 수행<br>line 4 : while-루프가 i=1일 때, 최대 1회 수행, i=2일 때, 최대 2회 수행, … i=n-1일 때, 최대 n-1회 수행<br>while-루프 내부의 수행시간은 O(1)</p><p>따라서, n(n-1)/2 * O(1) = O(n<sup>2</sup>)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 선택 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo26/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo26/</guid>
      <pubDate>Fri, 01 Feb 2019 08:53:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 선택 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 선택 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘선
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 선택 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간복잡도</a></p><hr><p><a name="1">1. 선택 정렬</a></p><p><strong>‘선택 정렬(Selection Sort)’</strong>은 입력 배열 전체에서 최솟값을 ‘선택’하여 배열의 0번 원소와 자리를 바꾸고, 다음에는 0번 원소를 제외한 나머지 원소에서 최솟값을 선택하여 배열의 1번 원소와 자리를 바꾼다. 이러한 방식으로 마지막에 2개의 원소 중에서 작은 값을 선택, 자리를 바꿈으로서 정렬을 마친다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>SelectionSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 to n-2 // 크기가 n인 배열은 n-1번 까지 있음. 마지막 칸은 제외하니 n-2까지 정렬시킨다.</span><br><span class="line">  min = i </span><br><span class="line">  for j = i+1 to n-1 &#123;  // A[i]보다 작은 값이 A[i+1]~A[n-1]까지 있으면, 그 중 가장 작은 값을 선택</span><br><span class="line">    if (A[j] &lt; A[min])</span><br><span class="line">      min = j</span><br><span class="line">  &#125;</span><br><span class="line">  A[i] &lt;-&gt; A[min]// A[i]와 가장 작은 값을 위치 변경</span><br><span class="line">&#125;</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>다음 배열이 선택 정렬 알고리즘에 의해 정렬되는 과정을 본다.</p><div align="center"><br><img src="/image/algo26-1.png"><br></div><ul><li>i=0, A[0]~A[7] 중 min=1</li></ul><p><img src="/image/algo26-2.png">  </p><ul><li>i=1, A[1]~A[7] 중 min=4</li></ul><p><img src="/image/algo26-3.png">  </p><ul><li>i=2, A[2]~A[7] 중 min=6</li></ul><p><img src="/image/algo26-4.png">  </p><p>…</p><ul><li>i=6, A[6]~A[7] 중 min=7</li></ul><p><img src="/image/algo26-5.png">  </p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1의 for-루프는 (n-1)번 수행된다.<br>line 3의 for-루프는 i=1,2,3,…일 때, 각각 (n-2), (n-2), (n-4), …번 수행된다.<br>루프 내부의 if-조건이 ‘참’일 때 자리바꿈 O(1) 시간이 걸린다.<br>따라서 시간복잡도는 n*(n-1)/2 * O(1) = O(n<sup>2</sup>)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 버블 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo25/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo25/</guid>
      <pubDate>Thu, 31 Jan 2019 16:37:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 버블 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 버블 벙렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 버블 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 버블 벙렬</a></p><p><strong>‘버블 정렬(Bubble Sort)’</strong>은 이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘이다.<br>배열을 좌우가 아니라 상하로 그리면 정렬하는 과정에서 작은 수가 ‘거품’처럼 위로 올라가는 것이 연상된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>BubbleSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for pass = 1 to n - 1</span><br><span class="line">  for i = 1 to n - pass</span><br><span class="line">    if (A[i-1] &gt; A[i])// 위의 원소가 아래의 원소보다 크면</span><br><span class="line">      A[i-1] &lt;-&gt; A[i] // 서로 자리를 바꾼다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>다음의 배열에 대해 버블 정렬이 수행되는 과정을 확인한다.</p><div align="center"><br><img src="/image/algo25-1.png"><br></div><ul><li>패스 1</li></ul><p><img src="/image/algo25-2.png">  </p><ul><li>패스 2</li></ul><p><img src="/image/algo25-3.png">  </p><ul><li>패스 3</li></ul><p><img src="/image/algo25-4.png">  </p><ul><li>패스 4</li></ul><p><img src="/image/algo25-5.png">  </p><ul><li>패스 5~7의 결과는 패스 4의 결과와 동일하다.</li></ul><p><strong>배열의 가장 아래부터 정렬되는 것을 확인할 수 있다.</strong></p><hr><p><a name="3">3. 시간복잡도</a></p><p>pass = 1이면 (n-1)번 비교, pass = 2이면 (n-2)번 비교, pass = (n-1)이면 1번 비교한다.<br>따라서 총 비교 횟수는 n(n-1)/2이다.<br>그리고 if-조건이 참일 경우 자리바꾸는 시간 O(1)이 걸린다.<br>최악의 경우를 가정하고 시간복잡도를 구하면, O(n<sup>2</sup>)이 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정렬 알고리즘</title>
      <link>http://dudri63.github.io/2019/02/01/algo24/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo24/</guid>
      <pubDate>Thu, 31 Jan 2019 15:39:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;정렬 알고리즘&lt;/strong&gt; 분류는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기본 정렬 알고리즘&lt;/strong&gt; : 버블 정렬, 선택 정렬, 삽입 정렬&lt;/li&gt;
&lt;li&gt;보다 &lt;strong&gt;효율적인 정렬 알고리즘&lt;/str
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>정렬 알고리즘</strong> 분류는 다음과 같다.</p><ul><li><strong>기본 정렬 알고리즘</strong> : 버블 정렬, 선택 정렬, 삽입 정렬</li><li>보다 <strong>효율적인 정렬 알고리즘</strong> : 쉘 정렬, 힙 정렬, 합병 정렬, 퀵 정렬, 기수 정렬</li></ul><p>특히 기수 정렬은 제한된 크기 이내의 숫자로 구성되어 있을 때 매우 효율적이다.</p><p>정렬 알고리즘은 또한 <strong>내부정렬(Internal Sort)</strong>과 <strong>외부 정렬(External Sort)</strong>로도 분류할 수 있다.</p><ul><li>내부 정렬 : 입력의 크기가 메인 메모리의 공간보다 크지 않은 경우 수행, 앞서 언급한 정렬 알고리즘들은 모두 내부 정렬 알고리즘들이다.</li><li>외부 정렬 : 입력의 크기가 메인 메모리의 공간보다 큰 경우 수행, 보조 기억 장치에 있는 입력을 여러 번에 나누어 주기억 장치에 읽어들인 후, 정렬하여 보조 기억 장치에 다시 저장하는 과정을 반복한다.</li></ul><p>앞으로 포스팅하는 모든 정렬 알고리즘은 오름차순으로 정렬하겠다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝/머신러닝] TensorFlow</title>
      <link>http://dudri63.github.io/2019/01/30/adl2/</link>
      <guid>http://dudri63.github.io/2019/01/30/adl2/</guid>
      <pubDate>Wed, 30 Jan 2019 13:14:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. TensorFlow&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. TensorFlow 예제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. TensorFlow 구조&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. placeholder&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. TensorFlow</a><br><a href="#2">2. TensorFlow 예제</a><br><a href="#3">3. TensorFlow 구조</a><br><a href="#4">4. placeholder</a><br><a href="#5">5. Tesnor, Ranks, Shapes, Types</a></p><hr><p><a name="1">1. TensorFlow</a></p><p><strong>텐서플로우(TensorFlow)</strong>는 구글에서 만든 오픈 소스 라이브러리이다.<br>텐서플로우는 데이터 플로우 그래프(Data Flow Graph)를 이용하여 수 계산(Numerical Computation)을 할 수 있다는 특징이 있다.<br>또한, ‘파이썬(Python)’ 언어를 이용하여 텐서플로우를 활용할 수 있다.</p><p>Data Flow Graph란 다음 그림과 같은 것이다.</p><div align="center"><br><img src="/image/ald2-1.png"><br></div><br>‘노드’와 노드간을 연결하는 ‘엣지’로 구성되어 있는 것을 그래프라고 한다.<br>Data Flow Graph에서 노드는 하나의 operation이다.<br>엣지는 데이터(tensor)이다.<br>데이터들은 연속적으로 연산하여 결과를 추출하는 것이 Data Flow Graph의 방식이다.<br><br><div align="center"><br><img src="/image/ald2-2.png"><br></div><p>리눅스 환경에서 텐서플로우를 설치한 후, 파이썬에서 텐서플로우 모듈을 import 및 버전 정보를 확인한 결과는 위와 같다.</p><hr><p><a name="2">2. TensorFlow 예제</a></p><div align="center"><br><img src="/image/ald2-3.png"><br></div><p>“Hello, TensorFlow!”라는 내용의 constant 노드를 만들고, 변수 hello에 이를 할당한다.<br>(computation 그래프 내에 노드 1개가 만들어진 형태이다.)<br>이 후, session을 만든 뒤 실행(run)시켰다.<br>(computation 그래프를 실행하기 위해서는 session을 만들어야 한다.)</p><p>(b’라는 문자열은 간단하게 byte string이라는 의미이다. 프로그램 동작과는 무관하다)</p><hr><div align="center"><br><img src="/image/ald2-5.png"><br><br><img src="/image/ald2-4.png"><br></div><p>a와 b라는 노드가 있고, ‘+’라는 노드로 연결되는 간단한 그래프를 만든 것이다.</p><p>node1은 ‘3’이라는 내용, data type은 float32인 constant 노드이다.<br>node2는 ‘4’라는 내용의 constant 노드이다. node2는 암묵적으로 node1과 마찬가지로 data type이 float32임을 유의한다.<br>node3은 node1, node2를 더하는 add 노드이다.</p><p>이 후, node1, node2, node3를 print() 함수를 이용하여 출력하면, 각각의 노드들은 Tensor이며, 그 내용들을 확인할 수 있다. 결과값을 확인할 수는 없다.</p><p>결과값을 확인하기 위해서 1. session을 만들고, 2. 해당 session에 원하는 노드들을 넣은 뒤 3. run한다.</p><hr><p><a name="3">3. TensorFlow 구조</a></p><div align="center"><br><img src="/image/ald2-6.png"><br></div><p>텐서플로우의 구조는 위와 같은데 기존의 프로그래밍과는 조금 다르다.</p><ol><li>먼저 그래프를 빌드한다.</li><li>session을 만든 뒤 run한다.</li><li>결과로 graph내의 값을 업데이트한다.</li></ol><hr><p><a name="4">4. plcaeholder</a></p><p>위에서는 그래프를 만들면서, 각 노드들의 숫자들을 지정하였다.<br>그렇다면, 그래프를 미리 만들어 놓고, 실행시키는 단계에서 값을 던지고 싶다면 어떻게 해야할까?</p><p>constant 노드가 아니라, <strong>placeholder</strong>라는 특별한 노드를 사용한다.</p><div align="center"><br><img src="/image/ald2-7.png"><br><img src="/image/ald2-8.png"><br></div><p>a, b, adder_node, 총 3개의 placeholder 노드를 만들었다.<br>이 후, session을 생성한 뒤, feed_dict로 a, b 노드에 값을 할당한 뒤 실행시킨다.<br>1개의 값이 아닌 여러개의 값을 넘겨줄 수도 있다.</p><hr><p><a name="5">5. Tensor, Ranks, Shapes, Types</a></p><p>5.1. Tensor</p><p>TensorFlow 프로그램은 모든 데이터를 <strong>tensor</strong> 데이터 구조를 사용해서 표현한다.<br>TensorFlow의 tensor는 n-차원 배열 또는 리스트라고 생각할 수 있다.<br>하나의 tesnor는 정적 타입, 동적 차원을 가지고 있다.<br>그리고 Computation 그래프의 노드들은 오직 tensor만을 전달할 수 있다.</p><p>5.2. Rank</p><p>TensorFlow 시스템에서 tensor는 <strong>rank</strong>라는 차원 단위로 표현된다.</p><div align="center"><br><img src="/image/ald2-9.png"><br></div><br>위 표는 rank에 따른 tensor의 형식이다.<br><br>5.3. Shape<br><br>TensorFlow 문서는 tensor 차원을 표현할 때, 세 가지 기호를 사용한다.<br>rank, shape, 차원수가 그것들이다.<br>다시 말하면, tensor의 차원을 알기 위해서 rank, shape, 차원수를 살펴볼 수 있다.<br><div align="center"><br><img src="/image/ald2-10.png"><br></div><p>5.4. Data Types</p><p>Tensor는 차원 말고도 <strong>데이터 타입</strong>을 갖는다. 아래의 데이터 타입을 tensor에 지정할 수 있다.</p><div align="center"><br><img src="/image/ald2-11.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>랭크, 크기, 타입-텐서플로우 문서 한글 번역본, 텐서플로우, 2019. 1. 30, <a href="https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\_types.html" rel="external nofollow noopener noreferrer" target="_blank">https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\_types.html</a></li><li>섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/30/adl2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝/머신러닝] 머신러닝이란</title>
      <link>http://dudri63.github.io/2019/01/30/adl1/</link>
      <guid>http://dudri63.github.io/2019/01/30/adl1/</guid>
      <pubDate>Wed, 30 Jan 2019 10:32:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 이세돌과 알파고&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 머신러닝이란&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 이세돌과 알파고&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 이세돌과 알파고</a><br><a href="#2">2. 머신러닝이란</a></p><hr><p><a name="1">1. 이세돌과 알파고</a></p><p>그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의 순간적인 직관이 매우 중요한 것으로 여겨졌다.<br>따라서 바둑이라는 종목에 한해서는 컴퓨터가 인간을 넘어서기 힘들 것으로 꽤 오랜 시간 간주되었다.<br>그러나 이세돌 9단이 알파고에게 4:1로 패배하였다.</p><div align="center"><br><img src="/image/ald1-1.png"><br></div><p>인공지능이란 무엇인가에 대하여 많은 이목이 쏠린 역사적인 사건이다.<br>인공지능은 과연 사람처럼 직관적인 의사결정을 할 수 있는 것인가?</p><div align="center"><br><img src="/image/ald1-2.png"><br></div><p>Dr.Andrew Ng에 의하면 오늘날의 시대를 살기 위해서는 머신러닝 학습이 필수적이라고 이야기한다.<br>또한, 머신러닝을 잘 활용하는 사람이 Super Power를 지닐 수 있다고 한다.</p><hr><p><a name="2">2. 머신러닝이란</a></p><p><strong>머신러닝(Machine Learning)</strong>이란 일종의 소프트웨어, 프로그램이다.<br>그러나 기존 프로그래밍 기법과는 차이점이 있다.</p><p>기존 explicit programming이란 개발자가 환경에 따라서 프로그램이 어떻게 반응할지를 정의한다.<br>그런데 explicit하게, 즉, 명확하게 프로그래밍하기 어려운 경우가 있다.<br>예를 들어, 스팸 메일을 필터링하는 프로그램을 작성할 때 모든 경우를 고려하여 스팸 or not을 결정하기가 어렵다.</p><p>머신러닝의 시작은 상황이 복잡할 때 모든 경우를 일일이 프로그래밍하지 않고, ‘어떤 현상이나 자료에서 자동적으로 배우는 것은 어떨까?’라는 생각이다.<br>즉, 머신러닝은 프로그램인데, 개발자가 모든 경우를 명확하게 프로그래밍 하지 않고, 프로그램이 스스로 학습하여 배운 뒤 처리할 수 있도록 하는 것이라고 할 수 있다.</p><div align="center"><br><img src="/image/ald1-3.png"><br></div><p>머신러닝은 학습하는 방법에 따라서 Supervised Learning, Unsupervised Learning으로 구분할 수 있다.<br>Supervised Learning은 정해져있는 데이터(labeled, training set)를 이용하여 학습하는 것이다.<br>예를 들어, 개나 고양이 사진들의 label을 각각 개, 고양이로 달고 학습을 시킬 수 있다.</p><div align="center"><br><img src="/image/ald1-4.png"><br></div><p>그런데, 모든 경우 label을 달 수 있는 것은 아니다.<br>Google news는 자동적으로 유사한 뉴스들을 grouping을 한다.<br>또한, 유사한 단어들을 grouping하는 것도 특정한 label을 달기 어렵다.<br>이 경우 Unsupervised Learning(학습)하여야 한다.</p><p>머신러닝에서 대부분의 문제들은 Supervised Learning으로 해결할 수 있다.<br>Supervised Learning의 예는 다음과 같다.</p><p><div align="center"><br><img src="/image/ald1-5.png"><br>X: feature, Y: label<br></div></p><ul><li>label이 정해져 있는 feature들을 가지고 학습을 한다.<br>(네모칸 안에 있는 표를 training data set이라고 한다.)</li><li>이 후, 내가 모르는 X<sub>test</sub>의 label을 물어보면, ML은 Y=3이라고 대답한다.</li></ul><p>알파고의 원리도 위와 다르지 않다.<br>기존 바둑 기사들이 둔 기보를 이용하여 학습한 뒤, 이세돌 9단과 대결할 때, 학습한 것을 바탕으로 각 수를 놓는 것이다.</p><p>Supervised Learning의 Type은 다음과 같다.</p><ol><li>공부한 시간에 따른 시험 성적(0~100) 예상 : regression</li><li>공부한 시간에 따른 시험 결과(pass or fail) 예상 : binary classification</li><li>공부한 시간에 따른 시험 성적(A,B,C,D,F) 예상 : multi-label classification</li></ol><p>ML을 이용한 공부한 시간에 따른 시험 성적(0~100) 예상이 어떻게 되는지는 다음과 같다.</p><p><div align="center"><br><img src="/image/ald1-6.png"><br>왼쪽 표는 training data set이다.<br></div><br>regression 모델을 왼쪽 표를 이용하여 training한다. 이 후, x=7(7시간)일 때, y(점수)를 물어보면, 학습한 것을 바탕으로 y=70을 내놓는다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/</a>, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/30/adl1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 클래스</title>
      <link>http://dudri63.github.io/2019/01/29/python8/</link>
      <guid>http://dudri63.github.io/2019/01/29/python8/</guid>
      <pubDate>Tue, 29 Jan 2019 12:31:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 클래스&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 클래스&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 클래스</a></p><hr><p><a name="1">1. 클래스</a></p><p>C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있다.<br>그러나 프로그램 작성 시 클래스를 사용하면 프로그래머가 얻을 수 있는 이점이 굉장히 많다.</p><p>클래스는 ‘과자틀’, 객체는 과자틀에 의해 만들어진 ‘과자’에 비유할 수 있다.<br>클래스란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고, 객체란 클래스에 의해서 만들어진 피조물을 뜻한다.</p><p>클래스에 의해서 만들어진 객체는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 동일한 클래스에 의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Cal:# Cal이라는 새로운 class를 정의</span><br><span class="line">    def __init__(self, v1, v2): # 생성자</span><br><span class="line">        self.v1 = v1</span><br><span class="line">        self.v2 = v2</span><br><span class="line"> </span><br><span class="line">    def add(self):# add 함수</span><br><span class="line">        return self.v1+self.v2</span><br><span class="line"> </span><br><span class="line">    def subtract(self):  # subtract 함수</span><br><span class="line">        return self.v1-self.v2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">c1 = Cal(10,10)# 객체 c1 생성 및 변수에 객체 할당</span><br><span class="line">print(c1.add())# 객체의 멤버에 접근</span><br><span class="line">print(c1.subtract()) # 객체의 멤버에 접근</span><br><span class="line">c2 = Cal(30,20)# 객체 c2 생성 및 변수에 객체 할당</span><br><span class="line">print(c2.add())# 객체의 멤버에 접근</span><br><span class="line">print(c2.subtract())# 객체의 멤버에 접근</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-1.png"><br></div><ul><li>__init__ : 생성자<br>객체를 생성할 때, 생성자의 self를 제외한 매개변수 숫자만큼 인자를 채워야 한다.<br>ex. __init(self,v1, v2)__ -&gt; c1 = Cal(v1,v2)</li><li>self : 객체의 인스턴스 그 자체, 파이썬에서는 클래스의 메소드를 정의할 때 self를 꼭 명시해야 한다.</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        self.value = v</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.value)</span><br><span class="line"> </span><br><span class="line">c1 = C(10)</span><br><span class="line">print(c1.value)# 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출 </span><br><span class="line">c1.value = 20# 객체 c1의 멤버 변수 value의 값을 변경</span><br><span class="line">print(c1.value)# 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출</span><br><span class="line">c1.show()# 객체 c1의 멤버 함수 show()를 호출, show() 함수는 value의 값을 인자로 print() 함수 호출</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-2.png"><br></div><hr><p>cf. 객체와 인스턴스</p><p>클래스에 의해서 만들어진 객체를 인스턴스라고도 한다. 그러나 객체와 인스턴스는 미묘하지만 차이점이 있다. 예를 들어 Cookie라는 클래스가 있다고 가정한다. a = Cookie() 로 만들어진 a는 객체이다. 그리고 a라는 객체는 Cookie의 인스턴스이다. 즉, 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 인스턴스” 보다는 “a는 객체”라는 표현이 어울리며, “a는 Cookie의 객체” 보다는 “a는 Cookie의 인스턴스”라는 표현이 훨씬 잘 어울린다.</p><hr><p>cf. 변수 </p><p>값을 넣을 수 있는 이름이 붙어있는 공간. 일반적으로 값을 변경할 수 있다. 값을 변경할 수 없을 경우 특별하게 ‘상수’라고 한다.</p><hr><p>cf. 인스턴스 변수와 클래스 변수</p><p>인스턴스 변수와 클래스 변수를 합쳐서 ‘멤버 변수’라고 한다. 인스턴스 변수는 객체를 생성할 때 생성된다. 각각의 인스턴스마다 다른 값을 가질 수 있다. 클래스 변수는 인스턴스 변수에 static이 붙은 형식이다. 인스턴스 변수는 각각 고유한 값을 가질 수 있는 것에 반해 클래스 변수는 모든 인스턴스가 동일한 값을 공유한다. 인스턴스 변수, 클래스 변수 모두 Class 내부에서 선언된다.</p><hr><p>cf. 캡슐화</p><p>캡슐화(Encapsulation)는 객체 지향 프로그래미에서 다음 2가지 측면이 있다.</p><ul><li>객체의 속성과 행위를 하나로 묶고,</li><li>실제 구현 내용을 외부에 감추어 은닉한다.</li></ul><p>외부로부터 영향을 받지 변경되지 않도록 기본적으로 캡슐화를 이용한다. 함수나 변수도 캡슐로 감싼 예 중 하나이다. 또한 함수들을 다시 묶어서 모듈로 감쌀 수도 있다. 접근 지정자를 따로 지정하여 외부에서 캡슐에 얼마나 접근할 수 있을지 설정하기도 한다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        self.value = v</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.value)</span><br><span class="line">    def getValue(self):# 인스턴스의 value를 반환</span><br><span class="line">        return self.value</span><br><span class="line">    def setValue(self, v):# 인스턴스의 value를 설정 </span><br><span class="line">        self.value = v</span><br><span class="line">c1 = C(10)# C의 인스턴스 c1 생성 </span><br><span class="line">print(c1.getValue())# c1의 value값을 받아온 뒤, print() 호출</span><br><span class="line">c1.setValue(20)# c1의 value값을 설정</span><br><span class="line">print(c1.getValue())# c1의 value값을 받아온 뒤, print() 호출</span><br></pre></td></tr></table></figure><p>set은 객체 내부의 데이터를 직접 바꾸기 위한 메소드,<br>get은 객체 내부의 데이터를 직접 받아오기 위한 메소드이다.</p><div align="center"><br><img src="/image/py8-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    bag = []# bag 속성(클래스 속성)</span><br><span class="line"> </span><br><span class="line">    def put_bag(self, stuff):</span><br><span class="line">        self.bag.append(stuff)</span><br><span class="line"> </span><br><span class="line">james = Person()</span><br><span class="line">james.put_bag(&apos;책&apos;)</span><br><span class="line"> </span><br><span class="line">maria = Person()</span><br><span class="line">maria.put_bag(&apos;열쇠&apos;)</span><br><span class="line"> </span><br><span class="line">print(james.bag)</span><br><span class="line">print(maria.bag)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-4.png"><br></div><p><strong>클래스 속성</strong>으로서 bag 속성을 만들었다. james 인스턴스에서 ‘책’을 넣었고, maria 인스턴스에서 ‘열쇠’를 넣었는데, james, maria 모두 bag 속성으로서 책과 열쇠를 모두 갖는다.<br>클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bag = []# bag 속성(인스턴스 속성)</span><br><span class="line"> </span><br><span class="line">    def put_bag(self, stuff):</span><br><span class="line">        self.bag.append(stuff)</span><br><span class="line"> </span><br><span class="line">james = Person()</span><br><span class="line">james.put_bag(&apos;책&apos;)</span><br><span class="line"> </span><br><span class="line">maria = Person()</span><br><span class="line">maria.put_bag(&apos;열쇠&apos;)</span><br><span class="line"> </span><br><span class="line">print(james.bag)</span><br><span class="line">print(maria.bag)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-5.png"><br></div><p><strong>인스턴스 속성</strong>으로서 bag 속성을 만들었다. 이 경우, 클래스 속성으로 만들었을 때와는 달리 각 인스턴스마다 고유한 속성을 갖게 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>05-1 클래스, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/28" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/28</a></li><li>35.1 크래스 속성과 인스턴스 속성 알아보기, 코딩도장, 2019. 1. 29, <a href="https://dojang.io/mod/page/view.php?id=2378" rel="external nofollow noopener noreferrer" target="_blank">https://dojang.io/mod/page/view.php?id=2378</a></li><li>객체와 변수, 생활코딩, 2019. 1. 29, <a href="https://opentutorials.org/course/1750/10000" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/10000</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/python8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 동전 거스름돈 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/29/algo23/</link>
      <guid>http://dudri63.github.io/2019/01/29/algo23/</guid>
      <pubDate>Tue, 29 Jan 2019 09:07:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 동전 거스름돈&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 동전 거스름돈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;거스름돈을
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 동전 거스름돈</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 동전 거스름돈</a></p><p>거스름돈을 동전으로 받을 때, 누구나 적은 수의 동전을 받길 원한다고 가정한다.<br>동전 거스름돈 문제는 그리디 알고리즘으로 해결할 수도 있으나, 160원짜리 동전을 추가로 발행하는 등의 상황이 있을 때는 항상 최적해를 찾을 수는 없다.<br>동적 계획 알고리즘은 모든 동전 거스름돈 문제에 대하여 항상 최적해를 찾는다.</p><p>다른 문제들과 마찬가지로 동적 계획 알고리즘을 고안하기 위해서는 부분문제들을 찾아내야 한다.<br>동전 거스름돈 문제에 주어지는 일반적인 문제 요소들을 고려한다.<br>정해진 동전의 종류, 거스름돈이 그것들이다.</p><p>동전 거스름돈 문제도 배낭 문제와 마찬가지로 동전 거스름돈도 1원씩 증가시켜 문제를 해결한다.<br>그리고 부분문제들의 해를 1차원 배열 C에 저장한다.</p><ul><li>1원을 거슬러 받을 때 사용되는 최소의 동전 수 C[1]</li><li>2원을 거슬러 받을 때 사용되는 최소의 동전 수 C[2]</li><li>3원을 거슬러 받을 때 사용되는 최소의 동전 수 C[3]<br>…</li><li>n원을 거슬러 받을 때 사용되는 최소의 동전 수 C[n]</li></ul><p>그렇다면, C[j]를 구하는 데 어떤 부분문제가 필요한가?</p><ul><li>500원짜리 동전이 거스름돈 j원에 필요하면 C[j-500] = C[j-d<sub>1</sub>]에 500원짜리 동전 1개를 추가한다.</li><li>100원짜리 동전이 거스름돈 j원에 필요하면 C[j-100] = C[j-d<sub>2</sub>]에 100원짜리 동전 1개를 추가&gt;한다. </li><li>50원짜리 동전이 거스름돈 j원에 필요하면 C[j-50] = C[j-d<sub>3</sub>]에 50원짜리 동전 1개를 추가&gt;한다.</li><li>10원짜리 동전이 거스름돈 j원에 필요하면 C[j-10] = C[j-d<sub>4</sub>]에 10원짜리 동전 1개를 추가&gt;한다.</li><li>1원짜리 동전이 거스름돈 j원에 필요하면 C[j-1] = C[j-d<sub>5</sub>]에 1원짜리 동전 1개를 추가&gt;한다.</li></ul><p>위 다섯 가지 중에서 가장 작은 값을 C[j]로 정한다. 그리하여 C[j]의 정의는 다음과 같다.</p><p>C[j] = min<sub>1&lt;=i&lt;=k</sub>{C[j-d<sub>i</sub>] + 1}, if j &gt;= d<sub>i</sub></p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 거스름돈 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 배열 C는 최소의 동전 수를 저장하는 데 사용된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DPCoinChange</span><br><span class="line">입력: 거스름돈 n원, k개의 동전의 액면, d1&gt;d2&gt;...&gt;dk=1</span><br><span class="line">출력: C[n]</span><br><span class="line">for i = 1 to n C[i] = ∞</span><br><span class="line">C[0] = 0</span><br><span class="line">for j = 1 to n &#123;// j는 1원부터 증가하는 임시 거스름돈 액수, j=n이면 입력에 주어진 거스름돈</span><br><span class="line">  for i = 1 to k &#123;// 액면이 가장 높은 동전부터 1원짜리 동전까지</span><br><span class="line">    if (di &lt;= j) and (C[j-di] + 1 &lt; C[j])// 액면이 가장 높은 동전부터 1원짜리 동전까지</span><br><span class="line">      C[j] = C[j-di] + 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return C[n]</span><br></pre></td></tr></table></figure></p><p>다음은 d<sub>1</sub>=16, d<sub>2</sub>=10, d<sub>3</sub>=5, d<sub>4</sub>=1이고, 거스름돈 n=20일 때, DPCoinChange 알고리즘이 수행되는 과정이다.</p><div align="center"><br><img src="/image/algo23-1.png"><br></div><ul><li><p>Line 4~5 : 배열 C를 초기화한다.<br><img src="/image/algo23-2.png">  </p></li><li><p>Line 6~9 : j = 1일 때(임시 거스름론), </p><ul><li><p>i = 1, 2, 3일 때,<br>d<sub>1</sub> = 16 &gt; j, d<sub>2</sub>=10 &gt; j, d<sub>3</sub>=5 &gt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 4일 때,<br>d<sub>4</sub> = 1 &lt; j, C[j-d<sub>4</sub>]+1 = C[1-1]+1 = 0+1 = 1 &lt; C[j] = C[1] = ∞<br>if 조건을 만족<br>C[j] = C[j-d<sub>4</sub>] + 1 = C[1] = C[1-1] + 1 = 0 + 1 = 1</p></li></ul></li><li><p>Line 6~9 : j = 2, 3, 4일 때,</p><ul><li>i = 4일 때에만 if 조건을 만족함(j = 1일 때와 동일)<br>C[2] = C[2-1] + 1 = 2, C[3] = 3, C[4] = 4</li></ul><p><img src="/image/algo23-3.png"></p></li><li><p>Line 6~9 : j = 5일 때</p><ul><li><p>i = 1, 2일 때,<br>d<sub>1</sub> = 16 &gt; j, d<sub>2</sub>=10 &gt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 3일 때,<br>d<sub>3</sub> = 5 = j, C[j-d<sub>3</sub>]+1 = C[5-5]+1 = 0+1 = 1 &lt; C[j] = C[5] = ∞<br>if 조건을 만족<br>C[5] = C[j-d<sub>3</sub>]+1 = C[5-5]+1 = 0+1 = 1</p></li><li><p>i = 4일 때,<br>d<sub>4</sub> = 1 = j, C[j-d<sub>4</sub>]+1 = C[5-1]+1 = 4+1 = 5 &gt; C[j] = C[5] = 1<br>if 조건을 만족하지 않음</p></li></ul></li><li><p>Line 6~9 : j = 6, 7, 8, 9일 때</p><ul><li>i = 3일 경우에만 if 조건을 만족함(j = 5일 때와 동일)<br>C[6] = C[6-5] + 1 = 2, C[7] = 3, C[8] = 4, C[9] = 5</li></ul></li></ul><p><img src="/image/algo23-4.png"></p><ul><li><p>Line 6~9 : j = 10일 때</p><ul><li><p>i = 1일 때,<br>d<sub>1</sub> = 16 &gt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 2일 때,<br>d<sub>2</sub> = 10 = j, C[j-d<sub>2</sub>]+1 = C[10-10]+1 = 0+1 = 1 &lt; C[j] = C[10] = ∞<br>if 조건을 만족<br>C[10] = C[j-d<sub>2</sub>]+1 = C[10-10]+1 = 0+1 = 1</p></li><li><p>i = 3,4 일 때,<br>d<sub>i</sub> &lt; j = 10,<br>C[j-d<sub>3</sub>]+1 = C[10-5]+1 = 2 &gt; 1, C[j-d<sub>4</sub>]+1 = C[10-1]+1 = 6 &gt; 1<br>if 조건을 만족하지 않음</p></li></ul></li><li><p>Line 6~9 : j = 11, 12, 13, 14, 15일 때</p><ul><li>i = 2일 경우에만 if 조건을 만족함(j = 10일 때와 동일)<br>C[11] = 2, C[12] = 3, C[13] = 4, C[14] = 5</li></ul></li></ul><p><img src="/image/algo23-5.png"></p><ul><li><p>Line 6~9 : j =15일 때</p><ul><li><p>i = 1일 때,<br>d<sub>1</sub> = 16 &lt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 2일 때,<br>d<sub>2</sub> = 10 &gt; j, C[j-d<sub>2</sub>]+1 = C[15-10]+1 = 1+1 = 2 &lt; C[j] = C[10] = ∞<br>if 조건을 만족<br>C[15] = C[j-d<sub>2</sub>]+1 = C[15-10]+1 = 2</p></li><li><p>i = 3,4일 때,<br>if 조건을 만족하지 않음</p></li></ul></li></ul><p><img src="/image/algo23-6.png"></p><ul><li><p>Line 6~9 : j = 16일 때</p><ul><li>i = 1일 때,<br>d<sub>1</sub> = 16 = j, C[j-d<sub>1</sub>]+1 = C[16-16]+1 = 0+1 = 1 &lt; C[j] = C[16] = ∞<br>if 조건을 만족<br>C[16] = C[j-d<sub>1</sub>]+1 = C[16-16]+1 = 0+1 = 1</li><li>i = 2, 3, 4일 때,<br>if 조건을 만족하지 않음</li></ul></li><li><p>Line 6~9 : j = 17, 18, 19일 때</p><ul><li>i = 1일 경우에만 if 조건을 만족함(j = 16일 때와 동일)<br>C[17] = 2, C[18] = 3, C[19] = 4</li></ul></li></ul><p><img src="/image/algo23-7.png"></p><ul><li><p>Line 6~9 : j = 20일 때</p><ul><li><p>i = 1<br>if 조건을 만족하지 않음</p></li><li><p>i = 2<br>if 조건을 만족<br>C[20] = C[j-d<sub>2</sub>]+1 = C[10]+1 = 2</p></li><li><p>i = 3<br>C[20] = C[j-d<sub>3</sub>]+1 = C[15]+1 = 3 &gt; 2<br>if 조건을 만족하지 않음</p></li><li><p>i = 4일 때<br>C[20] = C[j-d<sub>4</sub>]+1 = C[19]+1 = 5 &gt; 2<br>if 조건을 만족하지 않음</p></li></ul></li></ul><p><img src="/image/algo23-8.png"></p><ul><li>Line 12 C[20] = 2를 return</li></ul><p><a name="3">3. 시간복잡도</a> </p><p>DPCoinChange 알고리즘의 시간복잡도는 O(nk)이다.<br>왜냐하면 거스름돈 j가 1원부터 n원까지 변하며, 각각의 j에 대하여 최악의 경우 모든 동전을 1번씩 고려하기 때문이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/algo23/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 배낭 문제 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/29/algo22/</link>
      <guid>http://dudri63.github.io/2019/01/29/algo22/</guid>
      <pubDate>Tue, 29 Jan 2019 06:53:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 배낭 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 배낭 문제&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;배
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 배낭 문제</a><br><a href="#1">2. 알고리즘</a><br><a href="#1">3. 시간 복잡도</a></p><hr><p><a name="1">1. 배낭 문제</a></p><p><strong>배낭 문제(Knapsack)</strong>는 n개의 물건과 각 물건 i의 무게 w<sub>i</sub>와 가치 v<sub>i</sub>가 주어지고, 배낭의 용량이 C일 때, 배낭에 담을 수 있는 물건의 최대 가치를 찾는 문제이다.<br>단, 배나에 담은 물건의 무게의 합이 C를 초과하지 말아야 하고, 각 물건은 1개씩만 있다. 이러한 배낭 문제를 <strong>0-1 배낭 문제</strong>라고 하는데, 이는 각 물건이 담기지 않은 경우 ‘0’, 담긴 경우 ‘1’로 간주하기 때문이다.</p><p>배낭 문제는 제한적입 입력에 대해서 동적 계획 알고리즘으로 풀 수 있다.<br>배낭 문제의 부분 문제를 정의하기 위해서 물건, 물건의 무게, 물건의 가치, 배낭의 용량, 4가지의 요소를 고려할 수 있다.</p><p>배낭 문제의 부분문제의 정의를 위해 물건은 하나씩 차례로 고려하면 되지만, 물건의 무게는 각각 다를 수 있기 때문에, 무게에 대해서는 배낭의 용량 0(kg)으로부터 1(kg)씩 증가하여 입력으로 주어진 용량 C가 될 때까지 변화시켜 가며 물건을 배낭에 담는 것이 가치가 더 커지는지를 결정해야 한다. 따라서 배낭 용량이 0부터 1씩 증가할 경우의 용량을 ‘임시’ 배낭 용량이라고 한다.<br>따라서 배낭 문제의 부분문제를 다음과 같이 정의할 수 있다.</p><p>K[i,w] = 물건 1~i까지만 고려하고, (임시) 배낭 용량이 w일 때의 최대 가치<br>단, i - 1, 2, …, n, w = 1, 2, 3, …, C이다.</p><p>문제의 최적해는 K[n,C]이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 배낭 문제의 동적 계획 알고리즘이다. 2차원 배열 K가 최대 가치를 저장하는 데 사용된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Knapsack</span><br><span class="line">입력: 배낭의 용량 C, n개의 물건, 각 물건 i의 무게 wi, 가치 vi, 단, i = 1,2,3,...,n</span><br><span class="line">출력: K[n,C]</span><br><span class="line">for i = 0 to nK[i,0]=0// 배낭의 용량이 0일 때 총 가치 0으로 초기화</span><br><span class="line">for w = 0 to CK[0,w]=0// 배낭에 아무것도 담기지 않았을 때 총 가치 0으로 초기화</span><br><span class="line">for i = 1 to n &#123;</span><br><span class="line">  for w = 1 to C &#123;</span><br><span class="line">    if (wi &gt; w)// 물건 i의 무게가 임시 배낭의 용량을 초과하면</span><br><span class="line">      K[i,w] = K[i-1,w]</span><br><span class="line">    else// 물건 i를 배낭에 담지 않을 경우와 담을 경우를 고려</span><br><span class="line">      K[i,w] = max&#123;K[i-1,w], K[i-1,w-wi]+vi&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return K[n,C]</span><br></pre></td></tr></table></figure><ul><li>Line 8~9 : 현재 배낭에 담으려고 고려하는 물건 i의 무게 w<sub>i</sub>가 임시 배낭의 무게 w보다 크면 배낭에 담을 수 없다. 따라서 K[i,w]는 물건 (i-1)까지 담은 K[i-1,w]가 된다.</li><li>Line 10~11 : 고려하는 물건 i의 무게 w<sub>i</sub>가 임시 배낭의 무게 w보다 같거나 작으면, 물건 i를 배낭에 담을 수 있다. 그러나 배낭에서 물건 i를 담을 공간을 마련하는 작업을 고려하여야 한다.(배낭의 무게가 부족할 경우)</li></ul><p>즉, 물건 i를 배낭에 담기 위해서는 2가지 경우를 살펴보아야 한다.</p><div align="center"><br><img src="/image/algo22-1.png"><br></div><p>1) 물건 i를 배낭에 담을 수 없는 경우, K[i,w] = K[i-1,w]<br>2) 물건 i를 배낭에 담을 수 있는 경우, K[i,w] = max{K[i-1,w],K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>}, 기존 물건을 빼고 물건 i를 담거나, 물건 i를 담지 않거나, 기존 물건들은 배낭에 냅둔 체 물건 i를 새롭게 담는 경우로서 3가지 경우를 망라한다.</p><p>배낭의 용량이 C=10kg, 각 물건의 무게와 가치가 다음과 같을 때 위 알고리즘이 적용되는 것을 본다.</p><div align="center"><br><img src="/image/algo22-2.png"><br><br></div><ul><li>Line 3~4 : 0번 행과 0번 열의 각 원소를 ‘0’으로 초기화한다.</li></ul><div align="center"><br><img src="/image/algo22-3.png"><br><br></div><ul><li><p>Line 5 : 물건을 하나씩 고려하기 위해 물건 번호 i가 1~4까지 변화<br>Line 6 : 배낭의 임시 용량 w가 1씩 증가하여 마지막엔 10kg이 된다.</p><ul><li><p>i = 1일 때,</p><ul><li>w = 1일 때, 물건 1을 배낭에 담으려고 한다. 그러나 w<sub>1</sub>=5 &gt; w=1, K[1,1] = K[1-1,1] = 0</li><li>w = 2, 3, 4일 때, w<sub>1</sub> &gt; w, K[1,2]=K[1,3]=K[1,4]=0</li><li>w = 5일 때, w<sub>1</sub> = w = 5,<br>K[1,5] = max{K[i-1,w], K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>} = max{K[0,5], K[0,0] + 10} = max{0, 10} = 10</li><li>w = 6, 7, 8, 9, 10일 때, w = 5일 때와 같다. K[1,6] = K[1,7] = K[1,8] = K[1,9] = K[1,10] = 10이다.<br><img src="/image/algo22-4.png"></li></ul></li><li><p>i = 2일 때, 물건 1에 대한 부분문제들의 해는 구한 상태, 이를 이용하여 물건 2를 고려한다.</p><ul><li>w = 1, 2, 3일 때, 물건 2를 배낭에 담으려고 한다. 그러나 w<sub>2</sub>=4 &gt; w, K[2,1] = K[2,2] = K[2,3] = 0</li><li>w = 4일 때, 물건 2를 배낭에 담을 수 있다.<br>K[2,4] = max{K[i-1,w], K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>} = max{K[1,4], K[1,0]+40} = max{0, 40} = 40</li><li>w = 5일 때, 물건 2를 배낭에 담을 수 있다. 그러나 물건 1이 배낭에 담았을 때의 가치와 물건 2를 담았을 때의 가치를 비교하여, 더 큰 가치를 얻는 물건을 배낭에 담는다.<br>K[2,5] = max{K[i-1,w], K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>} = max{K[1,5], K[1,1]+40} = max{10,40} = 40<br>물건 1을 배낭에서 뺀 후, 물건 2를 담는 것의 가치가 더 높으므로 물건 2를 담는다.</li><li>w = 6, 7, 8일 때, 물건 1을 빼내고 물건 2를 담는 것이 더 큰 가치를 얻는다. K[2,6] = K[2,7] = K[2,8] = 40</li><li>w = 9일 때, 물건 2를 배낭에 담을 수 있다.<br>K[2,9] = max{K[i-1,w], K[i-1,w-w<sub>i&lt;/sub]&gt;+v<sub>i</sub>} = max{10,50} = 50<br>배낭에 물건 1,2를 모두 담을 수 있고, 그때 가치가 50이 된다.</sub></li><li>w = 10일 때, w = 9일 때와 마찬가지로 물건 1,2를 모두 담을 수 있고, K[2,10] = 50이 된다.<br><img src="/image/algo22-5.png"></li></ul></li><li><p>i = 3, 4일 때 알고리즘 수행 결과는 다음과 같다.<br><img src="/image/algo22-6.png"></p></li></ul></li><li><p>최적해는 물건 2와 4의 가치의 합인 90이다.</p></li></ul><hr><p><a name="3">3. 시간 복잡도</a></p><p>Knapsack 알고리즘은 line 8에서 무게를 한번 비교한 후 line 9에서 1개의 부분문제의 해를 참조 line 11에서 2개희 해를 참조한 계산이므로 O(1) 시간이 걸린다. 그런데, 부분문제의 수는 원소 수인 n*C이므로, 시간복잡도는 O(1)*n*C = O(nC)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/algo22/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 편집 거리 문제 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/29/algo21/</link>
      <guid>http://dudri63.github.io/2019/01/29/algo21/</guid>
      <pubDate>Tue, 29 Jan 2019 05:32:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 편집 거리 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1.편집 거리 문제&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;문서 편
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 편집 거리 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1.편집 거리 문제</a></p><p>문서 편집기를 사용하는 중에 하나의 문자열을 수정하여 다른 문자열로 변환시키고자 할 때, <strong>삽입(insert)</strong>, <strong>삭제(delete)</strong>, <strong>대체(substitute)</strong> 연산이 사용된다. 예를 들어, A를 B로 변환시키는 데 필요한 최소의 편집 연산 횟수를 <strong>편집 거리(Edit Distance)</strong>라고 한다. 편집 거리 문제는 편집 거리를 찾는 문제이다.</p><p>예를 들어, ‘strong’을 ‘stone’으로 편집하는 과정을 본다.</p><div align="center"><br><img src="/image/algo21-1.png"><br></div><p>‘s’, ‘t’는 그대로 사용, ‘o’를 삽입, ‘r’, ‘o’를 삭제, ‘n’을 그대로 사용, ‘g’를 ‘e’로 대체한다.<br>이 경우, 총 4회의 편집 연산이 수행되었다.(삽입 1회, 삭제 2회, 대체 1회)</p><div align="center"><br><img src="/image/algo21-2.png"><br></div><p>반면에 위 경우, ‘r’ 삭제, ‘g’를 ‘e’로 대체, 단 2회의 편집 연산을 수행하였다.</p><p>이처럼 문자를 편집할 때, 어떤 연산을 어느 문자에 수행하느냐에 따라서 편집 연산 횟수가 달라진다.</p><div align="center"><br><img src="/image/algo21-3.png"><br></div><p>부분 문제를 정의하기 위하여 스트링 S, T를 위와 같이 지정하고, 길이를 각각 m, n이라고 한다. 그리고 각각의 문자를 s<sub>i</sub>,t<sub>i</sub>이라 한다.</p><p>E[i,j]는 S의 접두부의 i개 문자를 T의 접두부 j개 문자로 변환시키는 데 필요한 최소 편집 연산 횟수, 즉 편집 거리이다.<br>예를 들어, ‘strong’의 접두부는 ‘stro’이므로 i = 4, ‘stone’의 접두부는 ‘sto’이므로 j = 3인데, 각 문자열의 접두부를 바꾸기 위한 편집 거리를 찾는 문제는 E[i,j] = E[4,3]이다.<br>E[4,3]을 점진적으로 E[6,5]를 해결하면 문제의 해를 찾을 수 있다.</p><div align="center"><br><img src="/image/algo21-4.png"><br></div><ul><li>s<sub>1</sub> -&gt; t<sub>1</sub> 부분문제 : E[1,1] = 0</li><li>S<sub>1</sub> -&gt; t<sub>1</sub>t<sub>2</sub> 부분문제 : E[1,2] = 1, ‘s’를 ‘st’로 편집, ‘t’ 삽입 1회 연산</li><li>s<sub>1</sub>s<sub>2</sub> -&gt; t<sub>1</sub> 부분문제 : E[2,1] = 1, ‘st’를 ‘s’로 편집, ‘t’ 삭제 1회 연산</li><li>s<sub>1</sub>s<sub>2</sub> -&gt; t<sub>1</sub>t<sub>2</sub> 부분문제 : E[2,2] = 0</li></ul><p>이 때, 부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub> -&gt; t<sub>1</sub>t<sub>2</sub>t<sub>3</sub> : E[4,3], ‘stro’를 ‘sto’로 편집은 어떻게 계산하는가?</p><ul><li>E[4,2] (부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub> -&gt; t<sub>1</sub>t<sub>2</sub>)를 알면, t<sub>3</sub> = ‘o’를 삽입하면 된다. 그러므로 E[4,3] = E[4,2] + 1이다.</li><li>E[3,3] (부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub> -&gt; t<sub>1</sub>t<sub>2</sub>t<sub>3</sub>)를 알면, s<sub>4</sub> = ‘o’를 삭제하면 된다. 그러므로 E[4,3] = E[3,3] + 1이다.</li><li>E[3,2] (부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub> -&gt; t<sub>1</sub>t<sub>2</sub>)를 알면, s<sub>4</sub> -&gt; t<sub>3</sub>로 편집하는데 필요한 연산을 계산하면 도니다. 그러나 이 경우, 2개의 문자가 ‘o’로 같으므로 편집할 필요가 없다. 그러므로 E[4,3] = E[3,2]이다.</li></ul><div align="center"><br><img src="/image/algo21-5.png"><br></div><p>따라서 E[4,3]의 편집 거리를 계산하려면 앞의 3가지 부분문제의 해, 즉, E[4,2], E[3,3], E[3,2]의 편집 거리를 알아야 한다. 그런데 이 경우, (2+1), (1+1), 1 중에서 최솟값인 1이 E[4,3]의 편집 거리가 된다.</p><p>일반적으로 E[i-1,j], E[i,j-1], E[i-1,j-1]의 해가 미리 계산되어 있으면 E[i,j]를 계산할 수 있다. 그러므로 편집 거리 문제의 부분문제 간의 함축적인 순서는 다음과 같다.</p><div align="center"><br><img src="/image/algo21-6.png"><br></div><p>위 E[4,3] 예제와 비교하면, 위 그림이 의미하는 바는 금방 파악된다.<br>세 가지 경우 중 가장 적은 값을 E[i,j]의 해로서 선택한다.<br>E[i,j] = min{E[i,j-1]+1, E[i-1,j]+1, E[i-1,j-1]+a} 단, if s<sub>i</sub>=t<sub>j</sub> a=0, else a=1</p><p>위 식을 위해, E[0,0], E[1,0], … , E[m,0]과 E[0,1], E[0,2], … , E[0,n]을 다음과 같이 초기화한다.</p><div align="center"><br><img src="/image/algo21-7.png"><br>ε = (공 문자열)<br></div><br>공 문자열에서 문자열이 하나씩 추가되는 것이므로 삽입 연산에 의해 1씩 증가하는 것은 자명한 사실이다.<br><br><strong><strong><em>**</em></strong></strong><br><br><a name="2">2. 알고리즘</a><br><br>다음은 편집 거리 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 2차원 배열 E는 편집 거리를 저장하는 데 사용된다.<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EditDistance</span><br><span class="line">입력: 스트링 S,T, 단, S와 T의 길이는 각각 m,n이다.</span><br><span class="line">출력: S를 T로 변환하는 편집 거리, E[m,n]</span><br><span class="line">for i=0 to m E[i,0]=i// 0번 열의 초기화</span><br><span class="line">for j=0 to n E[0,j]=j// 0번 행의 초기화</span><br><span class="line">for i=1 to m</span><br><span class="line">  for j=1 to n</span><br><span class="line">    E[i,j] = min&#123;E[i,jj-1]+1, E[i-1,j]+1, E[i-1,j-1]+a&#125;</span><br><span class="line">return E[m,n]</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/image/algo21-8.png"><br></div><p>위 그림은 EditDistance 알고리즘이 ‘strong’을 ‘stone’으로 바꾸는 데 필요한 거리를 계산한 결과인 배열 E이다.<br>a = 0 or a = 1인 경우에 유의하여 9시, 11시, 12시 방향에서 가장 작은 값을 푸른색 배경의 셀에 넣으면서 나아가면 된다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>EditDistance 알고리즘의 시간복잡도는 O(mn)이다. 총 부분문제의 수가 m*n이고, 각 부분문제를 해결하기 위해서 주위의 3개의 부분문제들의 해를 참조한 후 최솟값을 찾는 것이므로 O(1) 시간이 걸리기 때문이다. </p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/algo21/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 함수, 모듈</title>
      <link>http://dudri63.github.io/2019/01/29/python7/</link>
      <guid>http://dudri63.github.io/2019/01/29/python7/</guid>
      <pubDate>Mon, 28 Jan 2019 15:08:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 함수&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 모듈&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 함수&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;함수란 믹서기와 같다. 입력값을 가지고 어떤 일을 수핸한 다음에 그 결과물을 내놓는 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 함수</a><br><a href="#2">2. 모듈</a></p><hr><p><a name="1">1. 함수</a></p><p>함수란 믹서기와 같다. 입력값을 가지고 어떤 일을 수핸한 다음에 그 결과물을 내놓는 역할을 한다.<br>예를 들어 y = 4x + 5도 함수이다.</p><p>프로그래밍을 하다 보면 똑같은 내용을 반복해서 작성할 수 있다. 이 때, 함수를 사용하면 유용하다.<br>또한, 프로그램을 함수화하면 프로그램의 흐름을 일목요연하게 볼 수 있다. 이 경우, 에러가 발생 시에도 어디서 발생하였는지 금방 알 수 있다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def a3():# 함수 a3() 정의</span><br><span class="line">    print(&apos;aaa&apos;)</span><br><span class="line">a3()</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-1.png"><br></div><p>def : 함수를 정의한다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def a3():</span><br><span class="line">    return &apos;aaa&apos;</span><br><span class="line">print(a3())</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-2.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def a(num):</span><br><span class="line">    return &apos;a&apos;*num</span><br><span class="line">print(a(3))</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def make_string(str, num):</span><br><span class="line">    return str*num</span><br><span class="line">print(make_string(&apos;b&apos;, 3))</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-4.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">def login(_id):</span><br><span class="line">    members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]</span><br><span class="line">    for member in members:</span><br><span class="line">        if member == _id:</span><br><span class="line">            return True</span><br><span class="line">    return False</span><br><span class="line">if login(input_id):</span><br><span class="line">    print(&apos;Hello, &apos;+input_id)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;Who are you?&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-5.png"><br></div><hr><p><a name="2">2. 모듈</a></p><p>모듈이란 함수나 변수 또는 클래스들을 모아놓은 파일이다.<br>또한, 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.<br>다른 사람들이 이미 만들어놓은 모듈을 사용할 수도 있고, 직접 만들어서 사용할 수도 있다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">print(math.ceil(2.9))</span><br><span class="line">print(math.floor(2.9))</span><br><span class="line">print(math.sqrt(16))</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-6.png"><br></div><p>math 모듈은 여러가지 수학 관련 함수를 담고 있는 모듈이다.</p><p>ceil(x) : x를 가까운 정수까지 반올림한 뒤 반환<br>floor(x) : x를 가까운 정수까지 버림한 뒤 반환<br>sqrt(x) : x의 제곱근을 반환</p><hr><p>egoing.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def a():</span><br><span class="line">    return &apos;a&apos;</span><br><span class="line">def b():</span><br><span class="line">    return &apos;b&apos;</span><br><span class="line">def c():</span><br><span class="line">    return &apos;c&apos;</span><br></pre></td></tr></table></figure></p><p>k8805.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def a():</span><br><span class="line">    return &apos;B&apos;</span><br></pre></td></tr></table></figure></p><p>6.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from egoing import a as z</span><br><span class="line">import k8805 as k</span><br><span class="line">print(z())</span><br><span class="line">print(k.a())</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/py7-7.png"><br></div><p>egoing 모듈로부터 모듈함수를 import할 수 있다. 이 경우, 모듈이름을 붙이지 않고 바로 해당 모듈의 함수를 사용할 수 있다.<br>또한, 모듈을 import할 경우, 해당 모듈 함수를 사용하기 위해서는 모듈이름을 붙여야 한다.</p><hr><p>auth.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def login(_id):</span><br><span class="line">    members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]</span><br><span class="line">    for member in members:</span><br><span class="line">        if member == _id:</span><br><span class="line">            return True</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure></p><p>6.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import auth</span><br><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">if auth.login(input_id):</span><br><span class="line">    print(&apos;Hello, &apos;+input_id)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;Who are you?&apos;)</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/py7-8.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>‘04-1 함수’, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/24#_1" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/24#_1</a></li><li>‘05-5 내장 함수’, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/32#len" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/32#len</a></li><li>‘[파이썬]공통함수,수학(math) 함수’, andamiro25, 2019. 1. 29, <a href="https://andamiro25.tistory.com/" rel="external nofollow noopener noreferrer" target="_blank">https://andamiro25.tistory.com/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/python7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 반복문</title>
      <link>http://dudri63.github.io/2019/01/28/python6/</link>
      <guid>http://dudri63.github.io/2019/01/28/python6/</guid>
      <pubDate>Mon, 28 Jan 2019 14:46:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 반복문, while&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 컨테이너와 반복문&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. for&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 반복문, while&lt;/a&gt;&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 반복문, while</a><br><a href="#2">2. 컨테이너와 반복문</a><br><a href="#3">3. for</a></p><hr><p><a name="1">1. 반복문, while</a></p><p>1.1 반복문이 없다면</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello world 0&quot;)</span><br><span class="line">print(&quot;Hello world 9&quot;)</span><br><span class="line">print(&quot;Hello world 18&quot;)</span><br><span class="line">print(&quot;Hello world 27&quot;)</span><br><span class="line">print(&quot;Hello world 36&quot;)</span><br><span class="line">print(&quot;Hello world 45&quot;)</span><br><span class="line">print(&quot;Hello world 54&quot;)</span><br><span class="line">print(&quot;Hello world 63&quot;)</span><br><span class="line">print(&quot;Hello world 72&quot;)</span><br><span class="line">print(&quot;Hello world 81&quot;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-1.png"><br></div><p>1.2 while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while False:</span><br><span class="line">    print(&apos;Hello world&apos;)</span><br><span class="line">print(&apos;After while&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-2.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 3:</span><br><span class="line">    print(&apos;Hello world&apos;)</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(&apos;print(&quot;Hello world &apos;+str(i*9)+&apos;&quot;)&apos;)</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-4.png"><br></div><p>str() : 숫자를 문자열로 변환하는 함수</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    if i == 4:</span><br><span class="line">        print(i)</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-5.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    if i == 4:</span><br><span class="line">        break</span><br><span class="line">    print(i)</span><br><span class="line">    i = i + 1</span><br><span class="line">print(&apos;after while&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-6.png"><br></div><hr><p><a name="2">2. 컨테이너와 반복문</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]</span><br><span class="line">i = 0</span><br><span class="line">while i &lt; len(members):</span><br><span class="line">    print(members[i])</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-7.png"><br></div><hr><p><a name="3">3. for</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]</span><br><span class="line">for member in members:</span><br><span class="line">    print(member)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-8.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for item in range(5, 11):</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-9.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]</span><br><span class="line">for member in members:</span><br><span class="line">    if member == input_id:</span><br><span class="line">        print(&apos;Hello!, &apos;+member)</span><br><span class="line">        import sys</span><br><span class="line">        sys.exit()</span><br><span class="line">print(&apos;Who are you?&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-10.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“Python &amp; Ruby”, 생활코딩, 2019. 1. 28, <a href="https://opentutorials.org/course/1750/9621" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9621</a>, <a href="https://opentutorials.org/course/1750/9874" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9874</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/28/python6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 연속 행렬 곱셈 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/28/algo20/</link>
      <guid>http://dudri63.github.io/2019/01/28/algo20/</guid>
      <pubDate>Mon, 28 Jan 2019 07:59:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 연속 행렬 곱셉 (Chained Matrix Multiplications)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a na
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 연속 행렬 곱셉 (Chained Matrix Multiplications)</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 연속 행렬 곱셉 (Chained Matrix Multiplications)</a></p><p><strong>연속 행렬 곱셉 (Chained Matrix Multiplications)</strong> 문제는 연속된 행렬들의 곱셉에 필요한 원소 간의 최소 곱셉 횟수를 찾는 문제이다.</p><div align="center"><br><img src="/image/algo20-1.png"><br></div><p>예를 들어, 위와 같은 두 개의 행렬을 곱하는 경우, 10*20 행렬 A와 20*5 행렬 B를 곱하는데 원소간의 곱셈 횟수는 10*20*5 = 1000이다. 그리고 두 행렬을 곱한 결과 행렬 C는 10*5이다.</p><div align="center"><br><img src="/image/algo20-2.png"><br></div><p>또 다른 예시로, 세 개의 행렬을 곱하는 경우를 고려한다.<br>행렬의 곱셈에서는 결합법칙이 허용됨을 기억한다. A*B*C = (A*B)*C = A*(B*C)</p><div align="center"><br><img src="/image/algo20-3.png"><br></div><p>A*B를 먼저 계산한 후에 그 결과 행렬과 행렬 C를 곱하는 경우, 곱셈 횟수는 다음과 같다.<br>A*B = 10*20*5 = 1000, AB*C = 10*5*15 = 750<br>총 1000 + 750 = 1750회의 원소의 곱셈이 필요하다.</p><div align="center"><br><img src="/image/algo20-4.png"><br></div><p>B*C를 먼저 계산한 후에 그 결과 행렬과 행렬 A를 곱하는 경우, 곱셈 횟수는 다음과 같다.<br>B*C = 20*5*15 = 1500, A*BC = 10*20*15 = 3000<br>총 1500 + 3000 = 4500회의 원소의 곱셈이 필요하다.</p><p>동일한 결과를 얻음에도 불구하고 원소 간의 곱셈 횟수가 차이가 난다. 따라서 연속 행렬을 곱하는 데 필요한 원소 간의 곱셈 횟수를 최소화시키기 위한 적절한 곱셈 순서를 찾아야 한다.</p><p>연속 행렬 곱셈 문제는 대표적인 동적 계획 알고리즘 문제이다.<br>단, 이웃하는 행렬끼리 먼저 곱해야 하는 특징 때문에 비교적 간단하게 해결할 수 있다.</p><p>행렬 A, B, C, D, E를 곱하는데 다음과 같은 부분 문제가 만들어진다.</p><div align="center"><br><img src="/image/algo20-5.png"><br></div><p><strong>부분 문제들이 겹쳐있다는 것</strong>이 중요하다.</p><div align="center"><br><img src="/image/algo20-6.png"><br></div><p>크기가 3인 부분문제가 3인 경우도 서로 이웃하는 부분문제들끼리 겹쳐 있음을 알 수 있다. 마지막 부분문제의 갯수가 1개인 경우는 주어진 문제로서 입력이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 연속 행렬 곱셈을 위한 동적 계획 알고리즘이다.<br>단, 원소 간의 최소 곱셈 횟수를 C[i,j]에 저장한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MatrixChain</span><br><span class="line">입력: 연속된 행렬 A1\*A2\*...\*An,</span><br><span class="line">출력: 입력의 행렬 곱셈에 필요한 원소 간의 최소 곱셈 횟수</span><br><span class="line">for i = 1 to n</span><br><span class="line">  C[i,i] = 0</span><br><span class="line">for L = 1 to n-1 &#123;//L은 부분문제의 크기를 조절하는 인덱스</span><br><span class="line">  for i = 1 to n-L &#123;</span><br><span class="line">    j = i + L</span><br><span class="line">    C[i,j] = ∞</span><br><span class="line">    for k = i to j-1 &#123;</span><br><span class="line">      temp = C[i,k] + C[k+1,j] + d(i-1)dkdj</span><br><span class="line">      if (temp &lt; C[i,j])</span><br><span class="line">        C[i,j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return C[1,n]</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/algo20-7.png"><br></div><p>A1 : 10*20, A2 : 20*5, A3 : 5*15, A4 : 15*30일 때, MatrixChain 알고리즘 수행 과정은 다음과 같다.</p><ul><li>Line 4~5 : C[1,1] = C[2,2] = C[3,3], C[4,4] = 0으로 초기화</li></ul><div align="center"><br><img src="/image/algo20-8.png"><br><br></div><ul><li>Line 6 : L이 1부터 n-1 = 4-1 = 3까지 변하고, 각각의 L값에 대해, i가 변화, C[i,j]를 계산</li><li>L = 1일 때, i는 1부터 n-L = 4-1 = 3까지 변한다.<ul><li>i = 1이면, j = i+L = 1+1 = 2, C[1,2] = ∞,<br>temp = C[1,1] + C[2,2] + d<sub>0</sub>d<sub>1</sub>d<sub>2</sub> = 0 + 0 + (10*20*5) = 1000<br>temp = 1000 &lt; C[1,2] = ∞, C[1,2] = 1000</li><li>i = 2이면, j = i+L = 2+1 = 3, C[2,3] = ∞<br>temp = C[2,2] + C[3,3] + d<sub>1</sub>d<sub>2</sub>d<sub>3</sub> = 0 + 0 + (20*5*15) = 1500<br>temp = 1500 &lt; C[2,3] = ∞, C[2,3] = 1500</li><li>i = 3이면, j = i+L = 3+1 = 4, C[3,4] = ∞<br>temp = C[3,3] + C[4,4] + d<sub>2</sub>d<sub>3</sub>d<sub>4</sub> = 0 + 0 + (5*15*30) = 2250<br>temp = 2250 &lt; C[3,4] = ∞, C[3,4] = 2250</li></ul></li></ul><div align="center"><br><img src="/image/algo20-9.png"><br>A1 * A2 = 1000, A2 * A3 = 1500, A3 * A4 = 2250<br><br></div><ul><li><p>L = 2일 때, i는 1부터 n-L = 4-2 = 2까지 변한다.</p><ul><li><p>i = 1이면, j = i+L = 1+2 = 3, C[1,3] = ∞</p><ul><li><p>k = 1일 때, temp = C[1,1] + C[2,3] + d<sub>0</sub>d<sub>1</sub>d<sub>3</sub> = 0 + 1500 + (10*20*15) = 4500<br>temp = 4500 &lt; C[1,3] = ∞, C[1,3] = 4500<br><img src="/image/algo20-10.png"><br>A2*A3 = 1500, A1*A2A3 = 3000 + 1500</p></li><li><p>k = 2일 때, temp = C[1,2] + C[3,3] + d<sub>0</sub>d<sub>2</sub>d<sub>3</sub> = 1000 + 0 + (10*5*15) = 1750<br>temp = 1750 &lt; C[1,3] = 4500, C[1,3] 1750<br><img src="/image/algo20-11.png"><br>A1*A2 = 1000, A1A2*A3 = 1000 + 750</p></li></ul></li><li><p>i =2이면, j = i+L = 2+2 = 4, C[2,4] = ∞</p><ul><li><p>k = 2일 때, temp = C[2,2] + C[3,4] + d<sub>1</sub>d<sub>2</sub>d<sub>4</sub> = 0 + 2250 + (20*5*30) = 5250<br>temp = 5250 &lt; C[2,4] = ∞, C[2,4] = 5250<br><img src="/image/algo20-12.png"><br>A3*A4 = 2250, A2*A3A4 = 3000 + 2250</p></li><li><p>k = 3일 때, temp = C[2,3] + C[4,4] + d<sub>1</sub>d<sub>3</sub>d<sub>4</sub> = 1500 + 0 + (20*15*30) = 10500<br>temp = 10500 &gt; C[2,4] = 2250, C[2,4] = 5250<br><img src="/image/algo20-13.png"><br>A2*A3 = 1500, A2A3*A4 = 9000 + 1500</p></li></ul></li></ul></li></ul><div align="center"><br><img src="/image/algo20-14.png"><br><br></div><ul><li><p>L = 3일 때, i는 1부터 n-L = 4-3 = 1까지 변한다.(i=1일때만 수행)</p><ul><li><p>i = 1이면, j = i+L = 1+3 = 4, C[1,4] = ∞</p><ul><li><p>k = 1일 때, temp = C[1,1] + C[2,4] = d<sub>0</sub>d<sub>1</sub>d<sub>4</sub> = 0 + 5250 + (10*20*30) = 11250<br>temp = 11250 &lt; C[1,4] = ∞, C[1,4] = 11250<br><img src="/image/algo20-15.png"><br>A2*A3*A4 = 5250, A1*A2A3A4 = 6000</p></li><li><p>k = 2일 때, temp = C[1,2] + C[3,4] = d<sub>0</sub>d<sub>2</sub>d<sub>4</sub> = 1000 + 2250 + (10*5*30) = 4750<br>temp = 4750 &lt; C[1,4] = ∞, C[1,4] = 4750<br><img src="/image/algo20-16.png"><br>A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1000 + 1500 + 2250 = 4750</p></li><li><p>k = 3일 때, temp = C[1,3] + C[4,4] = d<sub>0</sub>d<sub>3</sub>d<sub>4</sub> = 1750 + 0 + (10*15*30) = 6250<br>temp = 6250 &gt; C[1,4] = 4750, C[1,4] = 4750<br><img src="/image/algo20-17.png"><br>A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1750 + 4500 = 6250</p></li></ul></li></ul></li></ul><div align="center"><br><img src="/image/algo20-18.png"><br><br></div><ul><li>C[1,4]= 4750을 반환</li></ul><hr><p><a name="3">3. 시간복잡도 </a></p><p>3중 for문 -&gt; O(n<sup>3</sup>)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/28/algo20/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 컨테이너, 리스트</title>
      <link>http://dudri63.github.io/2019/01/27/python5/</link>
      <guid>http://dudri63.github.io/2019/01/27/python5/</guid>
      <pubDate>Sun, 27 Jan 2019 10:12:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 컨테이너&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 리스트&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 컨테이너&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;변수는 컨테이너와 비슷하다.&lt;/p&gt;
&lt;p&gt;ex. name = ‘seo’ 와 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 컨테이너</a><br><a href="#2">2. 리스트</a></p><hr><p><a name="1">1. 컨테이너</a></p><p>변수는 컨테이너와 비슷하다.</p><p>ex. name = ‘seo’ 와 같이 값을 대입할 수 있다.<br>위 예에서 볼 수 있듯이 변수는 ‘하나의 값을 담는 그릇’과 같다.</p><p>하나의 그릇에 여러 개의 값을 담을 수는 없을까?<br>-&gt; <strong>컨테이너</strong>라는 것을 만들어서 각각의 값을 담을 수 있다.</p><div align="center"><br><img src="/image/py5-1.png"><br></div><p>위 그림은 컨테이너의 개념을 파악하는 데 유용하다.<br>하나의 그릇에 세 개의 값(‘Egoing’, ‘Leezche’, ‘Graphittie’)을 담았다. 또한, 그릇데 담긴 값들은 각각 0, 1, 2라는 번호가 부여된다.<br>또한, 컨테이너를 다시 변수에 담을 수 있다. 그리하여 변수의 이름을 통해 컨테이너에 접근할 수 있다.</p><p>컨테이너란 포괄적인 개념이며, 파이썬에서는 보통 <strong>‘리스트(list)’</strong>로 지칭한다.</p><hr><p><a name="2">2. 리스트</a></p><p><strong>리스트</strong>란 “0개 이상의 값의 원소들의 순서있는 집합”이다. 즉, 일종의 집합이나 컨테이너의 형태로 그 내부에 여러 개의 값을 원소로 가질 수 있으며 다른 언어에서는 배열 혹은 벡터로 불리는 타입과 비슷하다.<br>리스트는 순서있는 집합이므로 각 원소는 리스트 내부에서 고유한 순서를 가지고 있는데, 이 순서를 인덱스라고 한다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(type(&apos;egoing&apos;))# &apos;egoing&apos;의 타입(stirng)을 출력</span><br><span class="line">name = &apos;egoing&apos;</span><br><span class="line">print(name) # 변수 name에 담긴 것을 출력</span><br><span class="line">print(type([&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;])) # [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]의 타입(list)을 출력</span><br><span class="line">names = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;] # 변수 name에 list를 담음</span><br><span class="line">print(names) </span><br><span class="line">print(names[2]) # 변수 name의 2번을 출력</span><br><span class="line">egoing = [&apos;programmer&apos;, &apos;seoul&apos;, 25, False] # list 생성 및 변수 name에 담음</span><br><span class="line">egoing[1] = &apos;busan&apos;# egoing의 1번을 변경</span><br><span class="line">print(egoing) # [&apos;programmer&apos;, &apos;busan&apos;, 25, False]</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py5-2.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">al = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;]# list al 생성</span><br><span class="line">print(len(al)) # al의 전체 요소 개수를 반환</span><br><span class="line">al.append(&apos;E&apos;)# al list에 &apos;E&apos;를 추가</span><br><span class="line">print(al) # [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]</span><br><span class="line">del(al[0]) # al list의 0번을 제거</span><br><span class="line">print(al) # [&apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;]</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py5-3.png"><br></div><p>len() : 입력값의 길이 또는 요소의 전체 개수를 반환하는 함수.<br>append() : 리스트에 요소를 추가하는 함수.<br>del() : 리스트의 요소를 삭제하는 함수.<br>ex. del a[1] : a list의 1번을 삭제<br>    del a[1:] : a list의 1번부터 삭제(여러개의 요소를 한꺼번에 삭제)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>(연재) 파이썬은 처음이라 - 리스트는 처음이라, Wireframe-숩은 아직 20대, 2019. 1 .27, <a href="https://soooprmx.com/archives/8824" rel="external nofollow noopener noreferrer" target="_blank">https://soooprmx.com/archives/8824</a></li><li>“Python &amp; Ruby”, 생활코딩, 2019. 1. 27, <a href="https://opentutorials.org/course/1750/9681" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9681</a>, <a href="https://opentutorials.org/course/1750/9619" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9619</a>, <a href="https://opentutorials.org/course/1750/9626" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9626</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/27/python5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 모든 쌍 최단 경로 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/27/algo19/</link>
      <guid>http://dudri63.github.io/2019/01/27/algo19/</guid>
      <pubDate>Sat, 26 Jan 2019 16:04:54 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 모든 쌍 최단 경로 (All Pairs Shortest Paths)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 플로이드-워셜(Floyd-Warshall) 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 모든 쌍 최단 경로 (All Pairs Shortest Paths)</a><br><a href="#2">2. 플로이드-워셜(Floyd-Warshall) 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 모든 쌍 최단 경로(All Pairs Shortest Paths)</a></p><p><strong>모든 쌍 최단 경로(All Pairs Shortest Paths)</strong> 문제는 각 쌍의 점 사이의 최단 경로를 찾는 문제이다.<br>이 문제를 해결하려면, 각 점을 시작점으로 다익스트라 알고리즘을 수행하면 된다.<br>이 때, 시간 복잡도는 (n-1)*O(n<sup>2</sup>) = O(n<sup>3</sup>)이다.</p><p>모든 쌍 최단 경로를 찾는 동적 계획 알고리즘을 <strong>플로이드-워셜(Floyd-Warshall) 알고리즘</strong>이라고 한다.(이하, 플로이도 알고리즘)<br>플로이드 알고리즘의 시간복잡도는 O(n<sup>3</sup>)으로 다익스트라 알고리즘을 (n-1)번 사용할 때의 시간복잡도와 동일하다.<br>그러나 플로이드 알고리즘은 매우 간단하다는 장점이 있다.</p><p>동적 계획 알고리즘으로 모든 쌍 최단 경로 문제를 해결하려면 먼저 부분문제들을 찾아야 한다.</p><div align="center"><br><img src="/image/algo19-1.png"><br></div><p>그래프에 3개의 점이 있는 경우,<br>점 i에서 점 j까지의 최단 경로를 찾으려면 2가지 경로, 점 j로 직접 가능 경로와 1을 경유하는 경로 중에서 짧은 것을 선택.</p><p>다른 아이디어는 경유 가능한 점들을 점 1로부터 시작하여, 점 1과 2, 그 다음에는 점 1,2,3으로 하나씩 추가, 마지막에는 점 1에서 점 n까지의 모든 점을 경유 가능한 점들로 고려, 모든 쌍의 최단 경로의 거리를 계산하는 것이다.</p><p>위 아이디어를 이용하면 부분문제들을 만들 수 있다.</p><p>D<sub>ij</sub><sup>k</sup> = 점 {1,2,…,k}만을 경유하는 점들로 고려, 점 i로부터 점 j까지의 모든 경로 중에서 가장 짧은 경로의 거리<br>(단, 점 1에서 k까지의 모든 점들을 반드시 경유하는 경로를 의미하는 것은 아님)</p><div align="center"><br><img src="/image/algo19-2.png"><br></div><ul><li>D<sub>ij</sub><sup>1</sup>은 i에서 점 1을 경유하여 j로 가는 경로, i에서 j로 직접 가는 경로, 즉 선분 (i,j) 중에서 짧은 거리이다. <strong>단, i≠1, j≠1</strong></li></ul><div align="center"><br><img src="/image/algo19-3.png"><br></div><ul><li>i에서 점 2를 경유하여 j로 가는 경로의 거리와 D<sub>ij</sub><sup>1</sup> 중에서 짧은 거리를 D<sub>ij</sub><sup>2</sup>로 정한다. 단, 점 2를 경유하는 경로의 거리는 D<sub>i2</sub><sup>1</sup> + D<sub>2j</sub><sup>1</sup> 이다. <strong>단, i≠2, j≠2</strong></li></ul><p>…</p><div align="center"><br><img src="/image/algo19-4.png"><br></div><ul><li>i에서 점 k를 경유하여 j로 가는 경로의 거리와 D<sub>ij</sub><sup>k-1</sup> 중에서 짧은 것을 D<sub>ij</sub><sup>k</sup>로 정한다. 단, 점 k를 경유하는 경로의 거리는 D<sub>ik</sub><sup>k-1</sup>+D<sub>kj</sub><sup>k-1</sup>이다. <strong>단, i≠k, j≠k</strong></li></ul><p>이런 방식으로 k가 1에서 n이 될 때까지 D<sub>ij</sub><sup>k</sup>를 계산해서 모든 점을 경유 가능한 점들로 고려된 모든 쌍 i와 j의 최단 경로의 거리를 찾는 방식이 플로이드의 모든 쌍 최단 경로 알고리즘이다.</p><hr><p><a name="2">2. 플로이드 알고리즘 </a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AllPairsShortest</span><br><span class="line">입력: 2차원 배열 D, 단, D[i,j] = 선분 (i,j)의 가중치, 만일 선분 (i,j)이 존재하지 않으면 D[i,j] = ∞, 모든 i에 대해 D[i,j]=0이다.</span><br><span class="line">출력: 모든 쌍 최단 경로의 거리를 저장한 2차원 배열 D</span><br><span class="line">for k = 1 to n</span><br><span class="line">  for i = 1 to n (단, i≠k)</span><br><span class="line">    for j = 1 to n (단, j≠k, j≠i)</span><br><span class="line">      D[i,j] = min&#123;D[i,k]+D[k,j],D[i,j]&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/algo19-5.png"><br></div><p>배열 D의 원소들이 k가 1부터 5까지 증가함에 따라서 갱신되는 것을 살펴본다.</p><ul><li><p>k = 1일 때 :</p><ul><li>D[2,3] = min{D[2,1]+D[1,3], D[2,3]} = min{∞+2,1} = 1</li><li>D[2,4] = min{D[2,1]+D[1,4], D[2,4]} = min{∞+5,∞} = ∞</li><li>D[2,5] = min{D[2,1]+D[1,5], D[2,5]} = min{4,∞+∞} = 4</li><li>D[3,2] = min{D[3,1]+D[1,2], D[3,2]} = min{1+4,3} = 3</li><li>D[3,4] = min{D[3,1]+D[1,4], D[3,4]} = min{1+5,1} = 1</li><li>D[3,5] = min{D[3,1]+D[1,5], D[3,5]} = min{1+∞,2} = 2</li><li>D[4,2] = min{D[4,1]+D[1,2], D[4,2]} = min{-2+4,∞} = 2 // 갱신됨 (∞-&gt;2)</li><li>D[4,3] = min{D[4,1]+D[1,3], D[4,3]} = min{-2+2,∞} = 0 // 갱신됨 (∞-&gt;0)</li><li>D[4,5] = min{D[4,1]+D[1,5], D[4,5]} = min{-2+∞,2} = 2</li><li>D[5,2] = min{D[5,1]+D[1,2], D[5,2]} = min{∞+4,-3} = -3</li><li>D[5,3] = min{D[5,1]+D[1,3], D[5,3]} = min{∞+2,3} = 3</li><li>D[5,4] = min{D[5,1]+D[1,4], D[5,4]} = min{∞+5,1} = 1</li></ul><p>즉, 모든 i,j에 대한 D<sub>ij</sub><sup>1</sup>을 계산한 결과는 다음과 같다.</p></li></ul><div align="center"><br><img src="/image/algo19-6.png"><br></div><ul><li><p>k = 2일 때 :</p><ul><li>(계산 과정 생략)</li></ul><p>모든 i,j에 대한 D<sub>ij</sub><sup>2</sup>을 계산한 결과는 다음과 같다.</p></li></ul><div align="center"><br><img src="/image/algo19-7.png"><br></div><ul><li><p>k = 3일 때 :</p><ul><li>(계산 과정 생략)</li></ul><p>모든 i,j에 대한 D<sub>ij</sub><sup>3</sup>을 계산한 결과는 다음과 같다.</p></li></ul><div align="center"><br><img src="/image/algo19-8.png"><br></div><ul><li><p>k = 4일 때 :</p><ul><li>(계산 과정 생략)</li></ul><p>모든 i,j에 대한 D<sub>ij</sub><sup>4</sup>를 계산한 결과는 다음과 같다.</p></li></ul><div align="center"><br><img src="/image/algo19-9.png"><br></div><ul><li><p>k = 5일 때 :</p><ul><li>(계산 과정 생략)</li></ul><p>모든 i,j에 대한 D<sub>ij</sub><sup>5</sup>를 계산한 결과는 다음과 같다.</p></li></ul><div align="center"><br><img src="/image/algo19-10.png"><br>(최종 해)<br></div><hr><p><a name="3">3. 시간 복잡도</a></p><p>3중 for문 -&gt; O(n<sup>3</sup>)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/27/algo19/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 동적 계획 알고리즘</title>
      <link>http://dudri63.github.io/2019/01/26/algo18/</link>
      <guid>http://dudri63.github.io/2019/01/26/algo18/</guid>
      <pubDate>Sat, 26 Jan 2019 11:02:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;‘동적 계획(Dynamic Programming)’&lt;/strong&gt; 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 동적 계획 알고리즘은 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>‘동적 계획(Dynamic Programming)’</strong> 알고리즘은 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다. 동적 계획 알고리즘은 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.</p><div align="center"><br><img src="/image/algo18-1.png"><br></div><p>단, 분할 정복 알고리즘과는 달리 부분문제의 해를 중복 사용하기도 한다.</p><p>동적계획 알고리즘에는 부분문제들 사이에 의존적 관계가 존재한다. 이러한 관계는 문제 또는 알고리즘에 따라 다르고, 대부분의 경우 뚜렷이 보이지 않아서 <strong>‘함축적인 순서(implicit order)’</strong>라고 한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/26/algo18/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 허프만 압축 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/25/algo17/</link>
      <guid>http://dudri63.github.io/2019/01/25/algo17/</guid>
      <pubDate>Fri, 25 Jan 2019 14:02:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 허프만 압축&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 허프만 압축&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;파일의 각 문
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 허프만 압축</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 허프만 압축</a></p><p>파일의 각 문자가 8bit 아스키(ASCII) 코드로 저장되면, 그 파일의 bit 수는 8 * (파일의 문자수)이다.<br>즉, 파일의 각 문자는 고정된 크기의 코드로 표현된다.<br>이러한 고정된 크기의 코드로 구성된 파일을 저장하거나 전송할 때 파일의 크기를 줄이고, 필요시 원래의 파일로 변환할 수 있으면,<br>메모리 공간을 효율적으로 사용할 수 있고, 파일 전송 시간을 단축시킬 수 있다.<br>주어진 파일의 크기를 줄이는 방법을 <strong>파일 압축(file compression)</strong>이라고 한다.</p><p><strong>허프만(Huffman) 압축</strong>은 파일에 빈번히 나타나는 문자에는 짧은 이진 코드를 할당, 드물게 나타나는 문자에는 긴 이진 코드를 할당한다.</p><p>허프만 압축 방법으로 변환시킨 문자 코드들 사이에는 접두부 특성(Prefix Property)이 존재한다.<br>이는 각 문자에 할당된 이진 코드는 어떤 다른 문자에 할당된 이진 코드의 접두부가 되지 않는다는 것을 의미.<br>즉, 문자 ‘a’에 할당된 코드가 ‘101’이라면, 다른 모든 문자의 코드는 ‘101’로 시작되지 않으며 또한 ‘1’이나 ‘10’으로도 시작되지 않는다.<br>접두부 특성을 가진 코드의 장점은 코드와 코드 사이를 구분할 특별한 코드가 필요 없다는 것이다.<br>예를 들어. 101#100#0#111#…에서 ‘#’이 인접한 코드를 구분 짓는데, 허프만 압축에서는 이러한 특별한 코드가 필요 없이 파일을 압축 및 해제할 수 있다.</p><p>허프만 압축은 입력 파일에 대해 각 문자의 출현 빈도수에 기반을 둔 이진트리를 만든 뒤, 각 문자에 이진 코드를 할당한다. 이 때, 이 이진 코드를 <strong>허프만 코드</strong>라고 한다.</p><hr><p><a name="2">2. 알고리즘 </a></p><p>다음은 파일 압축을 위한 허프만 코드를 찾기 위한 그리디 알고리즘이다.<br>입력 파일에 대해 각 문자에 할당될 이진 코드를 추출할 이진 트리인 <strong>허프만 트리</strong>를 리턴한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HuffmanCoding</span><br><span class="line">입력: 입력 파일의 n개의 문자에 대한 각각의 빈도수</span><br><span class="line">출력: 허프만 트리</span><br><span class="line">각 문자에 대해 노드를 만들고, 그 문자의 빈도수를 노드에 저장한다.</span><br><span class="line">n개의 노드들의 빈도수에 대해 우선순위 큐 Q를 만든다.</span><br><span class="line">while (Q에 있는 노드 수 &gt;=2) &#123;</span><br><span class="line">  빈도수가 가장 작은 2개의 노드(A와 B)를 Q에서 제거한다.</span><br><span class="line">  새 노드 N을 만들고, A와 B를 N의 자식 노드로 만든다.</span><br><span class="line">  노드 N을 Q에 삽입한다.</span><br><span class="line">&#125;</span><br><span class="line">return Q// 허프만 트리의 루트를 리턴하는 것이다.</span><br></pre></td></tr></table></figure></p><p>입력 파일이 4개의 문자로 구성되어 있고, 각 문자의 빈도수는 다음과 같다고 가정한다.</p><p>A: 450     T: 90    G:120    C:270</p><ul><li><p>Line 5 : 4개의 문자들의 빈도수에 대해 우선순위 Q를 만든다. </p><div align="center"><br><img src="/image/algo17-1.png"><br></div></li><li><p>Line 6 : while-루프 조건이 ‘참’이므로, Line 7~10을 수행한다.<br>즉, Q에서 ‘T’와 ‘G’를 제거한 후, 새 부모 노드를 Q에 삽입한다.</p><div align="center"><br><img src="/image/algo17-2.png"><br></div></li><li><p>Line 6 : while-루프 조건 ‘참’, Line 7~10을 수행.<br>즉, Q에서 ‘T’와 ‘G’의 ‘부모 노드’와 ‘C’를 제거한 후, 새 부모 노드를 Q에 삽입한다.</p><div align="center"><br><img src="/image/algo17-3.png"><br></div></li><li><p>Line 6 : while-루프 조건 ‘참’, Line 7~10을 수행.<br>즉, Q에서 ‘c’의 ‘부모 노드’와 ‘A’를 제거한 후, 새 부모 노드를 Q에 삽입한다.</p><div align="center"><br><img src="/image/algo17-4.png"><br></div></li><li><p>Line 6 : while-루프 조건 ‘거짓’, Line 11에서 Q에 있는 노드를 리턴.<br>즉, 허프만 트리의 루트가 리턴된다.</p></li></ul><div align="center"><br><img src="/image/algo17-5.png"><br></div><p>반환한 트리를 보면, 문자는 leaf 노드에만 존재한다.<br>루트로부터 왼쪽 자식 노드로 내려가면 ‘0’, 오른쪽 자식 노드로 내려가면 ‘1’을 부여할 수 있다.<br>그리하여 leaf 노드에 도착할 때까지 이진수를 추출, 문자의 이진코드를 구할 수 있다.<br>빈도수가 가장 높은 ‘A’는 가장 짧은 코드인 ‘0’,<br>빈도수가 가장 낮은 ‘T’는 가장 긴 코드인 ‘100’이 부여됐다.<br>또한 이렇게 얻은 숫자에 대한 코드는 접두부 특성을 가지고 있다.<br>(왜냐하면, leaf 노드에만 문자가 있고, 내부 노드에는 문자 없으며 코드를 부여하지 않았기 때문)</p><p>위 예제에서 압축된 파일의 bit 수는 (450*1)+(90*3)+(120*3)+(270*3) = 1620 bit이다.<br>반면에 아스키 코드로 된 파일 크기는 (450+90+120+270)*8 = 7440 bit이다.<br>압축률은 (1620/7440)*100 = 21.8%이다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 4, n개의 노드생성, 각 빈도수를 노드에 저장, O(n)<br>line 5, n개의 노드로 우선순위 큐 Q를 만듬. 힙 자료 구조 사용, O(n)<br>line 6~10, 노드 2개를 Q에서 제거, 새 노드를 Q에 삽입하므로 O(long), while-루프는 (n-1)번 반복, (n-1)*O(logn) = O(nlogn)<br>line 8, 트리의 루트를 리턴, O(1)</p><p>따라서 HuffmanCoding의 알고리즘은 O(nlogn)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 25, <a href="https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/25/algo17/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 작업 스케줄링 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/25/algo16/</link>
      <guid>http://dudri63.github.io/2019/01/25/algo16/</guid>
      <pubDate>Fri, 25 Jan 2019 13:56:10 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 작업 스케줄링&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 작업 스케줄링&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;기계에서 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 작업 스케줄링</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 작업 스케줄링</a></p><p>기계에서 수행되는 n개의 작업 t<sub>1</sub>, t<sub>2</sub>, … t<sub>n</sub>이 있고, 각 작업은 시작시간과 종료시간이 있다.<br><strong>작업 스케줄링(Task Scheduling) </strong>문제는 작업의 수행 시간이 중복되지 않도록 모든 작업을 가장 적은 수의 기계에 배정하는 문제이다.</p><p>작업 스케줄링 문제는 학술대회에서 발표자들을 강의실에 배정하는 문제와 같다.</p><p>작업 스케줄링 문제에 주어진 문제 요소들은 작업의 수, 각 작업의 시작시간과 종료시간이다.<br>작업의 시작시간과 종료시간은 정해져 있으므로 작업의 길이도 주어진 것이다.<br>그리하여 시작시간, 종료시간, 작업 길이에 대해 다음과 같은 그리디 알고리즘들을 생각할 수 있다.</p><ul><li>빠른 시작시간 작업을 우선(Earliest start time first) 배정</li><li>빠른 종료시간 작업을 우선(Earliest finish time first) 배정</li><li>짧은 작업 우선(Shortest job first) 배정</li><li>긴 작업을 우선(Longest job first) 배정</li></ul><p>위 4가지 알고리즘들 중 첫 번째 알고리즘을 제외, 나머지 3가지 알고리즘은 항상 최적해를 찾지 못한다.<br>(추후 공부 필요)</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 작업 스케줄링 문제를 위한 <strong>빠른 시작시간 작업을(Earilest start time first) 우선 배정</strong>하는 그리디 알고리즘이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">JobScheduling</span><br><span class="line">입력: n개의 작업 t1, t2, ... , tn</span><br><span class="line">출력: 각 기계에 배정된 작업 순서</span><br><span class="line">시작시간의 오름차순으로 정렬한 작업 리스트를 L이라고 한다.</span><br><span class="line">while (L ≠ ∅) &#123;</span><br><span class="line">  L에서 가장 이른 시작시간을 가진 작업 ti를 가져온다.</span><br><span class="line">  if (ti를 수행할 기계가 있으면)</span><br><span class="line">    ti를 수행할 수 있는 기계에 배정한다.</span><br><span class="line">  else</span><br><span class="line">    새로운 기계에 ti를 배정한다.</span><br><span class="line">  ti를 L에서 제거한다.</span><br><span class="line">&#125;</span><br><span class="line">return 각 기계에 배정된 작업 순서</span><br></pre></td></tr></table></figure><p>t1 = [7,8],<br>t2 = [3,7],<br>t3 = [1,5],<br>t4 = [5,9],<br>t5 = [0,2],<br>t6 = [6,8],<br>t7 = [1,6]<br>과 같은 작업 이 있다고 가정한다. 단, [s,f]에서 s는 시작시간, f는 종료시간이다.</p><ul><li>Line 4 : L = {[0,2], [1,6], [1,5], [3,7], [5,9], [6,8], [7,8]}이다.</li><li>Line 5~11 : while-루프를 반복 수행하면서 각 작업이 적절한 기계에 배정된다.</li></ul><div align="center"><br><img src="/image/algo16-1.png"><br><img src="/image/algo16-2.png"><br><img src="/image/algo16-3.png"><br></div><p>이 경우 최적해는 3대의 기계에 모든 작업을 마지막 그림과 같이 배정하는 것이다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>Line 4에서 n개의 작업을 정렬하는 데 O(nlogn) 시간이 걸린다.<br>while-루프에서 작업을 L에서 가져다가 수행 가능한 기계를 찾아 배정하므로 O(m)이 걸린다.<br>(m은 사용된 기계의 수)<br>while-루프가 수행된 총 횟수는 n번이므로, line 5~12까지는 O(m)*n = O(mn) 시간이 걸린다.<br>따라서 O(nlogn) + O(nm)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, <a href="https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/25/algo16/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
