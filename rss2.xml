<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Seo&#39;s Blog</title>
    <link>http://dudri63.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 20 Jan 2019 21:05:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Algorithm] 최소 신장 트리 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/21/algo12/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo12/</guid>
      <pubDate>Sun, 20 Jan 2019 20:50:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.최소 신장 트리란&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1.최소 신장 트리란&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;최소 신장 트리(Minimum Spanning Tree)&lt;/strong&gt;란 주어진 가중치 그래프
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1.최소 신장 트리란</a></p><hr><p><a name="1">1.최소 신장 트리란</a></p><p><strong>최소 신장 트리(Minimum Spanning Tree)</strong>란 주어진 가중치 그래프에서 사이클 없이 모든 점들을 연결시키 트리들 중 선분들의 가중치 합이 최소인 트리이다.</p><div align="center"><br><img src="/image/algo12-1.png" width="700" height="500"><br></div><p>위 경우에서 (a)를 주어진 가중치 그래프라고 가정한다.<br>(점들끼리 연결된 선분들마다 가중치(숫자)가 다른 그래프이다.)</p><ul><li>(b) 최소 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 이러한 종류의 트리들 중 가중치의 합이 최소임.</li><li>(c) 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 단, 이러한 종류의 트리들 중 가중치의 합이 최소는 아님.</li><li>(d) 부분그래프 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시키지 못함.</li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>*</p>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 동전 거스름돈 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/21/algo11/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo11/</guid>
      <pubDate>Sun, 20 Jan 2019 19:59:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 동전 거스름돈 문제란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 동전 거스름돈 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 동전 거스름돈 문제란&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;거스름돈을 동전으로 받아야 할 때,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 동전 거스름돈 문제란</a><br><a href="#2">2. 동전 거스름돈 알고리즘</a></p><hr><p><a name="1">1. 동전 거스름돈 문제란</a></p><p>거스름돈을 동전으로 받아야 할 때, 누구나 적은 수의 동전을 거스름돈으로 받기를 원한다고 가정한다.<br>동전 거스름돈 문제를 해결하는 가장 간단하고 효율적인 방법은 남은 액수를 초과하지 않는 조건하에 ‘욕심내어’ 가장 큰 액면의 동전을 취하는 것이다.</p><hr><p><a name="2">2. 동전 거스름돈 알고리즘</a></p><p>다음은 동전 거스름돈 문제의 최소 동전 수를 찾는 그리디 알고리즘이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CoinChange(W)</span><br><span class="line">입력: 거스름돈 액수 W</span><br><span class="line">출력: 거스름돈 액수에 대한 최소 동전 수</span><br><span class="line">change=W, n500=n100=n50=n10=n1//n500, n100, n50, n10, n1은 각각의 동전수를 위한 변수</span><br><span class="line">while(change&gt;=500) change=change-500, n500++//500원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=100) change=change-100, n100++//100원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=50)  change=change-50, n50++//50원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=10)  change=change-10, n10++//10원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=1)   change=change-1, n1++//1원짜리 동전수를 증가</span><br><span class="line">return (n500+n100+n50+n10+n1)//총 동전수를 반환</span><br></pre></td></tr></table></figure><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 그리디 알고리즘</title>
      <link>http://dudri63.github.io/2019/01/21/algo10/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo10/</guid>
      <pubDate>Sun, 20 Jan 2019 19:49:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;그리디(Greedy) 알고리즘&lt;/strong&gt;은 최적화 문제를 해결하는 알고리즘이다. &lt;strong&gt;최적화(Optimization)&lt;/strong&gt; 문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>그리디(Greedy) 알고리즘</strong>은 최적화 문제를 해결하는 알고리즘이다. <strong>최적화(Optimization)</strong> 문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.</p><p>그리디 알고리즘은 입력 데이터 간의 관계를 고려하지 않고 수행 과정에서 최솟값 또는 최댓값을 가진 데이터를 선택한다. 이러한 선택을 ‘근시안적’인 선택이라고도 하는데, 그리디 알고리즘은 근시안적인 선택으로 부분적인 최적해를 찾고, 이들을 모아서 문제의 최적해를 얻는다.</p><p>또한, 그리디 알고리즘은 일단 한번 선택하면, 이를 절대로 번복하지 않는다.</p><p>위와 같은 그리디 알고리즘의 특징들 때문에 그리디 알고리즘은 매우 단순하며 제한적인 문제들만이 그리디 알고리즘으로 해결이 가능하다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 주의할 점 (분할정복)</title>
      <link>http://dudri63.github.io/2019/01/21/algo9/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo9/</guid>
      <pubDate>Sun, 20 Jan 2019 19:33:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;분할 정복은 분활된 부분문제의 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우 사용기하게 부적절하다.&lt;br&gt;예를 들어, 피보나치 수를 구할 때, F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 한다고 가정한다. 그러나
        
      
      </description>
      
      <content:encoded><![CDATA[<p>분할 정복은 분활된 부분문제의 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우 사용기하게 부적절하다.<br>예를 들어, 피보나치 수를 구할 때, F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 한다고 가정한다. 그러나 이 경우는 n이라는 숫자로 인해 2개의 부분문제인 F(n-1), F(n-2)이 만들어지고, 입력의 크기의 합이 (n-1) + (n-2)가 되어 분할 후 입력의 총 크기가 거의 2배가 된다.</p><p><div align="center"><br><img src="/image/algo9-1.png" width="400" height="500"><br></div><br>위와 같이 6의 피보나치 수를 구할 때, 분할 정복을 사용하면, 중복되는 부분문제들이 생겨서 오히려 총 소요 시간이 증가함을 알 수 있다.</p><p>피보나치 수와 같은 경우에는 분할 정복(재귀 호출)을 사용하지 않고, for-루프를 사용하는 것이 더욱 효율적이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FiboNumber(n)</span><br><span class="line">F[0]=0</span><br><span class="line">F[1]=1</span><br><span class="line">for i=2 to n</span><br><span class="line">  F[i] = F[i-1] + F[i-2]</span><br></pre></td></tr></table></figure></p><p>위와 같은 알고리즘을 사용하면, 루프의 수행 횟수로서 시간복잡도가 O(n)이 된다.</p><p>주어진 문제를 분할 정복 알고리즘으로 해결하려고 하라 때 중의해야 하는 점 중 다른 하나는 취합 과정이다. 입력을 분할 한다고 해서 효율적인 알고리즘이 만들어지는 것은 아니다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“3장분할정복알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, <a href="https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] 원격 저장소(Remote Repository)</title>
      <link>http://dudri63.github.io/2019/01/21/git10/</link>
      <guid>http://dudri63.github.io/2019/01/21/git10/</guid>
      <pubDate>Sun, 20 Jan 2019 15:34:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 원격 저장소란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;1. 원격 저장소 생성&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 원격 저장소란&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;원격 저장소(Remote Reposito
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 원격 저장소란</a><br><a href="#1">1. 원격 저장소 생성</a></p><hr><p><a name="1">1. 원격 저장소란</a></p><p><strong>원격 저장소(Remote Repository)</strong>란 흔히 <strong>지역 저장소(Local Repository)</strong>와 구별되는 개념이다.</p><p>자신의 컴퓨터에서 작업하고 commit하면 저장되는 곳이 지역 저장소이다. 그런데, 작업물들을 인터넷에 올려서 백업을 하거나 다른 사람들과 협업을 할 경우, 컴퓨터와 연결된 다른 저장소가 필요하다.</p><p>원격 저장소의 역할은 크게 다음과 같다.</p><ul><li>협업</li><li>백업</li></ul><p>일반적으로 원격 저장소는 같은 컴퓨터에 연결되어 있지 않고, 인터넷을 통하여 다른 컴퓨터와 연결되어 있다. 원격 저장소는 프로젝트가 커지는 과정에서 굉장히 중요한 역할을 한다. 그러나 혼자서 프로젝트를 진행할 때에는 원격 저장소가 필요한 일은 많지 않다. 주로, dropbox 등과 같은 서비스를 이용한다.</p><hr><p><a name="2">2. 원격 저장소 생성</a></p><p>앞서 이야기하였듯이, 원격 저장소는 주로 인터넷을 통해 연결, 같은 컴퓨터 안에 있지 않는다. 그러나 원격 저장소 개념을 알기 위하여 본 포스팅에서는 한 대의 컴퓨터, 다른 디렉토리에 원격 저장소를 생성, 원격 저장소에 commit할 것이다.</p><p><img src="/image/git10-1.png" width="700" height="auto"></p><p><img src="/image/git10-2.png" width="700" height="auto"></p><p>위와 같이 gitfth2 디렉토리에 ‘local’이라는 이름의 저장소를 생성한다. 이 후, f1.txt를 add하고 commit한다.<br>(local 이름의 저장소를 지역 저장소라고 가정한다.)</p><p><img src="/image/git10-3.png" width="700" height="auto"></p><p>gitfth2 디렉토리에 또 다른 저장소 ‘remote’를 생성한다.<br>(remote 이름의 저장소를 원격 저장소라고 가정한다.)</p><hr><p>cf.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init --bare &apos;저장소 이름&apos;// 작업이 불가능, 저장만 가능한 저장소를 생성</span><br></pre></td></tr></table></figure></p><p>remote 저장소는 –bare option을 적용하였기 때문에 .git 디렉토리가 내부에 존재하지 않고 위와 같은 파일들이 존재한다.<br>원격 저장소는 일반적으로 작업을 하지 않고, 저장만 하는 경우가 많다.</p><hr><p><img src="/image/git10-4.png" width="700" height="auto"></p><hr><p>cf.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &apos;별명&apos; &apos;경로&apos;// 경로에 있는 디렉토리를 별명으로 설정 및 원격저장소로 연결</span><br><span class="line">$ git remote -v // 연결된 저장소 및 별명을 파악할 수 있음</span><br><span class="line">$ git remote remove &apos;별명&apos;// 연결된 원격원격소를 제거</span><br></pre></td></tr></table></figure></p><p>별명을 설정하는 이유는 항상 경로를 입력하기가 불편하기 때문이다.</p><hr><p>위와 같이 remote 디렉토리를 origin이라는 별명으로 하여 원격저장소로서 연결한다.</p><p><img src="/image/git10-5.png" width="700" height="auto"></p><hr><p>cf.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push // 현재 저장소의 현재 branch를 연결시킨 원격 저장소에 upload</span><br><span class="line">$ git config --global push.default.simple// git의 push 형식을 simple 방식으로 설정</span><br><span class="line">$ git push --set-upstream origin master // 현재 branch를 origin의 master branch로 push</span><br><span class="line">// 또한, 앞으로 git push할 경우 위와 같이 psuh하겠음을 설정</span><br></pre></td></tr></table></figure></p><hr><p><img src="/image/git10-6.png" width="700" height="auto"></p><p><img src="/image/git10-7.png" width="700" height="auto"></p><p>remote 디렉토리에서 확인하면, push가 잘 되었음을 알 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/2708/15395" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15395</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/git10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (4)</title>
      <link>http://dudri63.github.io/2019/01/20/git9/</link>
      <guid>http://dudri63.github.io/2019/01/20/git9/</guid>
      <pubDate>Sun, 20 Jan 2019 14:23:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git branch -d, -D&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Branch 병합 시 충돌 해결&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. $ git branch -d, -D&lt;/a&gt;&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git branch -d, -D</a><br><a href="#2">2. Branch 병합 시 충돌 해결</a></p><hr><p><a name="1">1. $ git branch -d, -D</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &apos;branch name&apos; // 해당 branch를 제거</span><br><span class="line">$ git branch -D &apos;branch name&apos;// 강제로 해당 branch를 제거</span><br></pre></td></tr></table></figure><hr><p><a name="2">2. Branch 병합 시 충돌 해결</a></p><p>2.1 충돌이 일어나지 않는 경우</p><p><img src="/image/git9-1.png" width="700" height="auto"></p><p>위와 같이 master, exp branch가 있고, 각각의 branch에서 master.txt, exp.txt가 commit된 상태임을 가정한다.</p><p><img src="/image/git9-2.png" width="700" height="auto"></p><p><img src="/image/git9-3.png" width="700" height="auto"></p><p><img src="/image/git9-4.png" width="700" height="auto"></p><p><img src="/image/git9-5.png" width="700" height="auto"></p><p>master branch에서 $ git merge exp 명령어를 실행하면, master branch에서 exp branch를 병합하는 새로운 commit이 생성된 것을 확인할 수 있다. 또한, ls -al 명령을 실행하면, 새로 생긴 commit은 master.txt, exp.txt를 모두 포함하는 것을 확인할 수 있다.<br>이것은 branch 병합시 충돌이 일어나지 않는 경우인데, 병합 시, 공통된 이름의 파일이 존재하지 않았기 깨문에 가능한 것이다.</p><p>다음은 또다른 상황을 가정한다.</p><p><img src="/image/git9-6.png" width="700" height="auto"></p><p><img src="/image/git9-7.png" width="700" height="auto"></p><p>master branch, exp branch에 모두 common.txt가 있는데, 위와 같이 각각의 common.txt의 내용은 다를 경우를 가정한다.<br>(첫 번째 이미지가 master branch의 common.txt, 두 번째 이미지가 exp branch의 common.txt이다.)</p><p><img src="/image/git9-8.png" width="700" height="auto"></p><p><img src="/image/git9-9.png" width="700" height="auto"></p><p>$ git merge master 명령어를 실행하면, 위와 같이 충돌 없이 두 branch가 병합되었음을 알 수 있다. 또한, $ cat 명령어를 이용하여 확인하면, common.txt에 function a, b, c가 모두 포함되어 있음을 확인할 수 있다.<br>서로 다른 branch에 같은 이름의 파일이 존재하고, 각 파일들은 서로 다른 내용을 포함하고 있지만 충돌없이 병합할 수 있는 경우이다.</p><p>2.2 충돌이 일어나는 경우</p><p><img src="/image/git9-10.png" width="700" height="auto"></p><p><img src="/image/git9-11.png" width="700" height="auto"></p><p>위와 같이 master branch와 exp branch의 common.txt라는 같은 이름의 파일이 존재하지만, 그 내용이 각각 다른 경우를 가정한다.</p><p><img src="/image/git9-12.png" width="700" height="auto"></p><p>master branch에서 $ git merge exp 명령어를 실행하면, Conflict가 발생한다. 구체적으로, $ git status 명령어를 실행하면, common.txt가 서로 다른 branch에서 both modified되었기 때문에 conflict가 발생하여 merge에 실패하였음을 확인할 수 있다.</p><p><img src="/image/git9-13.png" width="700" height="auto"></p><p><img src="/image/git9-14.png" width="700" height="auto"></p><p>common.txt를 텍스트 편집기를 이용하여 불러오면, 위와 같이 텍스트 내용이 변경되었음을 확인할 수 있다.<br>=======를 구분자로 하여 구분자를 중심으로 위 쪽은 현재 checkout한 branch인 master의 충돌 요인, 아래 쪽은 exp의 충돌 요인을 확인할 수 있다.</p><p>2.3 충돌 해결 방법</p><p><img src="/image/git9-15.png" width="700" height="auto"></p><p><img src="/image/git9-16.png" width="700" height="auto"></p><p><img src="/image/git9-17.png" width="700" height="auto"></p><p><img src="/image/git9-18.png" width="700" height="auto"></p><p>위와 같은 상황에서 common.txt를 위와 같이 수정한다.<br>(구분자를 비롯하여 나머지 부분들은 삭제한다.)<br>이 후, common.txt를 add, commit하면 충돌 없이 병합할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15275" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15275</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (3)</title>
      <link>http://dudri63.github.io/2019/01/20/git8/</link>
      <guid>http://dudri63.github.io/2019/01/20/git8/</guid>
      <pubDate>Sun, 20 Jan 2019 13:53:07 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;작업을 분기한 뒤, 각자의 history들을 이어가다가 병합할 필요성이 있을 수 있다.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>작업을 분기한 뒤, 각자의 history들을 이어가다가 병합할 필요성이 있을 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &apos;branch name&apos;</span><br></pre></td></tr></table></figure></p><p>이럴 경우, $ git merge ‘branch name’ 명령어를 실행하면 현재 chekcout되어 있는 branch에서 명령어에 함께 입력한 branch의 버전 정보들을 포함하는 새로운 commit이 생성된다.</p><div align="center"><br><img src="/image/git8-1.png" width="700" height="auto"><br></div><p>현재 저장소에 2 version에서 5 version으로 진행된 master branch, 3,4 version으로 진행된 exp branch가 있다고 가정한다.</p><div align="center"><br><img src="/image/git8-2.png" width="700" height="auto"><br><br><img src="/image/git8-3.png" width="700" height="auto"><br><br><img src="/image/git8-4.png" width="700" height="auto"><br><br><img src="/image/git8-5.png" width="700" height="auto"><br></div><p>master branch에서 $ git merge exp 명령어를 실행하면, commit message를 작성하는 화면이 나온다. 이 때, commit message를 작성 완료한 뒤, $ git log –branches 명령어를 실행하면, master branch에서 각 branch의 최신 commit들을 병합한 새로운 commit이 생성되었음을 확인할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15261" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15261</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (2)</title>
      <link>http://dudri63.github.io/2019/01/20/git7/</link>
      <guid>http://dudri63.github.io/2019/01/20/git7/</guid>
      <pubDate>Sun, 20 Jan 2019 13:05:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git log –branches –decorate&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git log –branches –decorate –graph&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. $ git lo
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git log –branches –decorate</a><br><a href="#2">2. $ git log –branches –decorate –graph</a><br><a href="#3">3. $ git log –branches –decorate –graph –oneline</a><br><a href="#4">4. $ git log ‘branch name a’..’branch name b’</a></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;1&quot;&gt;1. $ git log --branches --decorate&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">$ git log --branches --decorate</span><br></pre></td></tr></table></figure><p>기본적으로 $ git log 명령어는 현재 속해있는 branch의 버전 history만을 출력한다. 그러나 –branches 옵션을 추가로 실행하면, 현재 checkout되어 있는 branch 뿐만 아니라 저장소에 속해있는 모든 branches의 버전 정보들을 출력한다.</p><div align="center"><br><img src="/image/git7-1.png" width="700" height="auto"><br><br><img src="/image/git7-2.png" width="700" height="auto"><br></div><p>master의 최신 commit이 2, exp의 최신 commit이 4, 현재 checkout된 branch는 exp임을 알 수 있다.</p><hr><p><a name="2">2. $ git log –branches –decorate –graph</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --branches --decorate --graph</span><br></pre></td></tr></table></figure><p>–graph 옵션을 추가로 실행하면, 버전이 진행된 것을 도형(선)으로 나타내어 효율적으로 버전 정보들을 파악할 수 있다.</p><div align="center"><br><img src="/image/git7-3.png" width="700" height="auto"><br><br><img src="/image/git7-4.png" width="700" height="auto"><br></div><p>위와 같이 graph가 나타나 효율적으로 버전 histories를 파악할 수 있다. 2 version에서 exp branch는 3,4 version으로 차례대로 변화, master branch는 5 version으로 변화하였음을 알 수 있다.</p><hr><p><a name="3">3. $ git log –branches –decorate –graph –oneline</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --branches --decorate --graph --oneline</span><br></pre></td></tr></table></figure><p>더 간결하게 histories를 graph로 나타낸다.</p><div align="center"><br><img src="/image/git7-5.png" width="700" height="auto"><br></div><hr><p><a name="4">4. $ git log ‘branch name a’..’branch name b’</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log &apos;branch name a&apos;..&apos;branch name b&apos;</span><br></pre></td></tr></table></figure><p>위 명령어는 branch name a에는 없는 branch name b의 commit들을 전시한다.</p><div align="center"><br><img src="/image/git7-6.png" width="700" height="auto"><br></div><p>master branch에는 없는 exp branch들의 commit들을 나타내었다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15261" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15261</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (1)</title>
      <link>http://dudri63.github.io/2019/01/20/git6/</link>
      <guid>http://dudri63.github.io/2019/01/20/git6/</guid>
      <pubDate>Sun, 20 Jan 2019 11:58:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Git을 쓰는 이유&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git branch, $ git checkout ‘branch name’&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Git을 쓰는 이유&lt;/a
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Git을 쓰는 이유</a><br><a href="#2">2. $ git branch, $ git checkout ‘branch name’</a></p><hr><p><a name="1">1. Git을 쓰는 이유</a></p><p>예를 들어, report.xsl file을 버전 관리한다고 가정한다.<br>파일 내용이 변경될 때마다 새로운 이름으로 저장한다. report1.xsl, report2.xsl, ….<br>그런데, 순차적으로 수정이 되다가 경우에 따라서 나뉘어서 수정될 수 있다.<br>고객용으로 수정되면, report2_client.xsl으로 파일 이름을 저장할 수 있다.<br>그리고, 고객용이 아니라 또 다시 내용 변경되면, report3.xsl으로 파일 이름을 저장할 수 있다.<br>이렇게 나뉘어서 버전이 증가하다가, 다시 합쳐지는 경우도 있음.</p><div align="center"><br><img src="/image/git6-1.png" width="700" height="auto"><br></div><p>위와 같이 버전 관리를 할 경우, 파일 이름을 변경해야 하는데, 작업이 분기되거나 합쳐질 경우, 매우 복잡하다.<br><strong>git</strong>을 쓰면 위와 같이 과정을 쉽고, 세련되게 할 수 있다.</p><hr><p><a name="2">2. $ git branch, $ git checkout ‘branch name’</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch// 현재 저장소의 branch들, 현재의 branch</span><br><span class="line">$ git branch &apos;branch name&apos;// 새로운 branch 생성</span><br><span class="line">$ git checkout &apos;branch name&apos;// 해당 branch로 이동</span><br></pre></td></tr></table></figure><p>$ git branch 명령어를 실행하면 현재 저장소의 모든 branch들과 함께 현재 속해 있는 branch가 무엇인지 알 수 있다.<br>$ gir branch ‘branch name’ 명령어를 실행하면 해당 name의 새로운 branch가 생성된다.<br>$ git checkout ‘branch name’ 명령어를 입력하면 해당 branch로 이동한다.</p><div align="center"><br><img src="/image/git6-2.png" width="700" height="auto"><br></div><p>기본적으로 저장소에는 master branch가 존재한다. $ git branch 명령어를 실행하면, master branch가 있음을 알 수 있고, $ git branch exp 명령어를 실행하여 새로운 branch exp를 만든 뒤, $ git checkout exp 명령어를 실행하여 exp branch로 이동하였다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15260" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15260</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Reset, Command</title>
      <link>http://dudri63.github.io/2019/01/20/git5/</link>
      <guid>http://dudri63.github.io/2019/01/20/git5/</guid>
      <pubDate>Sun, 20 Jan 2019 11:25:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git reset&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git commit –help, -a, -m&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. $ git reset&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;버전 관리
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git reset</a><br><a href="#2">2. $ git commit –help, -a, -m</a></p><hr><p><a name="1">1. $ git reset</a></p><p>버전 관리 시스템에서 <strong>과거로 돌아가기</strong>란 commit을 취소하는 것을 의미한다. Git에서 과거로 돌아가는 방법에는 크게 2가지가 있다.</p><ul><li>reset</li><li>revert</li></ul><p>과거로 돌아가는 작업은 상당히 위험한 작업이며, 프로젝트 폴더 전체를 copy한 뒤, 위험한 작업을 실시하는 것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &apos;Commit ID&apos; --hard// Commit ID version이 최신이 됨</span><br><span class="line">$ git revert // Commit을 취소하면서 새로운 버전을 생성</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/git5-1.png" width="700" height="auto"><br><br><img src="/image/git5-2.png" width="700" height="auto"><br></div><p>$ git reset 명령어 뒤에 3 commit ID를 붙여서 실행하였더니, 이 후에 버전들은 삭제되고, 3 commit이 최신 버전이 된 것을 확인할 수 있다.<br>(실제로 이후에 버전들이 삭제된 것은 아니다. Git은 특별한 경우를 제외하고는 버전에 관한 정보들을 삭제하지 않는다.)</p><p>원격 저장소에 협업을 할 경우, 자신의 버전을 공유할 수 있다. 이 때, 공유한 이후에는 reset를 하면 안되고, reset은 local 저장소에서만 사용하도록 한다.</p><hr><p><a name="2">2. $ git commit –help, -a, -m</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --help // commit에 대한 도움말을 볼 수 있다.</span><br><span class="line">$ git commit -a, --all // 수정하거나 삭제한 파일을 자동으로 stage에 올린다.</span><br><span class="line">$ git commit -m, --message// commit message를 바로 쓴다.</span><br></pre></td></tr></table></figure><p>cf.<br>$ git commit -a : 자동으로 변경된 파일을 add시킨다. 그러나 이전에 한번도 add하지 않은 파일에 대해서는 add하지 않는다. 즉, 파일을 생성하면 최초 1회는 $ git add 명령어를 사용하여야 한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15210" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15210</a>, <a href="https://opentutorials.org/course/2708/15211" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15211</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Commit ID, Diff</title>
      <link>http://dudri63.github.io/2019/01/20/git4/</link>
      <guid>http://dudri63.github.io/2019/01/20/git4/</guid>
      <pubDate>Sun, 20 Jan 2019 10:22:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Commit ID&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git diff&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Commit ID&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;각각의 commit들은 고유한 ID가 있다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Commit ID</a><br><a href="#2">2. $ git diff</a></p><hr><p><a name="1">1. Commit ID</a></p><p>각각의 commit들은 고유한 ID가 있다.<br>git log 명령어를 실행하였을 때 나오는 매우 긴 노란쌕 문자열이 고유 ID다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log &apos;commit ID&apos;// 해당 commit을 포함하여 이전의 history들만을 출력</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/git4-1.png" width="700" height="auto"><br></div><p>위와 같이 $ git log 명령어 뒤에 commit ID를 붙이면, 그 commit을 포함하여 이전의 history들만을 화면에 출력한다. </p><hr><p><a name="2">2. $ git diff</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &apos;commit ID A&apos;..&apos;commit ID B&apos;// 두 개의 commit 사이의 차이점 출력</span><br><span class="line">$ gii diff// 마지막 commit으로부터 변경된 점 출력</span><br></pre></td></tr></table></figure><p>$ git diff ‘commit ID A’..’commit ID B’ 명령어를 입력하면 두 개의 commit 사이의 차이점을 보여준다.</p><div align="center"><br><img src="/image/git4-2.png" width="700" height="auto"><br></div><br>f1.txt의 경우, ID A에서는 그 내용이 ‘f1.txt : 4’, ID B에서는 그 내용이 ‘source : 2’이었음을 알 수 있다.<br>f2.txt의 경우, ID A에서는 그 내용이 ‘source : 2’, ID B에서는 해당 파일이 없었음을 알 수 있다.<br><br>$ git diff 명령어를 실행하면, 마지막 commit으로부터 변경된 점을 출력한다.<br>(단, 변경사항을 git add하여 stage area로 이동시키면, 출력하지 않는다.)<br><div align="center"><br><img src="/image/git4-3.png" width="700" height="auto"><br><br><img src="/image/git4-4.png" width="700" height="auto"><br><br><img src="/image/git4-5.png" width="700" height="auto"><br></div><p>f1.txt, f2.txt를 수정한 뒤, add하기 전에 $ git diff 명령어를 실행했을때의 결과는 위와 같다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 19, <a href="https://opentutorials.org/course/2708/15202" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15202</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Setting, Commit, Log</title>
      <link>http://dudri63.github.io/2019/01/20/git3/</link>
      <guid>http://dudri63.github.io/2019/01/20/git3/</guid>
      <pubDate>Sat, 19 Jan 2019 15:31:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Setting&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git commit&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. $ git log&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Setting&lt;/a&gt;&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Setting</a><br><a href="#2">2. $ git commit</a><br><a href="#3">3. $ git log</a></p><hr><p><a name="1">1. Setting</a></p><p>Git을 처음 쓰는 거라면, 앞으로 만들 버전이 내가 만들었음을 알리기 위하여 name, email을 setting한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;이름&quot;</span><br><span class="line">$ git config --global user.email &quot;이메일 주소&quot;</span><br><span class="line">$ git config --list// 입력한 사용자 정보 조회</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/git3-1.png" width="700" height="auto"><br></div><hr><p><a name="2">2. $ git commit</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit// 버전 생성</span><br></pre></td></tr></table></figure><p><strong>git commit</strong> 명령어를 실행하면, add한 파일들에 한하여 해당 버전에 추가한다.<br>또한, git commit 명령어를 실행하면, commit message를 작성할 수 있는데, commit message에는 어떠한 변화가 있는지 혹은 변화의 이유에 대하여 작성하도록 한다.</p><p>파일에 대하여 commit하고 싶으면 반드시 이전에 add하여야 한다. </p><h5 id="cf"><a href="#cf" class="headerlink" title="cf."></a>cf.</h5><h5 id="버전-의미-있는-변화-완성된-코드-단위"><a href="#버전-의미-있는-변화-완성된-코드-단위" class="headerlink" title="버전 : 의미 있는 변화, 완성된 코드 단위"></a>버전 : 의미 있는 변화, 완성된 코드 단위</h5><h5 id="git-add-commit-대기-상태에-들어가게-한다"><a href="#git-add-commit-대기-상태에-들어가게-한다" class="headerlink" title="git add : commit 대기 상태에 들어가게 한다."></a>git add : commit 대기 상태에 들어가게 한다.</h5><h5 id="git-commit-commit-대기-상태에-있는-파일들만-해당-버전에-추가한다"><a href="#git-commit-commit-대기-상태에-있는-파일들만-해당-버전에-추가한다" class="headerlink" title="git commit : commit 대기 상태에 있는 파일들만 해당 버전에 추가한다."></a>git commit : commit 대기 상태에 있는 파일들만 해당 버전에 추가한다.</h5><h5 id="commit-대기-상태-stage-area에-올린다"><a href="#commit-대기-상태-stage-area에-올린다" class="headerlink" title="commit 대기 상태 : stage area에 올린다."></a>commit 대기 상태 : stage area에 올린다.</h5><div align="center"><br><img src="/image/git3-2.png" width="700" height="auto"><br><br><img src="/image/git3-3.png" width="700" height="auto"><br><br><img src="/image/git3-4.png" width="700" height="auto"><br></div><hr><p><a name="3">3. $ git log</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log// 버전 생성이 되었는지 확인 가능</span><br><span class="line">$ git log -p // 각 commit 사이의 소스상 차이점을 파악할 수 있음</span><br></pre></td></tr></table></figure><p><strong>git log</strong> 명령어를 실행하면, 각 버전들의 verseion message, author, date 등을 확인할 수 있다.(version history를 파악할 수 있음)</p><p><div align="center"><br><img src="/image/git3-5.png" width="700" height="auto"><br></div><br>$ git log 명령어를 입력하면 각 commit들의 정보를 파악할 수 있다.</p><p><div align="center"><br><img src="/image/git3-6.png" width="700" height="auto"><br><img src="/image/git3-7.png" width="700" height="auto"><br></div><br>$ git log -p 명령어를 입력하면 각 버전들 사이의 소스상 차이점을 알 수 있다.<br>위 경우, version 4(commit message가 ‘4’인 버전) commit에서, version 4의 f1.txt의 내용이 ‘f1.txt : 4’, version 3의 f1.txt의 내용이 ‘source : 2’이었음을 알 수 있다.<br>또한, version 3 commit에서, version 2에서는 f2.txt가 없었으나 version 3에서는 그 내용을 ‘source : 2’로 하는 f2.txt가 새로 생성되었음을 알 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 19, <a href="https://opentutorials.org/course/2708/15202" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15202</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Init, Status, Add</title>
      <link>http://dudri63.github.io/2019/01/19/git2/</link>
      <guid>http://dudri63.github.io/2019/01/19/git2/</guid>
      <pubDate>Sat, 19 Jan 2019 13:45:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git init&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git status, $ git add&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. $ git init&lt;/a&gt;&lt;/p&gt;
&lt;figure class
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git init</a><br><a href="#2">2. $ git status, $ git add</a></p><hr><p><a name="1">1. $ git init</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git init//현재 디렉토리를 Git의 저장소로 등록</span><br></pre></td></tr></table></figure><p>위와 같은 명령어를 실행하면, 현재 디렉토리를 Git으로 관리할 수 있다.</p><p>이 후, ls -al로 확인하면, <strong>.git</strong> 디렉토리가 현재 디렉토리 내부에 새롭게 생성된 것을 알 수 있다. 버전 관리를 하게 되면, 여러 가지 정보가 생성되는데, 이 때 이 정보들은 .git 디렉토리에 저장된다.</p><div align="center"><br><img src="/image/git2-1.png" width="700" height="auto"><br></div><hr><p><a name="2">2. $ git status, $ git add</a></p><p>Git은 init을 하여 관리하고 있는 디렉토리라고 할지라도, 기본적으로 새롭게 생성된 파일에 대해서는 관리하지 않는다. 파일을 관리하기 위해서는 관리 대상으로 등록해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status// 현재 관리하고 있는 파일과 그렇지 않은 파일 확인</span><br><span class="line">git add + 파일// 해당 파일을 git에게 추적하라고 명령</span><br></pre></td></tr></table></figure><p><div align="center"><br><img src="/image/git2-2.png" width="700" height="auto"><br><img src="/image/git2-3.png" width="700" height="auto"><br></div><br>f1.txt의 내용을 ‘source:1’으로 하여 생성한다.</p><p><div align="center"><br><img src="/image/git2-4.png" width="700" height="auto"><br></div><br><strong>git status</strong>를 실행하였을 때, f1.txt는 untracked file임을 확인할 수 있다. 즉, f1.txt는 버전 관리가 되고 있는 디렉토리에 존재하지만, 아직 git에 의해 관리되고 있지 않다.<br>그러나 이 후, <strong>git add</strong> 명령어를 입력하여 git에게 f1.txt를 추적하라고 명령하면, 새롭게 f1.txt가 관리되기 시작하는 것을 알 수 있다.   </p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 19, <a href="https://opentutorials.org/course/2708/15170" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15170</a>, <a href="https://opentutorials.org/course/2708/15172" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15172</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/19/git2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Git의 기본</title>
      <link>http://dudri63.github.io/2019/01/19/git1/</link>
      <guid>http://dudri63.github.io/2019/01/19/git1/</guid>
      <pubDate>Sat, 19 Jan 2019 09:32:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 파일 복구 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Git이란 &lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 파일 복구 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;파일을 편집 전 상태로 돌리기 위한 방법 중 가장 간단한 것은 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 파일 복구 </a><br><a href="#2">2. Git이란 </a></p><hr><p><a name="1">1. 파일 복구 </a></p><p>파일을 편집 전 상태로 돌리기 위한 방법 중 가장 간단한 것은 기존 파일을 미리 복사해두는 것이다. 이 경우에는 특별하게 파일명을 구분할 수 있게 해주어야 한다는 번거로움이 있다. 또한, 여러 명이 공유한 파일을 동시에 편집할 경우 다른 사람이 변경하고 있는 내용을 지워버릴 수 있다.</p><hr><p><a name="2">2. Git이란 </a></p><p>이러한 문제점들을 해결하기 위하여 버전 관리 시스템이 <strong>‘Git’</strong>을 사용한다.<br>Git에서는 소스 코드가 변경된 이력을 쉽게 확인할 수 있고, 특정 시점에 저장된 버전과 비교하거나 특정 시점으로 되돌릴 수 있다.<br>또한, 내가 업로드하는 파일이 누군가가 편집한 내용과 충돌한다면, 경고 메세지가 발생하여 사전에 다른 사람들과 조율할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Git의 기본(시작하기), 누구나 쉽게 이해할 수 있는 Git 입문, 2017. 1. 19, <a href="https://backlog.com/git-tutorial/kr/" rel="external nofollow noopener noreferrer" target="_blank">https://backlog.com/git-tutorial/kr/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/19/git1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 최근접 점의 쌍 찾기 (분할정복)</title>
      <link>http://dudri63.github.io/2019/01/19/algo8/</link>
      <guid>http://dudri63.github.io/2019/01/19/algo8/</guid>
      <pubDate>Sat, 19 Jan 2019 09:31:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 최근접 점의 쌍 찾기&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 최근접 점의 쌍을 찾는 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 최근접 점의 쌍 찾기</a><br><a href="#2">2. 최근접 점의 쌍을 찾는 알고리즘</a><br><a href="#3">3. 시간복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 최근접 점의 쌍 찾기</a></p><p><strong>‘최근접 점의 쌍(Closest Pair)’</strong>을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다.</p><div align="center"><br><img src="/image/algo8-1.png" width="400" height="auto"><br></div><p>최근접 점의 쌍을 찾는 가장 간단한 방법은 모든 점에 대하여 각각의 두 점 사이의 거리를 계산하여 가장 가까운 점의 쌍을 찾는 것이다. 그러나 이러한 방법을 사용할 경우, 경우의 수는 <sub>n</sub>C<sub>2</sub> = n(n-1)/2 = O(n<sup>2</sup>)의 시간복잡도로써 굉장히 오랜 시간이 걸린다.</p><p>효율적인 방법은 분할 정복을 이용하는 것이다. 즉, n개의 점을 1/2로 분할하여 각각의 부분문제에서 최근점 점의 쌍을 찾고, 2개의 부분해 중에서 가장 짧은 거리를 가진 점의 쌍을 찾는다. 그러나 다음과 같은 경우도 있다.</p><div align="center"><br><img src="/image/algo8-2.png" width="400" height="auto"><br></div><p>2개의 부분해를 취합할 때, 더 가까운 거리를 가진 점의 쌍이 있는 경우이다.<br>따라서 단순히 2개로 분할한 부분문제에서 더 짧은 거리의 점의 쌍이 전체 문제에서 최근접 점의 쌍이라고 할 수 없는 것이다.(중간 영역에 있는 점들 때문에)</p><p>다음은 배열에 점의 좌표가 저장되어 있을 때, 중간 영역에 있는 점들을 찾는 방법이다.</p><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th></tr></thead><tbody><tr><td style="text-align:center">(1,- )</td><td style="text-align:center">(13,-)</td><td style="text-align:center">(17,-)</td><td style="text-align:center">(25,-)</td><td style="text-align:center">(26,-)</td><td style="text-align:center">(28,-)</td><td style="text-align:center">(30,-)</td><td style="text-align:center">(37,-)</td><td style="text-align:center">(45,-)</td><td style="text-align:center">(56,-)</td></tr></tbody></table><h5 id="4번-5번-점을-각각-왼쪽-부분문제의-가장-오른쪽-점-오른쪽-부분문제의-가장-왼쪽-점이라고-한다"><a href="#4번-5번-점을-각각-왼쪽-부분문제의-가장-오른쪽-점-오른쪽-부분문제의-가장-왼쪽-점이라고-한다" class="headerlink" title="(4번, 5번 점을 각각 왼쪽 부분문제의 가장 오른쪽 점, 오른쪽 부분문제의 가장 왼쪽 점이라고 한다.)"></a>(4번, 5번 점을 각각 왼쪽 부분문제의 가장 오른쪽 점, 오른쪽 부분문제의 가장 왼쪽 점이라고 한다.)</h5><p>2차원 공간에서 위와 같이 10개의 점이 있다고 가정한다.<br>이 때, 중간 영역에 속한 점들은 어떤 점들인가?</p><p>왼쪽 부분문제의 가장 오른쪽 점의 x-좌표에서 d를 뺀값과 오른쪽 부분문제의 가장 왼쪽 점의 x-좌표에 d를 더한 값 사이의 x-좌표 값을 가진 점들이다.<br>(이 때, d=min{왼쪽 부분의 최근접 점 쌍 사이의 거리, 오른쪽 부분의 최근접 점 쌍 사이의 거리})<br>만약, d=10이라면, 26-d=16, 28+d=38, 즉, 16~38 사이의 점들이 그것들이다.</p><hr><p><a name="2">2. 최근접 점의 쌍을 찾는 알고리즘</a></p><p>다음은 최근접 점의 쌍을 찾는 분할 정복 알고리즘이다. 단, 입력 점들은 x-좌표를 기준으로 미리 정렬되어 있다고 가정한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ClosestPair(S)</span><br><span class="line">입력: x-좌표의 오름차순으로 정렬된 배열 S</span><br><span class="line">출력: S에 있는 점들 중 최근접 점의 쌍의 거리</span><br><span class="line">if(i&lt;=S) return (2 또는 3개의 점들 사이의 최근접 쌍) // 3개 이하일 경우, 분할 X</span><br><span class="line">정렬된 S를 같은 크기의 S1과 S2로 분할한다. 단 |S|가 홀수이면, S1이 1 더 많게 분할한다.</span><br><span class="line">CP1 = ClosestPair(S1) // CP1은 S1에서의 최근접 점의 쌍</span><br><span class="line">CP2 = ClosestPair(S2) // CP2는 S2에서의 최근접 점의 쌍</span><br><span class="line">d = min&#123;dist(CP1), dist(CP2)&#125;일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서 이를 CPc라고 한다. 단, dist()는 두 점 사이의 거리이다.</span><br><span class="line">return (CP1, CP2, CPc 중에거 거리가 가장 짧은 쌍)</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>ClosestPair 알고리즘의 전처리 과정으로서 S의 점을 x-좌표로 정렬하여야 하는데, 이 과정에서 O(nlogn)의 시간이 소요된다. 왜냐하면 합병 정렬 또는 힙 정렬을 사용하면 O(nlogn)의 시간이 소요되기 때문이다.</p><ul><li>이 후, Line 4에서 O(1) 시간이 걸린다.</li><li>Line 5에서는 S1, S2로 S를 분할하는데, 배열의 중간 인덱스를 계산해야 하므로 O(1) 시간이 걸린다.</li><li>Line 6~7에서는 S1, S2가 각가 ClosestPair를 호출한다. 합병 정렬처럼 분할하면서 호출하는 데에는 특별한 시간이 소요되지 않는다.</li><li>Line 8에서는 중간 영역에 속해 있는 점들 중에서 최근접 점의 쌍을 찾는다. <strong>중간 영역에 있는 점들을 y-좌표 기준으로 정렬</strong>한 후, 거리가 d 이내인 주변의 점들 사이의 거리를 각각 계산하며 이 영역에 속한 점들 중에서 최근접 점의 쌍을 찾는다. 따라서 y-좌표로 정렬하는데 O(nlogn) 시간이 걸리고, 아래에서 위로 올라가며 각 점에서 주변의 점들 사이의 거리를 계산하는데 O(1) 시간이 걸린다. 따라서 O(nlogn) + O(n) = O(nlogn) 시간이 걸린다. (실제로 O(n)은 아니지만, 계산하는 시간이 n을 넘지 않으므로 대략적으로 O(n)으로 하였음)<div align="center"><br><img src="/image/algo8-3.png" width="400" height="auto"><br></div></li><li>Line 9에서는 3개의 점의 쌍 중 가장 짧은 거리를 가진 점의 쌍을 리턴하므로 O(1) 시간이 걸린다.</li></ul><div align="center"><br><img src="/image/algo8-4.png" width="400" height="auto"><br></div><p>ClosestPair 알고리즘의 분할 과정은 합병 정렬의 분할 과정과 동일하다. 그러나 취합하여 올라가는 과정에서 O(nlogn) 시간이 추가로 걸린다. 따라서, O(nlogn<sup>2</sup>)이 된다.</p><hr><p><a name="4">4. 응용</a></p><p>최근점 점의 쌍을 찾는 ClosestPair 알고리즘은 컴퓨터 그래픽스, 컴퓨터 비전, 지리 정보 시스템, 분자 모델링, 마케팅 등의 분야에서 활용된다.</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“알고리즘) Closest Pair”, Au commencement, 2019. 1. 19, <a href="https://m.blog.naver.com/PostView.nhn?blogId=babobigi&amp;logNo=220530321348&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F" rel="external nofollow noopener noreferrer" target="_blank">https://m.blog.naver.com/PostView.nhn?blogId=babobigi&amp;logNo=220530321348&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F</a></li><li>“최근접 점쌍 문제”, Wikipedia, 2019. 1. 19, <a href="https://ko.wikipedia.org/wiki/%EC%B5%9C%EA%B7%BC%EC%A0%91_%EC%A0%90%EC%8C%8D_%EB%AC%B8%EC%A0%9C" rel="external nofollow noopener noreferrer" target="_blank">https://ko.wikipedia.org/wiki/%EC%B5%9C%EA%B7%BC%EC%A0%91_%EC%A0%90%EC%8C%8D_%EB%AC%B8%EC%A0%9C</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/19/algo8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 선택 문제 (분할정복)</title>
      <link>http://dudri63.github.io/2019/01/18/algo7/</link>
      <guid>http://dudri63.github.io/2019/01/18/algo7/</guid>
      <pubDate>Fri, 18 Jan 2019 12:05:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 선택문제란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 선택문제 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 선택문제란</a><br><a href="#2">2. 선택문제 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 선택문제란</a></p><p><strong>‘선택(selection) 문제’</strong>는 n개의 숫자들 중에서 <strong>k번째로 작은 숫자를 찾는</strong> 문제이다.<br>선택문제는 <strong>Quick-Select</strong> 알고리즘이라고도 한다.<br>간단한 방법은 최소 숫자들을 오름차순으로 정렬한 후, k번째 숫자를 찾는 것이다.<br>그러나 이러한 알고리즘은 O(nlogn)의 수행 시간이 걸린다.<br>이보다 효율적인 해결을 위하여 분할 정복 개념을 활용할 수 있다.</p><p>선택 문제는 입력이 정렬되어 있지 않으므로, 퀵 정렬과 마찬가지로 피봇을 선택하여 피봇보다 작은 숫자들은 피봇의 왼쪽으로, 큰 숫자들은 피봇의 오른쪽 숫자로 이동시킨다.<br>이렇게 2개로 분할된 그룹들의 크기를 각각 파악하면, k번째로 작은 숫자가 2개의 그룹 중 어디에 속해있는 지를 알 수 있다.<br>이 후, 원하는 숫자가 속해 있지 않은 그룹은 고려하지 않고, 숫자가 속해 있는 그룹에서 위와 같은 작업을 반복하여 k번째로 작은 숫자를 파악한다.</p><div align="center"><br><img src="/image/algo7-1.png" width="500" height="auto"><br></div><p>선택 문제 알고리즘은 문제가 2개의 부분문제로 분할되나, 그 중에 1개의 부분문제는 고려할 필요 없으며, 부분문제의 크기가 일정하지 않은 크기로 감소하는 형태의 분할 정복 알고리즘이다.</p><hr><p><a name="2">2. 선택문제 알고리즘</a></p><p>다음은 선택 문제를 위한 분할 정복 알고리즘이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Selection(A, left, right, k)</span><br><span class="line">입력: A[left]~A[right]와 k, 단, 1&lt;=k&lt;=|A|, |A|=right-left+1</span><br><span class="line">출력: A[left]~A[right]에서 k번째 작은 원소</span><br><span class="line">피봇을 A[left]~A[right]에서 랜덤하게 선택,</span><br><span class="line">피봇과 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교,</span><br><span class="line">피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,</span><br><span class="line">피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.</span><br><span class="line">S = (p+1)-left  // S = small group의 크기</span><br><span class="line">if (k &lt;= S) Selection(A, left, p-1, k)// Small group에서 찾기</span><br><span class="line">else if (k = S) return A[p] // 피봇이 k번째 숫자인 경우</span><br><span class="line">else Selection(A, p+1, right, k-S)// Large group에서 찾기</span><br></pre></td></tr></table></figure><p>위 알고리즘에서 피봇은 small group에 속한다.</p><p>위 이미지에 이 알고리즘을 적용하여 살펴본다.</p><ol><li>k=10, 피봇은 A[0]인 23을 선택한다. (이 경우, A[left]를 피봇으로 선정하였음, 자리 변경 없음)</li><li>퀵 정렬과 마찬가지로 피봇과 원소들을 비교하여 자리를 바꾼 뒤, 피봇을 두 그룹의 가운데로 이동한다.</li><li>p=7, small group의 크기 S=8이므로, 10보다 작으니깐 large group만 고려한다.(그림 상 2번 과정까지)</li><li>Selection(A, 8, 15, 2)을 실시한다.</li><li>피봇은 A[8]인 44를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음)</li><li>2번 과정을 다시 수행한다.</li><li>p’=11, small group’의 크기 S’=4, k=2&lt;4이므로 찾고자 하는 수는 small group’내에 있다.(그림 상 3번 과정까지)</li><li>Selection(A, 8, 10, 2)을 실시한다.</li><li>피봇을 A[8]인 39를 선택한다. (마찬가지로, A[left]를 피봇으로 선정, 자리 변경 없음)</li><li>2번 과정을 다시 수행한다.</li><li>p’’=9, small group’’의 크기 S=2, k=2=S이므로, 피봇이 k=10번 째 숫자이다. A[9]를 리턴한다.</li></ol><hr><p><a name="3">3. 시간 복잡도</a></p><p>Selection 알고리즘은 분할 정복 알고리즘이기도 하지만 랜덤(Random) 알고리즘이기도 하다. 왜냐하면 위 알고리즘에서 line 4에서 피봇을 랜덤하게 정하기 때문이다. 만일 피봇이 입력을 너무 한 쪽으로 치우치게 분할하면, 알고리즘의 수행시간이 길어진다.</p><p>피봇이 입력을 분할하는 데, 두 그룹 중 하나의 크기가 입력 크기의 3/4과 같거나 그보다 크면 bad 분할이고, 그 반대의 경우느 good 분할이다. 그런데, bad 분할이 되거나 good 분할이 될 확률은 각가 1/2로 동일하다. 즉, 피봇을 랜덤하게 정했을 때 good 분할이 될 학률이 1/2이므로 평균 2회 연속해서 랜덤하게 피봇을 정하면 good 분할을 할 수 있다.<br>따라서, 매 2회 호출마다 good 분할이 되므로, good 반할만 연속하여 이루어졌을 때마의 시간복잡도를 구하여, 그 값에 2를 곱하면 평균 경우 시간복잡도를 구할 수 있다.</p><p>처음 입력의 크기가 n일 때 피봇을 랜덤하게 정한 후 입력은 두 그룹으로 분할된다. 이 과정에서 소요시간은 O(n)이고, 분할 후 large group의 최대 크기는 (3n-1)/4이다. 왜냐하면 good 분할만 일어난다고 가정하였기 때문이다.(편의상 (3n-1)/4를 (3/4)n으로 하겠음)<br>2번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)<sup>2</sup>n이다.<br>3번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)<sup>3</sup>n이다.<br>……..<br>i번째 분할에서, 분할 후 리스트들 중 가장 큰 것의 크기는 (3/4)<sup>i</sup>n이다.</p><p>즉, 입력의 크기가 계속해서 줄어들게 된다.<br>그리하여 평균 경우 시간 복잡도는 다음과 같다.<br>O(n + (3/4)n + (3/4)<sup>2</sup>n + (3/4)<sup>3</sup>n + … + (3/4)<sup>i</sup>) = O(n)<br>(입력의 크기는 계속해서 줄어든다. 그리고, 분할 된 리스트들 중에서는 가장 큰 것의 입력만을 고려하면 된다. 왜냐하면 작은 리스트들은 큰 리스트의 수행 시간 안에 이미 다 계산이 완료되기 때문이다.)<br>위 시간복잡도에 2를 곱한다.(평균 2회만에 good 분할이 되기 때문)<br>그리하여 Selection 알고리즘의 시간복잡도는 2XO(n) = O(n)이다.</p><hr><p><a name="4">4. 응용</a></p><p>선택 알고리즘은 정렬을 하지 않고 k번째 작은 수를 선형 시간에 찾을 수 있게 해준다. 따라서 선택 알고리즘은 데이터 분석을 위한 중앙값을 찾는 데 활용된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“Quick Select”, AlgoCoding, 2019. 1. 18, <a href="http://www.algocoding.net/design/dc/quickselect.html" rel="external nofollow noopener noreferrer" target="_blank">http://www.algocoding.net/design/dc/quickselect.html</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/18/algo7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 퀵 정렬 (분할정복)</title>
      <link>http://dudri63.github.io/2019/01/17/algo6/</link>
      <guid>http://dudri63.github.io/2019/01/17/algo6/</guid>
      <pubDate>Thu, 17 Jan 2019 10:07:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 퀵 정렬이란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 퀵 정렬 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 퀵 정렬이란</a><br><a href="#2">2. 퀵 정렬 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 퀵 정렬이란</a></p><p><strong>‘퀵 정렬(Quick Sort)’</strong>은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 <strong>정복 후 분할하는 알고리즘</strong>이다. 퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, <strong>각 부분문제의 크기가 일정하지 않은 형태</strong>의 분할 정복 알고리즘이다.</p><p>퀵 정렬의 아이디어는 <strong>피봇(pivot)</strong>이라 일컫는 배열의 원소를 기준으로 피봇보다 작은 숫자들은 왼편으로, 피봇보다 큰 숫자들은 오른편에 위치하도록 분할하고, 피봇을 그 사이에 놓는 것이다.<br>단, 피봇은 분할된 왼편이나 오른편 부분에 포함되지 않는다.</p><div align="center"><br><img src="/image/algo6-2.png" width="500" height="auto"><br></div><p>위 경우는 피봇을 분할된 왼편과 오른편 부분에 가운데에 위치시켰다.</p><hr><p><a name="2">2. 퀵 정렬 알고리즘</a></p><p>다음은 퀵 정렬 알고리즘이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(A, left, right)</span><br><span class="line">입력: 배열 A[left]~A[right]</span><br><span class="line">출력: 정렬된 배열 A[left]~A[right]</span><br><span class="line">if(left&lt;right)&#123;// 원소가 1개일 경우에는 정렬하지 않는다.</span><br><span class="line">  피봇을 A[left]~A[right] 중에서 선택,</span><br><span class="line">  피봇을 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교,</span><br><span class="line">  피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고,</span><br><span class="line">  피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮긴다.</span><br><span class="line">  피봇은 A[p]에 놓는다.</span><br><span class="line">  QuickSort(A, left, p-1)// 피봇보다 작은 그룹</span><br><span class="line">  QuickSort(A, p+1, right)// 피봇보다 큰 그룹</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위 이미지를 이 알고리즘에 적용하여 살펴본다.<br>초기상태의 배열에서 left는 0, right 8이다.<br>피봇(A[pivot])을 A[0]인 1으로 선택한다.<br>피봇 A[pivot]를 A[left]과 자리를 바꾼다.(이 경우, 피봇과 A[left]가 일치)<br>피봇과 배열의 각 원소들과 비교를 실시하여 자리를 옮긴 뒤 피봇의 위치를 A[p]로 옮긴다.<br>이 과정은 아래 그림에 잘 나와 있다.</p><div align="center"><br><img src="/image/algo6-4.png" width="500" height="auto"><br></div><p>A[left+1], A[right]에서 출발하여 각각 오른쪽, 왼쪽으로 이동하면서, 비교를 진행한다.<br>왼쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 작을 경우 정지,<br>오른쪽에서 출발하는 인덱스는 가리키는 숫자가 피봇보다 클 경우 정지한다.<br>양 쪽의 인덱스가 모두 정지하면 교환한다.<br>이 작업 계속 실시하다가 두 인덱스가 엇갈려서 지난 경우, stop한다.<br>이 후, 피봇의 위치를 가운데로 옮긴다.</p><p>위 작업을 실시한 후, 왼쪽 부분 리스트와 오른쪽 부분 리스트에 대하여 위 작업을 반복한다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>퀵 정렬의 성능은 기본적으로 <strong>피봇 선택</strong>이 결정한다.<br>항상 1/2씩 분할한다면 최선의 경우가 되지만(O(nlogn)),<br>피봇으로 가장 작은 숫자 또는 가장 큰 숫자가 선택되면, 최악의 경우가 된다.(O(n<sup>2</sup>))</p><ul><li>최선의 경우<div align="center"><br><img src="/image/algo6-5.png"><br></div></li><li>최악의 경우<div align="center"><br><img src="/image/algo6-6.png"><br></div></li></ul><p><strong>피봇 선정 방법</strong></p><p>퀵 저렬의 불균형한 분할을 완화시키기 위해서, 일반적으로 다음과 같은 피봇 선정 방법이 사용된다.</p><ul><li>랜덤하게 선정</li><li>세 숫자의 중앙 값으로 선정하는 방법</li></ul><p>입력의 크기가 매우 클 때, 퀵 정렬의 성능을 더 향상시키기 위해서, 삽입 정렬이 동시에 사용되기도 한다. 퀵 정렬을 재귀 호출로 수행되어 문제가 크기가 작아지면 중단하고, 삽입 정렬을 사용하면 효율적이다.</p><hr><p><a name="4">4. 응용</a></p><p>퀵 정렬은 커다란 크기의 입력에 대해서 가장 좋은 성능을 보이는 정렬 알고리즘이다. 퀵 정렬은 실질적으로 어느 정렬 알고리즘보다 좋은 성능을 보인다. 생물 정보 공학에서 특정 유전자를 효율적으로 찾는 데 퀵 정렬이 사용되곤 한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“[알고리즘] 퀵 정렬(quick sort)이란”, Heee’s Development Blog, 2019. 1. 17, <a href="https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html" rel="external nofollow noopener noreferrer" target="_blank">https://gmlwjd9405.github.io/2018/05/10/algorithm-quick-sort.html</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/17/algo6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 합병 정렬 (분할정복)</title>
      <link>http://dudri63.github.io/2019/01/17/algo5/</link>
      <guid>http://dudri63.github.io/2019/01/17/algo5/</guid>
      <pubDate>Thu, 17 Jan 2019 07:41:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 합병 정렬이란?&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 합병 정렬 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a nam
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 합병 정렬이란?</a><br><a href="#2">2. 합병 정렬 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 합병 정렬이란?</a></p><p><strong>‘합병 정렬(Merge Sort)’</strong>은 입력이 2개의 부분문제로 분할, 부분 문제의 크기가 1/2로 감소하는 분할 정복 알고리즘이다.</p><div align="center"><br><img src="/image/algo5-1.png" width="400" height="500"><br></div><p>합병 과정이 문제를 정복한다는 것이 중요하다.<br><strong>합병(merge)</strong>이란 2개의 각각 <strong>정렬된</strong> 숫자들을 1개의 <strong>정렬된</strong> 숫자들로 <strong>합치는 것</strong>이다. </p><hr><p><a name="2">2. 합병 정렬 알고리즘</a></p><p>다음은 분할 정복에 기반을 둔 합병 정렬 알고리즘이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MereSort(A,p,q)</span><br><span class="line">입력: A[p]~A[q]</span><br><span class="line">출력: 정렬된 A[p]~A[q]</span><br><span class="line">if(p &gt; q) &#123;// 배열의 원소의 수가 2개 이상이면,</span><br><span class="line">  k = [(p+q)/2]// (k는 배열을 반으로 나누기 위한 중간 원소의 인덱스이다.)</span><br><span class="line">  MergeSort(A,p,k)// 앞부분 재귀 호출</span><br><span class="line">  MergeSort(A,k+1,q)// 뒷부분 재귀 호출</span><br><span class="line">  A[p]~A[q]와 A[k+1]~A[q]를 합병한다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>분할하여 재귀 호출하는 것은 line 6, 7에서 수행되고, 합병은 line 8에서 수행된다.</p><p>위 그림에 이 알고리즘을 적용하여 살펴본다.</p><ol><li>A를 그림에서 가장 상위에 있는 배열, p를 6, q를 0이라고 한다.</li><li>그리하여 k는 3이 되고, 배열 A는 A[0]~A[3], A[4]~A[6] 두 부분으로 나뉜다.</li><li>이 작업을 배열의 원소가 한 개씩 남을 때까지 반복한다.</li><li>원소가 단, 1개인 배열들을 2개씩 합병한다.</li><li>분할된 배열들이 완성된 한 개의 배열이 될 때까지 4번을 반복한다.</li></ol><hr><p><a name="3">3. 시간 복잡도</a></p><p>정렬의 시간복잡도는 일반적으로 숫자의 <strong>비교 횟수</strong>로 나타낸다.<br>위 그림에서 알고리즘이 수행한 비교 횟수를 본다.<br>분할하는 부분은 배열의 중간 인덱스 계산과 2번의 재귀 호출을 하는 것이므로 O(1) 시간이 걸린다.<br>이에 반해, 합병의 수행 시간은 입력의 크기에 비례한다.<br>2개의 정렬된 배열 A, B의 크기가 각각 n, m이라면 <strong>최대 비교 횟수는 (n+m+-1)</strong>이다.<br>마지막에 합병되는 숫자는 비교할 대상이 없으므로, -1을 한다.<br>(그림에서 3,27,38,43 배열과 9,10,82 배열을 합치는 과정을 보면, 3을 9,10,82와 비교(3번), 27을 9,10,82와 비교(3번), 38을 82와 비교(1번), 43을 82와 비교(1번)이다. 총 8번의 비교를 하였다.)<br>즉, 합병의 시간복잡도는 O(n+m)이다.</p><p>그러나 비교 횟수를 직접 세보는 것보다 더 쉬운 계산은 층별로 살피는 것이다.<br>합병 과정에서 최종으로 만들어진 하나의 배열을 제외, 원소가 단 하나인 배열들로 구성된 층을 포함하여 총 3개의 층으로 이루어져 있는데, 각 층에서 모든 숫자가 합병에 참여하고 있다. 앞서 알아보았 듯이, 합병은 입력의 크기에 비례하므로 각 층에서 수행된 비교 횟수는 O(n)이다. 그런데, 층이 높아질수록(위로 올라갈수록) 입력의 크기(배열의 크기)가 반씩 줄어든다. 즉, 다음과 같다.</p><ul><li>3층 : n/2<sup>3</sup> = 1 / {38}, {27}, {43}, {3}, {9}, {82}, {10} (n은 7)</li><li>2층 : n/2<sup>2</sup> = 2 / {27,38}, {3,43}, {9,82}, {10}</li><li>1층 : n/2 = 4 / {3,27,38,43}, {9,10,82}</li></ul><p>k번 1/2로 분할하였으면 k개의 층이 생기는 것이고, k=log<sub>2</sub>n임을 알 수 있다.<br>결과적으로 합병 정렬의 시간복잡도는 (층수)XO(n) = log<sub>2</sub>nXO(n) = <strong>O(nlogn)</strong>이다.<br>(각 층마다 모든 입력의 합은 n이다. 헷갈리지 말자. 그림을 보자.)</p><p>합병 정렬 알고리즘의 공간 복잡도는 O(n)이다. 왜냐하면 입력을 위한 메모리 공간 외에 추가로 입력과 같은 크기의 공간이 별도로 필요하기 때문이다. 2개의 정렬된 부분을 하나로 합병하는 데 있어서, 합병된 결과를 저장할 곳이 필요하다.</p><hr><p><a name="4">4. 응용</a></p><p>합병 정렬은 외부정렬의 기본이 되는 정렬 알고리즘이다. 연결 리스트에 있는 데이터를 정렬할 때 퀵 정렬이나 힙 정렬보다 훨씬 효율적이다. CPU와 GPU를 이용한 병렬 프로세싱에서도 합병 정렬 알고리즘이 활용된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“Merge Sort”, Wikipedia, 2019. 1. 17, <a href="https://en.wikipedia.org/wiki/Merge_sort" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Merge_sort</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/17/algo5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 분할 정복 알고리즘</title>
      <link>http://dudri63.github.io/2019/01/16/algo4/</link>
      <guid>http://dudri63.github.io/2019/01/16/algo4/</guid>
      <pubDate>Wed, 16 Jan 2019 12:37:50 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 분할 정복 알고리즘이란?&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 분할 정복 알고리즘의 분류&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 분할 정복 알고리즘이란?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘분할 정
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 분할 정복 알고리즘이란?</a><br><a href="#2">2. 분할 정복 알고리즘의 분류</a></p><hr><p><a name="1">1. 분할 정복 알고리즘이란?</a></p><p><strong>‘분할 정복(Divide-and-Conquer) 알고리즘’</strong>이란 주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다.<br>분할된 입력에 대하여 동일한 알고리즘을 적용 및 계산하고 결과들을 취합하여 원래 문제의 결과를 얻는다.<br>분할된 입력에 대한 문제를 부분문제(subproblem)라고 하고, 부분문제의 해를 부분해라고 한다. 부분문제는 더이상 분할할 수 없을 때까지 계속 분할한다.</p><p><div align="center"><br><img src="/image/algo4-1.jpeg" width="400" height="500"><br></div><br>위 이미지는 분할 정복의 예이다.</p><p>그렇다면 입력 크기가 n일 때 총 몇 번 분할하여야 더 이상 분할할 수 없는 크기인 1이 될까?</p><p>답을 계산하기 위해 분할한 총 횟수를 k라고 하고, 1번 분할할 때마다 각각의 입력 크기가 절반씩 줄어든다고 가정한다. 이 때, k번 분할하였으면, 입력의 크기는 n/2<sup>k</sup>이고, 입력 크기가 n/2<sup>k</sup>=1일 때 더 이상 분할할 수 없으므로, k = log<sub>2</sub>n이다.</p><hr><p><a name="2">2. 분할 정복 알고리즘의 분류</a></p><p>분할 정복 알고리즘은 분할되는 부분문제의 수와 부분문제의 크기에 따라서 다음과 같이 분류할 수 있다.</p><ul><li>입력이 2개의 부분문제로 분할, 부분문제의 크기가 1/2로 감소하는 알고리즘<br>-&gt; 합병 정렬(Merge Sort)</li><li>입력이 2개로 분할되고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘<br>-&gt; 퀵 정렬(Quick Sort)</li><li>입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없는 알고리즘<br>-&gt; 이진 탐색(Binary Search)</li><li>입력이 2개로 분할되나, 그 중에 1개의 부분문제는 고려할 필요가 없고, 부분문제의 크기가 일정하지 않은 크기로 감소하는 알고리즘<br>-&gt; 선택 문제(Selection)</li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“Divide-and-conquer algorithm”, Wikipedia, 2019. 1. 16, <a href="https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm" rel="external nofollow noopener noreferrer" target="_blank">https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/16/algo4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 알고리즘을 배우기 위한 준비(2)</title>
      <link>http://dudri63.github.io/2019/01/16/algo3/</link>
      <guid>http://dudri63.github.io/2019/01/16/algo3/</guid>
      <pubDate>Wed, 16 Jan 2019 09:41:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#4&quot;&gt;4. 알고리즘의 분류&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#5&quot;&gt;5. 알고리즘의 효율성 표현&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#6&quot;&gt;6. 복잡도의 점근적 표기&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#7&quot;&gt;7. 왜 효율적인 알고리즘이 필요한가?
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#4">4. 알고리즘의 분류</a><br><a href="#5">5. 알고리즘의 효율성 표현</a><br><a href="#6">6. 복잡도의 점근적 표기</a><br><a href="#7">7. 왜 효율적인 알고리즘이 필요한가?</a></p><hr><p><a name="4">4. 알고리즘의 분류</a></p><p>알고리즘은 문제의 해결 방식에 따라 다음과 같이 분류된다.</p><ul><li>분할 정복 알고리즘(Divide-and-Conquer)</li><li>그리디 알고리즘(Greedy)</li><li>동적 계획 알고리즘(Dynamic Programming)</li><li>근사 알고리즘(Approximation)</li><li>백트래킹 기법(Backtracking)</li><li>분기 한정 기법(Branch-and-Bound)</li></ul><p>이 외에도 랜덤 알고리즘, 병렬 알고리즘, 분산 알고리즘, 양자 알고리즘, 유전자 알고리즘 등이 있다.<br>문제에 따라 어떤 알고리즘이 더 효율적일지는 다를 것이다.<br>또한, 이름 지어지지 못한 알고리즘들도 다수 존재한다.<br>위와 같이 해결 방식에 따른 알고리즘 분류 외에도 문제에 기반을 두어 알고리즘을 분류하기도 한다.<br>정렬 알고리즘, 그래프 알고리즘, 기하 알고리즘 등이 그 예이다.</p><hr><p><a name="5">5. 알고리즘의 효율성 표현</a></p><p>알고리즘의 효율성은 알고리즘의 ‘수행 시간’ 또는 알고리즘이 수행하는 동안 사용되는 ‘메모리 공간의 크기’로 나타낼 수 있다. 이들을 각각 <strong>‘시간복잡도’</strong>, <strong>‘공간복잡도’</strong>라고 한다. 일반적으로 알고리즘들을 비교할 때에는 시간복잡도가 주로 사용된다.</p><p>알고리즘을 프로그램으로 구현 및 실행 시켜 시간을 측정할 수 있으나, 이러한 방법은 객관적으로 평가하기가 어렵다. 왜냐하면 컴퓨터 환경, 프로그래밍 언어, 프로그래머 실력 등에 의하여 달라질 수 있기 때문이다. 그리하여 시간복잡도는 알고리즘이 수행하는 기본적인 연산 횟수를 입력 크기에 대한 함수로 표현한다.<br>예를 들어, n장의 숫자 카드 중에서 최대 숫자를 찾는데, 순차탐색으로 찾을 경우, (n-1)번의 비교를 수행한다. 이 경우, 시간복잡도는 (n-1)이다.</p><p>알고리즘의 복잡도를 표현하는 대는 다음과 같은 분석 방법들이 있다.</p><ul><li>최악 경우 분석(worst case analysis)</li><li>평균 경우 분석(average case analysis)</li><li>최선 경우 분석(best case analysis)</li></ul><p>일반적으로 ‘최악 경우 분석’으로 알고리즘의 복잡도를 나타낸다.</p><hr><p><a name="6">6. 복잡도의 점근적 표기</a></p><p>시간복잡도, 공간복잡도는 입력 크기에 대한 함수로 표기한다.<br>이 때, 함수는 주로 다항식인데, 이를 단순하게 나타내기 위해 ‘점근적 표기(asymptotic notation)’를 사용한다. 이는 입력 크기 n이 무한대로 커질 때의 복잡도롤 간단하게 표현하기 위함이다.</p><p>예를 들어, 3n<sup>3</sup>-15n<sup>2</sup>+10n-18을 n<sup>3</sup>으로, 4n+6을 n으로 단순화시킨다.<br>이 단순화된 식에 상한, 하한, 동일한 증가율과 같은 개념을 적용하여, 다음과 같이 점근적 표기를 사용한다.</p><ul><li>O(Big-Oh)-표기</li><li>Ω(Big-Omega)-표기</li><li>θ(Theta)-표기</li></ul><p>O-표기는 복잡도의 ‘점근적 상한’, Ω-표기는 복잡도의 ‘점근적 하한’, θ-표기는 복잡도의 ‘상한과 하한이 동시에 적용’되는 경우를 나타낸다.</p><p>복잡도가 f(n) = 2n<sup>2</sup>-8n+3이라면, f(n)의 O-표기는 O(n<sup>2</sup>)이다. 의미는 다음과 같다.<br>f(n)의 단순화된 표현 n<sup>2</sup>에 임의의 상수 c를 곱한 cn<sup>2</sup>이 n이 증가함에 따라 f(n)의 상한이 된다. 단, c&gt;0</p><p>위 경우, f(n)의 Ω-표기는 Ω(n<sup>2</sup>)이다. 단, 의미는 ‘n이 증가함에 따라 2n<sup>2</sup>-8n+3이 cn<sup>2</sup>보다 작을 수 없다.’이다.</p><p>θ-표기는 복잡도의 O-표기와 θ-표기가 같은 경우에 사용한다. 의미는 ‘f(n)은 n이 증가함에 따라 n<sup>2</sup>과 동일한 증가율을 가진다.’라는 뜻이다.</p><hr><p><a name="7">7. 왜 효율적인 알고리즘이 필요한가?</a></p><p>입력이 커질수록 알고리즘에 따른 수행 시간의 차이가 매우 커지게 된다. 효율적인 알고리즘은 값비싼 하드웨어의 기술 개발보다 훨씬 더 경제적이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/16/algo3/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
