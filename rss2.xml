<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Seo&#39;s Blog</title>
    <link>http://dudri63.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Tue, 22 Jan 2019 12:09:03 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[Python] PEP, 객체</title>
      <link>http://dudri63.github.io/2019/01/22/python4/</link>
      <guid>http://dudri63.github.io/2019/01/22/python4/</guid>
      <pubDate>Tue, 22 Jan 2019 11:02:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. PEP&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 객체&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. PEP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;파이썬은 수많은 사람들이 의견을 수용하고 토론하며 발전해온 언어이다.&lt;br&gt;언어 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. PEP</a><br><a href="#2">2. 객체</a></p><hr><p><a name="1">1. PEP</a></p><p>파이썬은 수많은 사람들이 의견을 수용하고 토론하며 발전해온 언어이다.<br>언어 발전을 위해 논의된 주제를 <strong>PEP</strong>라는 이름으로 문서화해왔다.<br>수많은 PEP 문서들이 있는데, 개발자들마다 작성한 코드 스타일이 다르다.<br>그렇기 때문에 대부분은 PEP 8문서를 통해 권장하는 파이썬 스타일을 학습한다.</p><hr><p><a name="2">2. 객체</a></p><p>파이썬은 모든 것이 <strong>객체(Object)</strong>로 이루어져 있다.<br>객체란 ‘어떠한 <strong>속성(attribute)</strong>값과 <strong>행동(method)</strong>을 가지고 있는 데이터’이다.<br>파이썬의 존재하는 숫자, 문자, 함수 등은 여러 속성과 행동을 가지고 있는 데이터이다.</p><p>예를들어, 문자 ‘a’는 파이썬에서 단순하게 문자를 표현되는 것으로 끝나지 않는다.<br>a.join, a.upper와 같이 문자 자체를 객체로 만들고 다양한 속성과 행동을 넣을 수 있다.</p><p>이러한 프로그래밍 기법을 <strong>객체지향 프로그래밍</strong>이라고 한다.<br>객체지향 프로그래밍은 해결할 문제를 실제의 세계처럼 다양한 정보들을 가진 객체로 표현하고, 객체들 간의 통신으로 해결하는 기법이다.</p><hr><p>2.1 객체의 타입, 클래스</p><p>파이썬에서 객체의 <strong>타입(type)</strong>은 객체를 어떤 <strong>클래스(Class)</strong>로 만들어졌는냐에 따라 결정된다.<br>클래스는 객체를 만드는 일종의 틀이다.<br>클래스는 생성할 객체들의 속성과 행동을을 정의하는 공간이고,<br>객체끼리 서로 같은 타입을 가진다면 같은 속성과 행동을 가지게 된다.<br>타입의 예로는 int, float, str 등이 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li><a href="https://wikidocs.net/21733" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/21733</a>, <a href="https://wikidocs.net/20456" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/20456</a>, <a href="https://wikidocs.net/20457" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/20457</a>, <a href="https://wikidocs.net/21719" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/21719</a>, </li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/22/python4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 입력과 출력, 논리 연산, 주석</title>
      <link>http://dudri63.github.io/2019/01/22/python3/</link>
      <guid>http://dudri63.github.io/2019/01/22/python3/</guid>
      <pubDate>Tue, 22 Jan 2019 10:32:22 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 입력과 출력&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 논리 연산&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 주석 (Comment)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 입력과 출력 &lt;/a&gt;&lt;/p&gt;
&lt;f
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 입력과 출력</a><br><a href="#2">2. 논리 연산</a><br><a href="#3">3. 주석 (Comment)</a></p><hr><p><a name="1">1. 입력과 출력 </a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in_str = input(&quot;입력해주세요.\n&quot;)</span><br><span class="line">print(in_str.upper()+&quot; World!&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py3-1.png"></p><p>input()</p><ul><li>사용자가 입력한 값을 반환하는 함수 </li><li>입력할 값에 대한 안내를 출력할 수도 있다. </li><li>사용자가 입력한 값은 문자열로 취급</li><li>입력한 값을 정수로 저장하고 싶다면 int() 함수를 이용한다.<br>ex. x = int(input(“숫자를 입력해주세요.\n”))</li></ul><p>string.upper() : 문자열을 대문자로 변환하여 반환<br>string.lower() : 문자열을 소문자로 변환하여 반환</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">in_str = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">real_egoing = &quot;11&quot;</span><br><span class="line">real_k8805 = &quot;ab&quot;</span><br><span class="line">if real_egoing == in_str:</span><br><span class="line">  print(&quot;Hello!, egoing&quot;)</span><br><span class="line">elif real_k8805 == in_str:</span><br><span class="line">  print(&quot;Hello!, k8805&quot;)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;Who are you?&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py3-2.png"></p><hr><p><a name="2">2. 논리 연산</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in_str = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">real_egoing = &quot;egoing&quot;</span><br><span class="line">real_k8805 = &quot;k8805&quot;</span><br><span class="line">if real_egoing == in_str or real_k8805 == in_str:</span><br><span class="line">  print(&quot;Hello!&quot;)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;Who are you?&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py3-3.png"></p><p>if를 중첩해서 사용한 경우<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">input_pwd = input(&quot;비밀번호를 입력해주세요.\n&quot;)</span><br><span class="line">real_id = &quot;egoing&quot;</span><br><span class="line">real_pwd = &quot;11&quot;</span><br><span class="line">if real_id == input_id:</span><br><span class="line">    if real_pwd == input_pwd:</span><br><span class="line">        print(&quot;Hello!&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;잘못된 비밀번호입니다&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;잘못된 아이디입니다&quot;)</span><br></pre></td></tr></table></figure></p><p><img src="/image/py3-4.png"></p><p>and로 통합한 경우<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">input_pwd = input(&quot;비밀번호를 입력해주세요.\n&quot;)</span><br><span class="line">real_id = &quot;egoing&quot;</span><br><span class="line">real_pwd = &quot;11&quot;</span><br><span class="line">if real_id == input_id and real_pwd == input_pwd:</span><br><span class="line">    print(&quot;Hello!&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;로그인에 실패했습니다&quot;)</span><br></pre></td></tr></table></figure></p><p><img src="/image/py3-5.png"></p><hr><p><a name="3">3. 주석(Comment)</a></p><p>파이썬에서 주석 사용은 다음과 같다.</p><div align="center"><br><img src="/image/py3-6.png"><br></div><ul><li>‘’’~’’’ : ‘’’ 사이에 주석을 작성(‘은 아포스트로피)</li><li>#~       : # 뒤에 주석을 작성</li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“Python &amp; Ruby”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/1750/9681" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9681</a>, <a href="https://opentutorials.org/course/1750/9619" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9619</a>, <a href="https://opentutorials.org/course/1750/9626" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9626</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/22/python3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 변수, 비교, 조건문</title>
      <link>http://dudri63.github.io/2019/01/22/python2/</link>
      <guid>http://dudri63.github.io/2019/01/22/python2/</guid>
      <pubDate>Tue, 22 Jan 2019 01:49:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 변수&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 비교(Boolean)&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 변수&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Python은 &lt;strong&gt;C&lt;/strong&gt;언어를 비롯한 다른 언
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 변수</a><br><a href="#2">2. 비교(Boolean)</a></p><hr><p><a name="1">1. 변수</a></p><p>Python은 <strong>C</strong>언어를 비롯한 다른 언어들과는 다르게 변수 선언을 미리 하지 않고도, 변수에 데이터를 저장할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=10// 정수형 변수</span><br><span class="line">y=5</span><br><span class="line">print(x+y)</span><br><span class="line"> </span><br><span class="line">title = &quot;python &amp; ruby&quot; // 문자열형 변수</span><br><span class="line">print(&quot;Title is &quot;+title)</span><br></pre></td></tr></table></figure></p><p><img src="/image/py2-1.png"></p><hr><p>1.1 문자열에서 변수의 사용<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name = &quot;서영기&quot;</span><br><span class="line">print(&quot;안녕하세요. &quot;+name+&quot;님&quot;)// 두 문자열을 합친 결과를 출력</span><br><span class="line">print(name+&quot;님을 위한 강의를 준비했습니다.&quot;)</span><br><span class="line">print(name+&quot;님 꼭 참석 부탁드립니다.&quot;)</span><br></pre></td></tr></table></figure></p><p><img src="/image/py2-2.png"></p><hr><p>1.2 수 계산에서 변수의 사용<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">donation = 200</span><br><span class="line">student = 10</span><br><span class="line">sponsor = 100</span><br><span class="line">print((donation*student)/sponsor)</span><br></pre></td></tr></table></figure></p><p><img src="/image/py2-3.png"></p><hr><p><a name="2">2. 비교(Boolean)</a></p><p>bool연산(boolean)의 결과를 확인할 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=1</span><br><span class="line">print(a==b)</span><br><span class="line">print(1==2)</span><br><span class="line">print(1&gt;2)</span><br><span class="line">print(1&lt;2)</span><br><span class="line">print(True)</span><br><span class="line">print(False)</span><br></pre></td></tr></table></figure></p><p><img src="/image/py2-4.png"></p><hr><p><a name="3">3. 조건문(Conditional Statement)</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if True:// true라고 쓰면 오류</span><br><span class="line">    print(&quot;code1&quot;)</span><br><span class="line">    print(&quot;code2&quot;)</span><br><span class="line">print(&quot;code3&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py2-5.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if False:// false라고 쓰면 오류</span><br><span class="line">    print(&quot;code1&quot;)</span><br><span class="line">    print(&quot;code2&quot;)</span><br><span class="line">print(&quot;code3&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py2-6.png"></p><p>if 조건문에 포함되어 있는 것들은 “code1”, “code2” 문자열을 각각 출력하는 print() 함수이다. 조건이 True일 때 if 조건문 내부에 있는 것들이 동작, Flase일 때 조건문 내부에 있는 것들이 동작하지 않음을 알 수 있다. 그리고 code3 문자열을 출력하는 print() 함수는 조건문 내부에 포함되어 있지 않다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input = 11</span><br><span class="line">real = 11</span><br><span class="line">if real == input:</span><br><span class="line">    print(&quot;Hello!&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py2-7.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input = 11</span><br><span class="line">real = 11</span><br><span class="line">if real == input:</span><br><span class="line">    print(&quot;Hello!&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Who are you?&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py2-7.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input = 11</span><br><span class="line">real = 12</span><br><span class="line">if real == input:</span><br><span class="line">    print(&quot;Hello!&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;Who are you?&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py2-8.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">input = &quot;ab&quot;</span><br><span class="line">real_egoing = 11</span><br><span class="line">real_k8805 = &quot;ab&quot;</span><br><span class="line">if real_egoing == input:</span><br><span class="line">  print(&quot;Hello!, egoing&quot;)</span><br><span class="line">elif real_k8805 == input:</span><br><span class="line">  print(&quot;Hello!, k8805&quot;)</span><br><span class="line">else:</span><br><span class="line">  print(&quot;Who are you?&quot;)</span><br></pre></td></tr></table></figure><p><img src="/image/py2-9.png"></p><p>else if를 elif 라고 함을 주의하자. 또한, 문자열 비교도 가능한 것을 알 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“Python &amp; Ruby”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/1750/9616" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9616</a>, <a href="https://opentutorials.org/course/1750/9618" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9618</a>, <a href="https://opentutorials.org/course/1750/9620" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9620</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/22/python2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 실행, 수와 계산, 문자 및 문자열</title>
      <link>http://dudri63.github.io/2019/01/21/python1/</link>
      <guid>http://dudri63.github.io/2019/01/21/python1/</guid>
      <pubDate>Mon, 21 Jan 2019 03:40:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Execution&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 수와 계산&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 문자 및 문자열&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Execution&lt;/a&gt;&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Execution</a><br><a href="#2">2. 수와 계산</a><br><a href="#3">3. 문자 및 문자열</a></p><hr><p><a name="1">1. Execution</a></p><p>1.1 대화형 모드로 실행</p><p><img src="/image/py1-1.png"></p><p>터미널에서 python3를 입력한다.</p><p>1.2 파일 모드로 실행</p><p>대화형 모드로 간단하게 코드를 작성하기는 편리하지만, 크고 많은 양의 코드를 작성하는 것은 어려움. 따라서 파일을 사용하여 실행한다.<br>windows의 경우, 메모장, linux의 경우 gedit을 사용할 수 있다.</p><p><img src="/image/py1-2.png"></p><p><img src="/image/py1-3.png"><br><img src="/image/py1-4.png"></p><p>gedit을 연 뒤, 코드 작성, 확장자를 *.py로 하여 저장한다.<br>이 후, $ python3 명령어 뒤에 경로 및 파일이름, 확장자를 실행한다.</p><hr><p><a name="2">2. 수와 계산</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(10 + 5)</span><br><span class="line">print(10 - 5)</span><br><span class="line">print(10 * 5)</span><br><span class="line">print(10 / 5)</span><br></pre></td></tr></table></figure><p><img src="/image/py1-5.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">print(math.ceil(2.2))// ceil : 소수점 이하를 올림</span><br><span class="line">print(math.floor(2.7))  // floor : 소수점 이하를 버림</span><br><span class="line">print(math.pow(2,10)) // 2^10, pow  : 제곱</span><br><span class="line">print(math.pi)// pi : 3.14</span><br></pre></td></tr></table></figure><p>math 모듈을 가져오고, 해당 모듈을 이용하여 위와 같은 연산을 실시할 수 있다.</p><p><img src="/image/py1-6.png"></p><hr><p><a name="3">3. 문자 및 문자열</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Hello&apos;)</span><br><span class="line">print(&quot;Hello&quot;)</span><br><span class="line">print(&quot;Hello &apos;world&apos;&quot;)</span><br><span class="line">print(&apos;Hello &quot;world&quot;&apos;)</span><br></pre></td></tr></table></figure><p><img src="/image/py1-7.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;Hello &apos;+&apos;world&apos;)   // 두 문자열을 합친 결과를 출력</span><br><span class="line">print(&apos;Hello &apos;*3)  // 해당 문자열을 3회 출력</span><br><span class="line">print(&apos;Hello&apos;[0])  // 해당 문자열(배열)의 특정 원소를 출력</span><br><span class="line">print(&apos;Hello&apos;[1])</span><br><span class="line">print(&apos;Hello&apos;[2])</span><br></pre></td></tr></table></figure><p><img src="/image/py1-8.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(&apos;hello world&apos;.capitalize())// 문자열의 첫 글자를 대문자로 변경</span><br><span class="line">print(&apos;hello world&apos;.upper())// 문자열이 모든 문자를 대문자로 변경</span><br><span class="line">print(&apos;hello world&apos;.__len__())// 문자열의 길이를 출력</span><br><span class="line">print(len(&apos;hello world&apos;))</span><br><span class="line">print(&apos;Hello world&apos;.replace(&apos;world&apos;, &apos;programming&apos;)) //특정 문자열을 다른 문자열로 변경</span><br></pre></td></tr></table></figure><p><img src="/image/py1-9.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;egoing&apos;s \&quot;tutorial\&quot;&quot;)// &quot;를 문자로서 출력하기 위해 \(escape)를 사용</span><br><span class="line">print(&quot;\\&quot;)// 첫번째 \은 뒤의 \의 임무(escape)를 해제</span><br><span class="line">print(&quot;Hello\nworld&quot;)// \: 줄바꿈</span><br><span class="line">print(&quot;Hello\t\tworld&quot;) // \t: 탭</span><br><span class="line">print(&quot;\a&quot;)// \a: 경고음을 출력</span><br><span class="line">print(&apos;Hello\nworld&apos;)</span><br></pre></td></tr></table></figure><p><img src="/image/py1-10.png"></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(10+5)// 수의 합을 출력</span><br><span class="line">print(&quot;10&quot;+&quot;5&quot;) // 문자열의 합을 출력</span><br></pre></td></tr></table></figure><p><img src="/image/py1-11.png"></p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“Python &amp; Ruby”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/1750/9612" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9612</a>, <a href="https://opentutorials.org/course/1750/9614" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9614</a>, <a href="https://opentutorials.org/course/1750/9615" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9615</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/python1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] GitHub (2)</title>
      <link>http://dudri63.github.io/2019/01/21/git12/</link>
      <guid>http://dudri63.github.io/2019/01/21/git12/</guid>
      <pubDate>Mon, 21 Jan 2019 02:36:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 원격 저장소 생성&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 원격 저장소에 push&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 원격 저장소 생성&lt;/a&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;i
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 원격 저장소 생성</a><br><a href="#2">2. 원격 저장소에 push</a></p><hr><p><a name="1">1. 원격 저장소 생성</a></p><div align="center"><br><img src="/image/git12-1.png"><br><br><img src="/image/git12-2.png"><br></div><ol><li>깃허브에 로그인한다.</li><li>new repository 버튼을 클릭한다.</li><li>저장소 이름을 설정한다.</li><li>public / private option을 설정한다.</li><li>readme (프로젝트에 대한 설명) 파일 생성 여부를 설정한다.</li><li>저장소를 생성한다.</li><li>https를 선택 및 저장소의 고유 주소를 확인한다.</li></ol><hr><p><a name="2">2. 원격 저장소에 push</a></p><p><img src="/image/git12-3.png"></p><p>$ git remote add ‘별명’ ‘경로’ 명령어를 실행하여 생성한 저장소 주소의 별명을 설정하고, 원격 저장소로서 설정한다.</p><p><img src="/image/git12-4.png"></p><p>$ git push ‘별명’ ‘branch 이름’ 명령어를 실행하여 origin이 가리키는 원격 저장소의 master branch에 현재 지역 저장소의 branch를 push한다.<br>-u : 서로 연결할 때, 최초 1회 사용한다. 이후에는 git push만 해도 위 설정대로 push하게 된다. </p><p><img src="/image/git12-5.png"></p><p>위 페이지와 같이 원격저장소에 성공적으로 push된 것을 알 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/2708/15426" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15426</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/git12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] GitHub (1)</title>
      <link>http://dudri63.github.io/2019/01/21/git11/</link>
      <guid>http://dudri63.github.io/2019/01/21/git11/</guid>
      <pubDate>Mon, 21 Jan 2019 01:49:56 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. GitHub란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. GitHub 둘러보기&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. GitHub 프로젝트 가져오기&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. GitHub란
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. GitHub란</a><br><a href="#2">2. GitHub 둘러보기</a><br><a href="#3">3. GitHub 프로젝트 가져오기</a></p><hr><p><a name="1">1. GitHub란</a></p><p><strong>‘깃허브(GitHub)’</strong>는 분산 버전 관리 툴인 <strong>깃</strong>을 사용하는 프로젝트를 지원하는 웹호스팅 서비스이다. 다른 말로, 자신의 서버를 직접 운영하지 않고도, 온라인 서비스를 이용하여 원격 저장소를 사용할 수 있게 해주는 웹 서비스이다.</p><hr><p><a name="2">2. GitHub 둘러보기(‘git’ project)</a></p><div align="center"><br><img src="/image/git11-1.png"><br></div><p>GitHub 홈페이지에서 git을 검색하여 git/git 항목으로 접속한다.<br>위와 같이 git이라는 오픈 소스 프로젝트의 원격 저장소를 볼 수 있다.<br>상위 리스트들의 수치가 의미하는 바는 다음과 같다.</p><ul><li>54,244 commits : 총 54,244번의 commit으로 현재까지 옴 (매우 큰 프로젝트)</li><li>5 branches : 5개의 branch가 있음</li><li>1240 contributors : 소스 코드에 접근하여 수정할 수 있는 인원</li><li>Fork 14,817 : 다른 사람들에 의해 fork한 횟수</li></ul><p>cf. fork 버튼을 누르면 이 프로젝트 나의 것이 된다. contributor에 속하지 않아도 코드를 수정할 수 있다. 그러나 해당 프로젝트의 소스 코드를 수정하는 것이 아니라, 나의 저장소로 복제된 코드를 수정하는 것이다. fork 숫자가 높을수록 높은 영향력을 지닌 개발자의 코드이다.</p><hr><p><a name="3">3. Github 프로젝트 가져오기</a></p><p>위 페이지에서 ‘Clone or download’라고 쓰인 초록색 버튼을 클릭하면, 주소가 나오는데 이를 복사한다.<br>이 후, 터미널에서 적당한 디렉토리로 이동한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone &apos;주소&apos; &apos;디렉토리 이름&apos;</span><br></pre></td></tr></table></figure></p><p>위와 같은 명령어를 실행하면 해당 디렉토리 이름으로 저장소를 만들고 그 곳의 주소가 가리키는 것들을 복사하여 저장한다.</p><div align="center"><br><img src="/image/git11-2.png"><br><br><img src="/image/git11-3.png"><br><br><img src="/image/git11-4.png"><br><br><img src="/image/git11-5.png"><br></div><p>gitsrc라는 저장소 생성 및 해당 저장소에 git 프로젝트를 복사하였다.<br>$git log 명령어를 실행하여 git 프로젝트의 commit history를 파악할 수 있다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --reverse// commit을 과거순으로 확인 가능</span><br></pre></td></tr></table></figure><p><div align="center"><br><img src="/image/git11-6.png"><br></div><br>$ git log –reverse 명령어를 실행하여 가장 상위에 있는 commit(최초의 commit) ID를 복사한다.</p><p><div align="center"><br><img src="/image/git11-7.png"></div></p><p><img src="/image/git11-8.png"><br><br>최초의 commit으로 checkout한 뒤, $ls -al 명령어를 실행하여 git 프로젝트의 최초 코드를 확인할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/2708/15426" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15426</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/git11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 최단 경로 찾기 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/21/algo13/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo13/</guid>
      <pubDate>Mon, 21 Jan 2019 01:26:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 최단 경로 찾기&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;1. 다익스트라 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;1. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;1. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a nam
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 최단 경로 찾기</a><br><a href="#1">1. 다익스트라 알고리즘</a><br><a href="#1">1. 시간 복잡도</a><br><a href="#1">1. 응용</a></p><hr><p><a name="1">1. 최단 경로 찾기</a></p><p><strong>최단 경로(Shortest Path)</strong> 문제는 주어진 가중치 그래프에서 어느 한 출발점에서 또 다른 도착점까지의 최단 경로를 찾는 문제이다. 최단 경로를 찾는 가장 대표적인 그리디 알고리즘은 <strong>다익스트라(Dijkstra)</strong> 최단 경로 알고리즘이다.</p><p>다익스트라 알고리즘은 <strong>프림의 최소 신장 트리 알고리즘</strong>과 거의 흡사한 과정으로 진행된다. 차이점은 다음과 같다.</p><ol><li>프림 알고리즘은 임의의 점에서 시작하지만, 다익스트라 알고리즘은 주어진 출발점에서 시작</li><li>프림 알고리즘은 트리에 하나의 점, 선분을 추가시킬 때 현재 상태의 트리에서 가장 가까운 점을 추가시키지만, 다익스트라 알고리즘은 <strong>출발점으로부터</strong> 최단거리가 확정되지 않은 점들 중 출발점으로부터 가장 가까운 점을 추가, 그 점의 최단 거리를 확정</li></ol><hr><p><a name="2">2. 다익스트라 알고리즘</a></p><p>다음은 다익스트라 최단 경로 알고리즘이다. 단, 입력 그래프는 양수의 가중치 그래프로서 하나의 연결요소로 되어 있다. 또한, s는 출발점이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ShortestPath(G, s)</span><br><span class="line">입력: 가중치 그래프 G=(V,E), |V|=n(점의 수), |E|=m(선분의 수)</span><br><span class="line">출력: 출발점 s로부터 (n-1)개의 점까지 각각 최단 거리르 저장한 배열 D</span><br><span class="line">배열 D를 ∞로 초기화한다. 단, D[s]=0으로 초기화한다. // 배열 D[v]에는 출발점 s로부터 점 v까지의 거리로 저장된다.</span><br><span class="line">while (s로부터의 최단 거리가 확정되지 않은 점이 있으면)&#123;</span><br><span class="line">  현재까지 s로부터 최단 거리가 확정되지 않은 각 점 v에 대해 최소의 D[v]의 값을 가진 점 vmin을 선택, 출발점 s로부터 vmin까지의 최단 거리 D[vmin]을 확정시킨다.</span><br><span class="line">  s로부터 현재보다 짧은 거리로 점 vmin을 통해 우회 가능한 각 점 w에 대해서 D[w]를 갱신한다.&#125;</span><br><span class="line">return D</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/algo13-1.png" width="300" height="auto"><br><img src="/image/algo13-2.png" width="300" height="auto"><br><img src="/image/algo13-3.png" width="300" height="auto"><br><img src="/image/algo13-4.png" width="300" height="auto"><br><img src="/image/algo13-5.png" width="300" height="auto"><br><img src="/image/algo13-6.png" width="300" height="auto"><br><img src="/image/algo13-7.png" width="300" height="auto"><br><img src="/image/algo13-8.png" width="300" height="auto"><br><img src="/image/algo13-9.png" width="300" height="auto"><br><img src="/image/algo13-10.png" width="300" height="auto"><br><img src="/image/algo13-11.png" width="300" height="auto"><br><img src="/image/algo13-12.png" width="300" height="auto"><br><img src="/image/algo13-13.png" width="300" height="auto"><br><img src="/image/algo13-14.png" width="300" height="auto"><br><img src="/image/algo13-15.png" width="300" height="auto"><br><img src="/image/algo13-16.png" width="300" height="auto"><br><img src="/image/algo13-17.png" width="300" height="auto"><br><img src="/image/algo13-18.png" width="300" height="auto"><br></div><p>위와 같이 서울에서부터 각 지역까지 최단 거리를 알 수 있다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>ShortestPath 알고리즘은 while-루프가 (n-1)번 반복되고, 1회 반복될 때 line 6에서 최소의 D[v]를 가진 점 vmin을 찾는 데 O(n) 시간이 걸린다.(입력만큼 비교)<br>또한 line 7에서 vmin에 연결된 점의 수가 최대 (n-1)개이므로, 각 D[w]를 갱신하는 데 걸리는 시간은 O(n이다.)<br>따라서 시간복잡도는 (n-1)X{O(n)+O(n)}=O(n<sup>2</sup>)이다.</p><hr><p><a name="4">4. 응용</a></p><p>최단 경로 알고리즘은 구글 웹사이트의 지도 서비스에서 사용된다.<br>또한, 자동차 네비게이션, 네트워크 및 통신 분야, 로봇 공학 등에 널리 활용된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, <a href="https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo13/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 최소 신장 트리 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/21/algo12/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo12/</guid>
      <pubDate>Sun, 20 Jan 2019 20:50:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 최소 신장 트리란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 크러스컬 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 크러스컬 알고리즘의 시간복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 프림 알고리즘&lt;/a&gt;&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 최소 신장 트리란</a><br><a href="#2">2. 크러스컬 알고리즘</a><br><a href="#3">3. 크러스컬 알고리즘의 시간복잡도</a><br><a href="#4">4. 프림 알고리즘</a><br><a href="#5">5. 프림 알고리즘의 시간복잡도</a><br><a href="#6">6. 응용</a></p><hr><p><a name="1">1. 최소 신장 트리란</a></p><p><strong>최소 신장 트리(Minimum Spanning Tree)</strong>란 주어진 가중치 그래프에서 사이클 없이 모든 점들을 연결시킨 트리들 중 선분들의 가중치 합이 최소인 트리이다.</p><div align="center"><br><img src="/image/algo12-1.png" width="700" height="500"><br></div><p>위 경우에서 (a)를 주어진 가중치 그래프라고 가정한다.<br>(점들끼리 연결된 선분들마다 가중치(숫자)가 다른 그래프이다.)</p><ul><li>(b) 최소 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 이러한 종류의 트리들 중 가중치의 합이 최소임.</li><li>(c) 신장 트리 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시킴. 단, 이러한 종류의 트리들 중 가중치의 합이 최소는 아님.</li><li>(d) 부분그래프 : 주어진 가중치 그래프에서 사이클 없이 모든 점을 연결시키지 못함.</li></ul><p>그래프의 점의 수가 n이면, 신장 트리에는 정확히 (n-1)개의 선분이 있다. 만일 (n-1)개의 선분보다 많다면, 반드시 사이클이 만들어져 신장 트리가 아니게 된다.</p><p>최소 신장 트리를 찾는 대표적인 그리디 알고리즘은 <strong>크러스컬(Kruskal)</strong>과 <strong>프림(prim)</strong> 알고리즘이다. </p><hr><p><a name="2">2. 크러스컬 알고리즘</a></p><p>다음은 크러스컬 알고리즘이다.<br>크러스컬 알고리즘은 가중치가 가장 적은 선분이 사이클을 만들지 않을 때에만 ‘욕심 내어’ 그 선분을 추가시킨다.<br>단, 알고리즘의 입력은 1개의 연결요소로 된 가중치 그래프이다.(<a href="#cf">cf. 연결요소</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">KruskalMST(G)</span><br><span class="line">입력: 가중치 그래프 G=(V,E), |V|=n (점의 수), |E|=m (선분의 수)</span><br><span class="line">출력: 최소 신장 트리 T</span><br><span class="line">가중치의 오름차순으로 선분들을 정렬한다. 정렬된 선분 리스트를 L이라고 하자.</span><br><span class="line">T=∅ // 트리 T를 초기화시킨다.</span><br><span class="line">while (T의 선분 수 &lt; n-1) &#123;</span><br><span class="line">  L에서 가장 작은 가중치를 가진 선분 e를 가져오고, e를 L에서 제거한다.</span><br><span class="line">  if (선분 e가 T에 추가되어 사이클을 만들지 않으면)</span><br><span class="line">    e를 T에 추가시킨다.</span><br><span class="line">  else// e가 T에 추라되어 사이클이 만들어지는 경우</span><br><span class="line">    e를 버린다.</span><br><span class="line">&#125;</span><br><span class="line">return 트리 T// 이 때, T는 최소 신장 트리이다.</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/algo12-10.png" width="500" height="auto"><br><img src="/image/algo12-11.png" width="400" height="auto"><br><img src="/image/algo12-12.png" width="400" height="auto"><br><img src="/image/algo12-13.png" width="400" height="auto"><br><img src="/image/algo12-14.png" width="400" height="auto"><br><img src="/image/algo12-15.png" width="400" height="auto"><br><img src="/image/algo12-16.png" width="400" height="auto"><br><img src="/image/algo12-17.png" width="400" height="auto"><br></div><hr><p><a name="3">3. 크러스컬 알고리즘의 시간복잡도</a></p><p>Line 4에서 선분들을 가중치를 기준으로 정렬하는데 O(mlogm)의 시간이 걸린다.<br>(이 때, m은 입력 그래프에 있는 선분의 수이다.)<br>Line 5에서는 T를 초기화하므로 O(1) 시간이 걸린다.<br>Line 6~11에서는 그래프의 선분을 검사하는데, 이 때, 선분의 수만큼 m번 수행된다.(최악의 경우)<br>또한, while-루프 내에서는 L로부터 가져온 e가 사이클을 만드는지를 검사하는데, O(log*m) 시간이 걸린다.<br>따라서 크러스컬 알고리즘의 시간복잡도는 O(mlogm)+O(mlog*m) = O(mlogm)이다.</p><hr><p><a name="4">4. 프림 알고리즘</a></p><p>다음은 프림 알고리즘이다.<br>프림 알고리즘은 주어진 가중치 그래프에서 임의의 점 하나를 선택한 후, (n-1)개의 선분을 하나씩 추가시켜 트리를 만든다. 현재까지 만들어진 트리에 새로운 선분을 추가하면서 연결시킬 때 ‘욕심 내어서’ 항상 최소의 가중치로 연결되는 선분을 추가시킨다.<br>단, 알고리즘의 입력은 1개의 연결요소로 된 가중치 그래프이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PrimMST(G)</span><br><span class="line">입력: 가중치 그래프 G=(V,E), |V|=n(점의 개수), |E|=m(선분의 개수)</span><br><span class="line">출력: 최소 신장 트리 T</span><br><span class="line">그래프 G에서 임의의 점 p를 시작점으로 선택, D[p]=0// D[v]는 T에 있는 점 u, v를 연결하는 선분의 최소 가중치를 저장</span><br><span class="line">for (점 p가 아닌 각 점 v에 대하여)&#123;// 배열 D의 초기화</span><br><span class="line">  if (선분 (p,v)가 그래프에 있으면)</span><br><span class="line">    D[v] = 선분 (p,v)의 가중치</span><br><span class="line">  else</span><br><span class="line">    D[v] = ∞</span><br><span class="line">&#125;</span><br><span class="line">T&#123;p&#125;// 초기에 트리 T는 점 p만을 가진다.</span><br><span class="line">while (T에 있는 점의 수 &lt; n) &#123;</span><br><span class="line">  T에 속하지 않은 각 점 v에 대하여, D[v]가 최소인 점 vmin과 연결된 선분 (u,vmin)을 T에 추가한다. 단, u는 T에 속한 점이고, 이 때 점 vmin도 T에 추가된다.</span><br><span class="line">  for (T에 속하지 않은 각 점 w에 대해서)&#123;</span><br><span class="line">    if (선분(vmin, w)의 가중치 &lt; D[w])</span><br><span class="line">      D[w] = 선분 (vmin, w)의 가중치// D[w]를 갱신한다.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return T</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/algo12-3.png" width="400" height="auto"><br></div><p>위 그림에 프림 알고리즘을 적용한다.</p><ul><li>Line 4: 임의로 점 c를 선택, D[c]=0<div align="center"><br><img src="/image/algo12-4.png" width="400" height="auto"><br></div></li><li>Line 5~9: 시작점 c와 선분으로 연결된 각 점 v에 대해 D[v]를 각 선분의 가중치로 초기화, 나머지 각 점 w에 대해 D[w]는 ∞로 초기화<br>D[a]=∞, D[b]=1, D[c]=0, D[d]=∞, D[e]=∞, D[f]=1</li><li>Line 10: T={c}로 초기화</li><li>Line 11: 현재 T에는 점 c만 있으므로 루프 조건 ‘참’</li><li>Line 12: T에 속하지 않은 각 점 v에 대해 D[v]가 최소인 점 vmin을 선택. 단, 이 경우, D[b]=D[f]=1로서 최소값이므로 점 b나 점 f 중 하나를 선택. 점 b를 선택한 상황을 가정한다. 점 b와 선분 (c,b)를 T에 추가<br>T={c, b, (c,b)}<div align="center"><br><img src="/image/algo12-5.png" width="400" height="auto"><br></div></li><li>Line 13~15: 점 b에 연결된 점 a와 d의 D[a]와 D[b]를 각각 3, 4로 갱신. 점 f는 점 b와 선분으로 연결되어 있으나 선분 (b,f)의 가중치인 2가 현재 D[f]=1보다 크므로 D[f]를 갱신 안함<br>D[a]=3, D[b]=1, D[c]=∞, D[d]=4, D[e]=∞, D[f]=1<div align="center"><br><img src="/image/algo12-6.png" width="300" height="auto"><br></div></li><li>Line 11: 루프 조건 ‘참’</li><li>Line 12: T에 속하지 않은 각 점 v에 대해 vmin인 점 f를 찾고, 점 f와 선분 (c,f)를 T에 추가<br>T={c, b, f, (c,b), (c,f)}</li><li>Line 13~15: 점 f에 연결된 점 e의 D[e]=9로 갱신. D[d]는 선분 (f,d)=7보다 작아서 if 조건문을 만족하지 못하므로 제외<br>D[a]=∞, D[b]=1, D[c]=0, D[d]=∞, D[e]=9, D[f]=1<div align="center"><br><img src="/image/algo12-7.png" width="600" height="auto"><br><img src="/image/algo12-8.png" width="600" height="auto"><br><img src="/image/algo12-9.png" width="600" height="auto"><br></div></li><li>Line 11~15 과정을 반복한다.</li><li>Line 16 : T를 리턴한다.</li></ul><p>프림 알고리즘은 항상 T 밖에 있는 점을 추가하므로 사이클을 만들지 않는다.</p><hr><p><a name="5">5. 프림 알고리즘의 시간 복잡도</a></p><p>프림 알고리즘은 while-루프가 (n-1)번 반복, 1회 반복될 때 line 9에서 T에 속하지 않은 각 점 v에 대해 vmin을 찾는 데 O(n) 시간이 걸린다. 따라서 프림 알고리즘의 시간복잡도는 (n-1)XO(n) = O(n<sup>2</sup>)이다.</p><hr><p><a name="6">6. 응용 </a></p><p>최소 신장 트리 알고리즘은 최소 비용으로 선로 또는 파이프 네트워크를 설치하는 데 활용되며, 여행자 문제를 근사적으로 해결하는 데 이용된다.</p><hr><p><a name="cf">cf. 연결요소</a></p><p><img src="/image/algo12-2.png" width="300" height="auto"><br>1개의 연결요소로 된 그래프</p><p><img src="/image/algo12-3.jpeg" width="400" height="auto"><br>2개의 연결요소로 된 그래프</p><hr><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“4장그리디알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, <a href="https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=4%C0%E5%B1%D7%B8%AE%B5%F0%BE%CB%B0%ED%B8%AE%C1%F2-0.pptx&amp;kid=</a></li><li>“6장 그래프 - (3) 그래프 탐색 문제1 - 연결 요소(11724번)”, 살구의 개발자 첫걸음을 위한 , 2019. 1. 21, <a href="http://salguru.tistory.com/" rel="external nofollow noopener noreferrer" target="_blank">http://salguru.tistory.com/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo12/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 동전 거스름돈 (그리디)</title>
      <link>http://dudri63.github.io/2019/01/21/algo11/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo11/</guid>
      <pubDate>Sun, 20 Jan 2019 19:59:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 동전 거스름돈 문제란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 동전 거스름돈 알고리즘&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 동전 거스름돈 문제란&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;거스름돈을 동전으로 받아야 할 때,
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 동전 거스름돈 문제란</a><br><a href="#2">2. 동전 거스름돈 알고리즘</a></p><hr><p><a name="1">1. 동전 거스름돈 문제란</a></p><p>거스름돈을 동전으로 받아야 할 때, 누구나 적은 수의 동전을 거스름돈으로 받기를 원한다고 가정한다.<br>동전 거스름돈 문제를 해결하는 가장 간단하고 효율적인 방법은 남은 액수를 초과하지 않는 조건하에 ‘욕심내어’ 가장 큰 액면의 동전을 취하는 것이다.</p><hr><p><a name="2">2. 동전 거스름돈 알고리즘</a></p><p>다음은 동전 거스름돈 문제의 최소 동전 수를 찾는 그리디 알고리즘이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CoinChange(W)</span><br><span class="line">입력: 거스름돈 액수 W</span><br><span class="line">출력: 거스름돈 액수에 대한 최소 동전 수</span><br><span class="line">change=W, n500=n100=n50=n10=n1//n500, n100, n50, n10, n1은 각각의 동전수를 위한 변수</span><br><span class="line">while(change&gt;=500) change=change-500, n500++//500원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=100) change=change-100, n100++//100원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=50)  change=change-50, n50++//50원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=10)  change=change-10, n10++//10원짜리 동전수를 증가</span><br><span class="line">while(change&gt;=1)   change=change-1, n1++//1원짜리 동전수를 증가</span><br><span class="line">return (n500+n100+n50+n10+n1)//총 동전수를 반환</span><br></pre></td></tr></table></figure><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 그리디 알고리즘</title>
      <link>http://dudri63.github.io/2019/01/21/algo10/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo10/</guid>
      <pubDate>Sun, 20 Jan 2019 19:49:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;그리디(Greedy) 알고리즘&lt;/strong&gt;은 최적화 문제를 해결하는 알고리즘이다. &lt;strong&gt;최적화(Optimization)&lt;/strong&gt; 문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>그리디(Greedy) 알고리즘</strong>은 최적화 문제를 해결하는 알고리즘이다. <strong>최적화(Optimization)</strong> 문제는 가능한 해들 중에서 가장 좋은(최대 또는 최소) 해를 찾는 문제이다.</p><p>그리디 알고리즘은 입력 데이터 간의 관계를 고려하지 않고 수행 과정에서 최솟값 또는 최댓값을 가진 데이터를 선택한다. 이러한 선택을 ‘근시안적’인 선택이라고도 하는데, 그리디 알고리즘은 근시안적인 선택으로 부분적인 최적해를 찾고, 이들을 모아서 문제의 최적해를 얻는다.</p><p>또한, 그리디 알고리즘은 일단 한번 선택하면, 이를 절대로 번복하지 않는다.</p><p>위와 같은 그리디 알고리즘의 특징들 때문에 그리디 알고리즘은 매우 단순하며 제한적인 문제들만이 그리디 알고리즘으로 해결이 가능하다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 주의할 점 (분할정복)</title>
      <link>http://dudri63.github.io/2019/01/21/algo9/</link>
      <guid>http://dudri63.github.io/2019/01/21/algo9/</guid>
      <pubDate>Sun, 20 Jan 2019 19:33:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;분할 정복은 분활된 부분문제의 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우 사용기하게 부적절하다.&lt;br&gt;예를 들어, 피보나치 수를 구할 때, F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 한다고 가정한다. 그러나
        
      
      </description>
      
      <content:encoded><![CDATA[<p>분할 정복은 분활된 부분문제의 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우 사용기하게 부적절하다.<br>예를 들어, 피보나치 수를 구할 때, F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 한다고 가정한다. 그러나 이 경우는 n이라는 숫자로 인해 2개의 부분문제인 F(n-1), F(n-2)이 만들어지고, 입력의 크기의 합이 (n-1) + (n-2)가 되어 분할 후 입력의 총 크기가 거의 2배가 된다.</p><p><div align="center"><br><img src="/image/algo9-1.png" width="400" height="500"><br></div><br>위와 같이 6의 피보나치 수를 구할 때, 분할 정복을 사용하면, 중복되는 부분문제들이 생겨서 오히려 총 소요 시간이 증가함을 알 수 있다.</p><p>피보나치 수와 같은 경우에는 분할 정복(재귀 호출)을 사용하지 않고, for-루프를 사용하는 것이 더욱 효율적이다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FiboNumber(n)</span><br><span class="line">F[0]=0</span><br><span class="line">F[1]=1</span><br><span class="line">for i=2 to n</span><br><span class="line">  F[i] = F[i-1] + F[i-2]</span><br></pre></td></tr></table></figure></p><p>위와 같은 알고리즘을 사용하면, 루프의 수행 횟수로서 시간복잡도가 O(n)이 된다.</p><p>주어진 문제를 분할 정복 알고리즘으로 해결하려고 하라 때 중의해야 하는 점 중 다른 하나는 취합 과정이다. 입력을 분할 한다고 해서 효율적인 알고리즘이 만들어지는 것은 아니다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“3장분할정복알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 21, <a href="https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=3%C0%E5%BA%D0%C7%D2%C1%A4%BA%B9%BE%CB%B0%ED%B8%AE%C1%F2%20-%200.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/algo9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] 원격 저장소(Remote Repository)</title>
      <link>http://dudri63.github.io/2019/01/21/git10/</link>
      <guid>http://dudri63.github.io/2019/01/21/git10/</guid>
      <pubDate>Sun, 20 Jan 2019 15:34:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 원격 저장소란&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;1. 원격 저장소 생성&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 원격 저장소란&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;원격 저장소(Remote Reposito
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 원격 저장소란</a><br><a href="#1">1. 원격 저장소 생성</a></p><hr><p><a name="1">1. 원격 저장소란</a></p><p><strong>원격 저장소(Remote Repository)</strong>란 흔히 <strong>지역 저장소(Local Repository)</strong>와 구별되는 개념이다.</p><p>자신의 컴퓨터에서 작업하고 commit하면 저장되는 곳이 지역 저장소이다. 그런데, 작업물들을 인터넷에 올려서 백업을 하거나 다른 사람들과 협업을 할 경우, 컴퓨터와 연결된 다른 저장소가 필요하다.</p><p>원격 저장소의 역할은 크게 다음과 같다.</p><ul><li>협업</li><li>백업</li></ul><p>일반적으로 원격 저장소는 같은 컴퓨터에 연결되어 있지 않고, 인터넷을 통하여 다른 컴퓨터와 연결되어 있다. 원격 저장소는 프로젝트가 커지는 과정에서 굉장히 중요한 역할을 한다. 그러나 혼자서 프로젝트를 진행할 때에는 원격 저장소가 필요한 일은 많지 않다. 주로, dropbox 등과 같은 서비스를 이용한다.</p><hr><p><a name="2">2. 원격 저장소 생성</a></p><p>앞서 이야기하였듯이, 원격 저장소는 주로 인터넷을 통해 연결, 같은 컴퓨터 안에 있지 않는다. 그러나 원격 저장소 개념을 알기 위하여 본 포스팅에서는 한 대의 컴퓨터, 다른 디렉토리에 원격 저장소를 생성, 원격 저장소에 commit할 것이다.</p><p><img src="/image/git10-1.png" width="700" height="auto"></p><p><img src="/image/git10-2.png" width="700" height="auto"></p><p>위와 같이 gitfth2 디렉토리에 ‘local’이라는 이름의 저장소를 생성한다. 이 후, f1.txt를 add하고 commit한다.<br>(local 이름의 저장소를 지역 저장소라고 가정한다.)</p><p><img src="/image/git10-3.png" width="700" height="auto"></p><p>gitfth2 디렉토리에 또 다른 저장소 ‘remote’를 생성한다.<br>(remote 이름의 저장소를 원격 저장소라고 가정한다.)</p><hr><p>cf.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init --bare &apos;저장소 이름&apos;// 작업이 불가능, 저장만 가능한 저장소를 생성</span><br></pre></td></tr></table></figure></p><p>remote 저장소는 –bare option을 적용하였기 때문에 .git 디렉토리가 내부에 존재하지 않고 위와 같은 파일들이 존재한다.<br>원격 저장소는 일반적으로 작업을 하지 않고, 저장만 하는 경우가 많다.</p><hr><p><img src="/image/git10-4.png" width="700" height="auto"></p><hr><p>cf.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add &apos;별명&apos; &apos;경로&apos;// 경로에 있는 디렉토리를 별명으로 설정 및 원격저장소로 연결</span><br><span class="line">$ git remote -v // 연결된 저장소 및 별명을 파악할 수 있음</span><br><span class="line">$ git remote remove &apos;별명&apos;// 연결된 원격원격소를 제거</span><br></pre></td></tr></table></figure></p><p>별명을 설정하는 이유는 항상 경로를 입력하기가 불편하기 때문이다.<br>같은 경로에 대하여 별명을 여러 개 설정할 수도 있다.</p><hr><p>위와 같이 remote 디렉토리를 origin이라는 별명으로 하여 원격저장소로서 연결한다.</p><p><img src="/image/git10-5.png" width="700" height="auto"></p><hr><p>cf.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git push // 현재 저장소의 현재 branch를 연결시킨 원격 저장소에 upload</span><br><span class="line">$ git config --global push.default.simple// git의 push 형식을 simple 방식으로 설정</span><br><span class="line">$ git push --set-upstream origin master // 현재 branch를 origin의 master branch로 push</span><br><span class="line">// 또한, 앞으로 git push할 경우 위와 같이 psuh하겠음을 설정</span><br></pre></td></tr></table></figure></p><hr><p><img src="/image/git10-6.png" width="700" height="auto"></p><p><img src="/image/git10-7.png" width="700" height="auto"></p><p>remote 디렉토리에서 확인하면, push가 잘 되었음을 알 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 21, <a href="https://opentutorials.org/course/2708/15395" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15395</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/21/git10/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (4)</title>
      <link>http://dudri63.github.io/2019/01/20/git9/</link>
      <guid>http://dudri63.github.io/2019/01/20/git9/</guid>
      <pubDate>Sun, 20 Jan 2019 14:23:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git branch -d, -D&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Branch 병합 시 충돌 해결&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. $ git branch -d, -D&lt;/a&gt;&lt;/p&gt;
&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git branch -d, -D</a><br><a href="#2">2. Branch 병합 시 충돌 해결</a></p><hr><p><a name="1">1. $ git branch -d, -D</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &apos;branch name&apos; // 해당 branch를 제거</span><br><span class="line">$ git branch -D &apos;branch name&apos;// 강제로 해당 branch를 제거</span><br></pre></td></tr></table></figure><hr><p><a name="2">2. Branch 병합 시 충돌 해결</a></p><p>2.1 충돌이 일어나지 않는 경우</p><p><img src="/image/git9-1.png" width="700" height="auto"></p><p>위와 같이 master, exp branch가 있고, 각각의 branch에서 master.txt, exp.txt가 commit된 상태임을 가정한다.</p><p><img src="/image/git9-2.png" width="700" height="auto"></p><p><img src="/image/git9-3.png" width="700" height="auto"></p><p><img src="/image/git9-4.png" width="700" height="auto"></p><p><img src="/image/git9-5.png" width="700" height="auto"></p><p>master branch에서 $ git merge exp 명령어를 실행하면, master branch에서 exp branch를 병합하는 새로운 commit이 생성된 것을 확인할 수 있다. 또한, ls -al 명령을 실행하면, 새로 생긴 commit은 master.txt, exp.txt를 모두 포함하는 것을 확인할 수 있다.<br>이것은 branch 병합시 충돌이 일어나지 않는 경우인데, 병합 시, 공통된 이름의 파일이 존재하지 않았기 깨문에 가능한 것이다.</p><p>다음은 또다른 상황을 가정한다.</p><p><img src="/image/git9-6.png" width="700" height="auto"></p><p><img src="/image/git9-7.png" width="700" height="auto"></p><p>master branch, exp branch에 모두 common.txt가 있는데, 위와 같이 각각의 common.txt의 내용은 다를 경우를 가정한다.<br>(첫 번째 이미지가 master branch의 common.txt, 두 번째 이미지가 exp branch의 common.txt이다.)</p><p><img src="/image/git9-8.png" width="700" height="auto"></p><p><img src="/image/git9-9.png" width="700" height="auto"></p><p>$ git merge master 명령어를 실행하면, 위와 같이 충돌 없이 두 branch가 병합되었음을 알 수 있다. 또한, $ cat 명령어를 이용하여 확인하면, common.txt에 function a, b, c가 모두 포함되어 있음을 확인할 수 있다.<br>서로 다른 branch에 같은 이름의 파일이 존재하고, 각 파일들은 서로 다른 내용을 포함하고 있지만 충돌없이 병합할 수 있는 경우이다.</p><p>2.2 충돌이 일어나는 경우</p><p><img src="/image/git9-10.png" width="700" height="auto"></p><p><img src="/image/git9-11.png" width="700" height="auto"></p><p>위와 같이 master branch와 exp branch의 common.txt라는 같은 이름의 파일이 존재하지만, 그 내용이 각각 다른 경우를 가정한다.</p><p><img src="/image/git9-12.png" width="700" height="auto"></p><p>master branch에서 $ git merge exp 명령어를 실행하면, Conflict가 발생한다. 구체적으로, $ git status 명령어를 실행하면, common.txt가 서로 다른 branch에서 both modified되었기 때문에 conflict가 발생하여 merge에 실패하였음을 확인할 수 있다.</p><p><img src="/image/git9-13.png" width="700" height="auto"></p><p><img src="/image/git9-14.png" width="700" height="auto"></p><p>common.txt를 텍스트 편집기를 이용하여 불러오면, 위와 같이 텍스트 내용이 변경되었음을 확인할 수 있다.<br>=======를 구분자로 하여 구분자를 중심으로 위 쪽은 현재 checkout한 branch인 master의 충돌 요인, 아래 쪽은 exp의 충돌 요인을 확인할 수 있다.</p><p>2.3 충돌 해결 방법</p><p><img src="/image/git9-15.png" width="700" height="auto"></p><p><img src="/image/git9-16.png" width="700" height="auto"></p><p><img src="/image/git9-17.png" width="700" height="auto"></p><p><img src="/image/git9-18.png" width="700" height="auto"></p><p>위와 같은 상황에서 common.txt를 위와 같이 수정한다.<br>(구분자를 비롯하여 나머지 부분들은 삭제한다.)<br>이 후, common.txt를 add, commit하면 충돌 없이 병합할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15275" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15275</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (3)</title>
      <link>http://dudri63.github.io/2019/01/20/git8/</link>
      <guid>http://dudri63.github.io/2019/01/20/git8/</guid>
      <pubDate>Sun, 20 Jan 2019 13:53:07 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;작업을 분기한 뒤, 각자의 history들을 이어가다가 병합할 필요성이 있을 수 있다.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>작업을 분기한 뒤, 각자의 history들을 이어가다가 병합할 필요성이 있을 수 있다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &apos;branch name&apos;</span><br></pre></td></tr></table></figure></p><p>이럴 경우, $ git merge ‘branch name’ 명령어를 실행하면 현재 chekcout되어 있는 branch에서 명령어에 함께 입력한 branch의 버전 정보들을 포함하는 새로운 commit이 생성된다.</p><div align="center"><br><img src="/image/git8-1.png" width="700" height="auto"><br></div><p>현재 저장소에 2 version에서 5 version으로 진행된 master branch, 3,4 version으로 진행된 exp branch가 있다고 가정한다.</p><div align="center"><br><img src="/image/git8-2.png" width="700" height="auto"><br><br><img src="/image/git8-3.png" width="700" height="auto"><br><br><img src="/image/git8-4.png" width="700" height="auto"><br><br><img src="/image/git8-5.png" width="700" height="auto"><br></div><p>master branch에서 $ git merge exp 명령어를 실행하면, commit message를 작성하는 화면이 나온다. 이 때, commit message를 작성 완료한 뒤, $ git log –branches 명령어를 실행하면, master branch에서 각 branch의 최신 commit들을 병합한 새로운 commit이 생성되었음을 확인할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15261" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15261</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (2)</title>
      <link>http://dudri63.github.io/2019/01/20/git7/</link>
      <guid>http://dudri63.github.io/2019/01/20/git7/</guid>
      <pubDate>Sun, 20 Jan 2019 13:05:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git log –branches –decorate&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git log –branches –decorate –graph&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. $ git lo
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git log –branches –decorate</a><br><a href="#2">2. $ git log –branches –decorate –graph</a><br><a href="#3">3. $ git log –branches –decorate –graph –oneline</a><br><a href="#4">4. $ git log ‘branch name a’..’branch name b’</a></p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a name=&quot;1&quot;&gt;1. $ git log --branches --decorate&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">$ git log --branches --decorate</span><br></pre></td></tr></table></figure><p>기본적으로 $ git log 명령어는 현재 속해있는 branch의 버전 history만을 출력한다. 그러나 –branches 옵션을 추가로 실행하면, 현재 checkout되어 있는 branch 뿐만 아니라 저장소에 속해있는 모든 branches의 버전 정보들을 출력한다.</p><div align="center"><br><img src="/image/git7-1.png" width="700" height="auto"><br><br><img src="/image/git7-2.png" width="700" height="auto"><br></div><p>master의 최신 commit이 2, exp의 최신 commit이 4, 현재 checkout된 branch는 exp임을 알 수 있다.</p><hr><p><a name="2">2. $ git log –branches –decorate –graph</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --branches --decorate --graph</span><br></pre></td></tr></table></figure><p>–graph 옵션을 추가로 실행하면, 버전이 진행된 것을 도형(선)으로 나타내어 효율적으로 버전 정보들을 파악할 수 있다.</p><div align="center"><br><img src="/image/git7-3.png" width="700" height="auto"><br><br><img src="/image/git7-4.png" width="700" height="auto"><br></div><p>위와 같이 graph가 나타나 효율적으로 버전 histories를 파악할 수 있다. 2 version에서 exp branch는 3,4 version으로 차례대로 변화, master branch는 5 version으로 변화하였음을 알 수 있다.</p><hr><p><a name="3">3. $ git log –branches –decorate –graph –oneline</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --branches --decorate --graph --oneline</span><br></pre></td></tr></table></figure><p>더 간결하게 histories를 graph로 나타낸다.</p><div align="center"><br><img src="/image/git7-5.png" width="700" height="auto"><br></div><hr><p><a name="4">4. $ git log ‘branch name a’..’branch name b’</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log &apos;branch name a&apos;..&apos;branch name b&apos;</span><br></pre></td></tr></table></figure><p>위 명령어는 branch name a에는 없는 branch name b의 commit들을 전시한다.</p><div align="center"><br><img src="/image/git7-6.png" width="700" height="auto"><br></div><p>master branch에는 없는 exp branch들의 commit들을 나타내었다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15261" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15261</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Branch (1)</title>
      <link>http://dudri63.github.io/2019/01/20/git6/</link>
      <guid>http://dudri63.github.io/2019/01/20/git6/</guid>
      <pubDate>Sun, 20 Jan 2019 11:58:30 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Git을 쓰는 이유&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git branch, $ git checkout ‘branch name’&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Git을 쓰는 이유&lt;/a
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Git을 쓰는 이유</a><br><a href="#2">2. $ git branch, $ git checkout ‘branch name’</a></p><hr><p><a name="1">1. Git을 쓰는 이유</a></p><p>예를 들어, report.xsl file을 버전 관리한다고 가정한다.<br>파일 내용이 변경될 때마다 새로운 이름으로 저장한다. report1.xsl, report2.xsl, ….<br>그런데, 순차적으로 수정이 되다가 경우에 따라서 나뉘어서 수정될 수 있다.<br>고객용으로 수정되면, report2_client.xsl으로 파일 이름을 저장할 수 있다.<br>그리고, 고객용이 아니라 또 다시 내용 변경되면, report3.xsl으로 파일 이름을 저장할 수 있다.<br>이렇게 나뉘어서 버전이 증가하다가, 다시 합쳐지는 경우도 있음.</p><div align="center"><br><img src="/image/git6-1.png" width="700" height="auto"><br></div><p>위와 같이 버전 관리를 할 경우, 파일 이름을 변경해야 하는데, 작업이 분기되거나 합쳐질 경우, 매우 복잡하다.<br><strong>git</strong>을 쓰면 위와 같이 과정을 쉽고, 세련되게 할 수 있다.</p><hr><p><a name="2">2. $ git branch, $ git checkout ‘branch name’</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch// 현재 저장소의 branch들, 현재의 branch</span><br><span class="line">$ git branch &apos;branch name&apos;// 새로운 branch 생성</span><br><span class="line">$ git checkout &apos;branch name&apos;// 해당 branch로 이동</span><br></pre></td></tr></table></figure><p>$ git branch 명령어를 실행하면 현재 저장소의 모든 branch들과 함께 현재 속해 있는 branch가 무엇인지 알 수 있다.<br>$ gir branch ‘branch name’ 명령어를 실행하면 해당 name의 새로운 branch가 생성된다.<br>$ git checkout ‘branch name’ 명령어를 입력하면 해당 branch로 이동한다.</p><div align="center"><br><img src="/image/git6-2.png" width="700" height="auto"><br></div><p>기본적으로 저장소에는 master branch가 존재한다. $ git branch 명령어를 실행하면, master branch가 있음을 알 수 있고, $ git branch exp 명령어를 실행하여 새로운 branch exp를 만든 뒤, $ git checkout exp 명령어를 실행하여 exp branch로 이동하였다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15260" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15260</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Reset, Command</title>
      <link>http://dudri63.github.io/2019/01/20/git5/</link>
      <guid>http://dudri63.github.io/2019/01/20/git5/</guid>
      <pubDate>Sun, 20 Jan 2019 11:25:27 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git reset&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git commit –help, -a, -m&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. $ git reset&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;버전 관리
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git reset</a><br><a href="#2">2. $ git commit –help, -a, -m</a></p><hr><p><a name="1">1. $ git reset</a></p><p>버전 관리 시스템에서 <strong>과거로 돌아가기</strong>란 commit을 취소하는 것을 의미한다. Git에서 과거로 돌아가는 방법에는 크게 2가지가 있다.</p><ul><li>reset</li><li>revert</li></ul><p>과거로 돌아가는 작업은 상당히 위험한 작업이며, 프로젝트 폴더 전체를 copy한 뒤, 위험한 작업을 실시하는 것이 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &apos;Commit ID&apos; --hard// Commit ID version이 최신이 됨</span><br><span class="line">$ git revert // Commit을 취소하면서 새로운 버전을 생성</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/git5-1.png" width="700" height="auto"><br><br><img src="/image/git5-2.png" width="700" height="auto"><br></div><p>$ git reset 명령어 뒤에 3 commit ID를 붙여서 실행하였더니, 이 후에 버전들은 삭제되고, 3 commit이 최신 버전이 된 것을 확인할 수 있다.<br>(실제로 이후에 버전들이 삭제된 것은 아니다. Git은 특별한 경우를 제외하고는 버전에 관한 정보들을 삭제하지 않는다.)</p><p>원격 저장소에 협업을 할 경우, 자신의 버전을 공유할 수 있다. 이 때, 공유한 이후에는 reset를 하면 안되고, reset은 local 저장소에서만 사용하도록 한다.</p><hr><p><a name="2">2. $ git commit –help, -a, -m</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --help // commit에 대한 도움말을 볼 수 있다.</span><br><span class="line">$ git commit -a, --all // 수정하거나 삭제한 파일을 자동으로 stage에 올린다.</span><br><span class="line">$ git commit -m, --message// commit message를 바로 쓴다.</span><br></pre></td></tr></table></figure><p>cf.<br>$ git commit -a : 자동으로 변경된 파일을 add시킨다. 그러나 이전에 한번도 add하지 않은 파일에 대해서는 add하지 않는다. 즉, 파일을 생성하면 최초 1회는 $ git add 명령어를 사용하여야 한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 20, <a href="https://opentutorials.org/course/2708/15210" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15210</a>, <a href="https://opentutorials.org/course/2708/15211" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15211</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Commit ID, Diff</title>
      <link>http://dudri63.github.io/2019/01/20/git4/</link>
      <guid>http://dudri63.github.io/2019/01/20/git4/</guid>
      <pubDate>Sun, 20 Jan 2019 10:22:19 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Commit ID&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git diff&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Commit ID&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;각각의 commit들은 고유한 ID가 있다.&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Commit ID</a><br><a href="#2">2. $ git diff</a></p><hr><p><a name="1">1. Commit ID</a></p><p>각각의 commit들은 고유한 ID가 있다.<br>git log 명령어를 실행하였을 때 나오는 매우 긴 노란쌕 문자열이 고유 ID다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log &apos;commit ID&apos;// 해당 commit을 포함하여 이전의 history들만을 출력</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/git4-1.png" width="700" height="auto"><br></div><p>위와 같이 $ git log 명령어 뒤에 commit ID를 붙이면, 그 commit을 포함하여 이전의 history들만을 화면에 출력한다. </p><hr><p><a name="2">2. $ git diff</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git diff &apos;commit ID A&apos;..&apos;commit ID B&apos;// 두 개의 commit 사이의 차이점 출력</span><br><span class="line">$ gii diff// 마지막 commit으로부터 변경된 점 출력</span><br></pre></td></tr></table></figure><p>$ git diff ‘commit ID A’..’commit ID B’ 명령어를 입력하면 두 개의 commit 사이의 차이점을 보여준다.</p><div align="center"><br><img src="/image/git4-2.png" width="700" height="auto"><br></div><br>f1.txt의 경우, ID A에서는 그 내용이 ‘f1.txt : 4’, ID B에서는 그 내용이 ‘source : 2’이었음을 알 수 있다.<br>f2.txt의 경우, ID A에서는 그 내용이 ‘source : 2’, ID B에서는 해당 파일이 없었음을 알 수 있다.<br><br>$ git diff 명령어를 실행하면, 마지막 commit으로부터 변경된 점을 출력한다.<br>(단, 변경사항을 git add하여 stage area로 이동시키면, 출력하지 않는다.)<br><div align="center"><br><img src="/image/git4-3.png" width="700" height="auto"><br><br><img src="/image/git4-4.png" width="700" height="auto"><br><br><img src="/image/git4-5.png" width="700" height="auto"><br></div><p>f1.txt, f2.txt를 수정한 뒤, add하기 전에 $ git diff 명령어를 실행했을때의 결과는 위와 같다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 19, <a href="https://opentutorials.org/course/2708/15202" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15202</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Setting, Commit, Log</title>
      <link>http://dudri63.github.io/2019/01/20/git3/</link>
      <guid>http://dudri63.github.io/2019/01/20/git3/</guid>
      <pubDate>Sat, 19 Jan 2019 15:31:03 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Setting&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git commit&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. $ git log&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Setting&lt;/a&gt;&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Setting</a><br><a href="#2">2. $ git commit</a><br><a href="#3">3. $ git log</a></p><hr><p><a name="1">1. Setting</a></p><p>Git을 처음 쓰는 거라면, 앞으로 만들 버전이 내가 만들었음을 알리기 위하여 name, email을 setting한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;이름&quot;</span><br><span class="line">$ git config --global user.email &quot;이메일 주소&quot;</span><br><span class="line">$ git config --list// 입력한 사용자 정보 조회</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/git3-1.png" width="700" height="auto"><br></div><hr><p><a name="2">2. $ git commit</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit// 버전 생성</span><br></pre></td></tr></table></figure><p><strong>git commit</strong> 명령어를 실행하면, add한 파일들에 한하여 해당 버전에 추가한다.<br>또한, git commit 명령어를 실행하면, commit message를 작성할 수 있는데, commit message에는 어떠한 변화가 있는지 혹은 변화의 이유에 대하여 작성하도록 한다.</p><p>파일에 대하여 commit하고 싶으면 반드시 이전에 add하여야 한다. </p><h5 id="cf"><a href="#cf" class="headerlink" title="cf."></a>cf.</h5><h5 id="버전-의미-있는-변화-완성된-코드-단위"><a href="#버전-의미-있는-변화-완성된-코드-단위" class="headerlink" title="버전 : 의미 있는 변화, 완성된 코드 단위"></a>버전 : 의미 있는 변화, 완성된 코드 단위</h5><h5 id="git-add-commit-대기-상태에-들어가게-한다"><a href="#git-add-commit-대기-상태에-들어가게-한다" class="headerlink" title="git add : commit 대기 상태에 들어가게 한다."></a>git add : commit 대기 상태에 들어가게 한다.</h5><h5 id="git-commit-commit-대기-상태에-있는-파일들만-해당-버전에-추가한다"><a href="#git-commit-commit-대기-상태에-있는-파일들만-해당-버전에-추가한다" class="headerlink" title="git commit : commit 대기 상태에 있는 파일들만 해당 버전에 추가한다."></a>git commit : commit 대기 상태에 있는 파일들만 해당 버전에 추가한다.</h5><h5 id="commit-대기-상태-stage-area에-올린다"><a href="#commit-대기-상태-stage-area에-올린다" class="headerlink" title="commit 대기 상태 : stage area에 올린다."></a>commit 대기 상태 : stage area에 올린다.</h5><div align="center"><br><img src="/image/git3-2.png" width="700" height="auto"><br><br><img src="/image/git3-3.png" width="700" height="auto"><br><br><img src="/image/git3-4.png" width="700" height="auto"><br></div><hr><p><a name="3">3. $ git log</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log// 버전 생성이 되었는지 확인 가능</span><br><span class="line">$ git log -p // 각 commit 사이의 소스상 차이점을 파악할 수 있음</span><br></pre></td></tr></table></figure><p><strong>git log</strong> 명령어를 실행하면, 각 버전들의 verseion message, author, date 등을 확인할 수 있다.(version history를 파악할 수 있음)</p><p><div align="center"><br><img src="/image/git3-5.png" width="700" height="auto"><br></div><br>$ git log 명령어를 입력하면 각 commit들의 정보를 파악할 수 있다.</p><p><div align="center"><br><img src="/image/git3-6.png" width="700" height="auto"><br><img src="/image/git3-7.png" width="700" height="auto"><br></div><br>$ git log -p 명령어를 입력하면 각 버전들 사이의 소스상 차이점을 알 수 있다.<br>위 경우, version 4(commit message가 ‘4’인 버전) commit에서, version 4의 f1.txt의 내용이 ‘f1.txt : 4’, version 3의 f1.txt의 내용이 ‘source : 2’이었음을 알 수 있다.<br>또한, version 3 commit에서, version 2에서는 f2.txt가 없었으나 version 3에서는 그 내용을 ‘source : 2’로 하는 f2.txt가 새로 생성되었음을 알 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 19, <a href="https://opentutorials.org/course/2708/15202" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15202</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/20/git3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Git] Init, Status, Add</title>
      <link>http://dudri63.github.io/2019/01/19/git2/</link>
      <guid>http://dudri63.github.io/2019/01/19/git2/</guid>
      <pubDate>Sat, 19 Jan 2019 13:45:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. $ git init&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. $ git status, $ git add&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. $ git init&lt;/a&gt;&lt;/p&gt;
&lt;figure class
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. $ git init</a><br><a href="#2">2. $ git status, $ git add</a></p><hr><p><a name="1">1. $ git init</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git init//현재 디렉토리를 Git의 저장소로 등록</span><br></pre></td></tr></table></figure><p>위와 같은 명령어를 실행하면, 현재 디렉토리를 Git으로 관리할 수 있다.</p><p>이 후, ls -al로 확인하면, <strong>.git</strong> 디렉토리가 현재 디렉토리 내부에 새롭게 생성된 것을 알 수 있다. 버전 관리를 하게 되면, 여러 가지 정보가 생성되는데, 이 때 이 정보들은 .git 디렉토리에 저장된다.</p><div align="center"><br><img src="/image/git2-1.png" width="700" height="auto"><br></div><hr><p><a name="2">2. $ git status, $ git add</a></p><p>Git은 init을 하여 관리하고 있는 디렉토리라고 할지라도, 기본적으로 새롭게 생성된 파일에 대해서는 관리하지 않는다. 파일을 관리하기 위해서는 관리 대상으로 등록해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git status// 현재 관리하고 있는 파일과 그렇지 않은 파일 확인</span><br><span class="line">git add + 파일// 해당 파일을 git에게 추적하라고 명령</span><br></pre></td></tr></table></figure><p><div align="center"><br><img src="/image/git2-2.png" width="700" height="auto"><br><img src="/image/git2-3.png" width="700" height="auto"><br></div><br>f1.txt의 내용을 ‘source:1’으로 하여 생성한다.</p><p><div align="center"><br><img src="/image/git2-4.png" width="700" height="auto"><br></div><br><strong>git status</strong>를 실행하였을 때, f1.txt는 untracked file임을 확인할 수 있다. 즉, f1.txt는 버전 관리가 되고 있는 디렉토리에 존재하지만, 아직 git에 의해 관리되고 있지 않다.<br>그러나 이 후, <strong>git add</strong> 명령어를 입력하여 git에게 f1.txt를 추적하라고 명령하면, 새롭게 f1.txt가 관리되기 시작하는 것을 알 수 있다.   </p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“지옥에서 온 Git”, 생활코딩, 2019. 1. 19, <a href="https://opentutorials.org/course/2708/15170" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15170</a>, <a href="https://opentutorials.org/course/2708/15172" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/2708/15172</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/19/git2/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
