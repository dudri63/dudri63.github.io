<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>SEO, IT blog</title>
    <link>http://dudri63.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 13 Feb 2019 14:11:35 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>jekyll1</title>
      <link>http://dudri63.github.io/2019/02/13/jekyll1/</link>
      <guid>http://dudri63.github.io/2019/02/13/jekyll1/</guid>
      <pubDate>Wed, 13 Feb 2019 12:14:12 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;지킬(Jekyll)&lt;/strong&gt;이란, 간단한 블로그가 되는 정적 사이트 생성기이다.&lt;/p&gt;
&lt;p&gt;사이트 생성기란 ‘홈페이지를
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1.</a></p><hr><p><a name="1">1.</a></p><p><strong>지킬(Jekyll)</strong>이란, 간단한 블로그가 되는 정적 사이트 생성기이다.</p><p>사이트 생성기란 ‘홈페이지를 만드는 것’을 의미한다.<br>기존 홈페이지는 html 언어를 이용하여 생성하고, 자바스크립트, css 등이 추가로 사용되기도 한다.<br><strong>HTML</strong>이란 HyperText Markup Language의 약자인데, Markup이라는 말의 의미에 주목할 필요가 있다.</p><p>1.1 마크다운 언어</p><p>WYSWYG(What you see is what you get)이란 방식이 있다.<br>이 방식은 “보이는 대로 결과가 나온다”는 뜻인데 이는 다음 예를 통하여 그 의미를 파악할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;지킬&lt;/u&gt; // 밑줄이 쳐진다.</span><br></pre></td></tr></table></figure><p>위 내용을 텍스트 파일에 작성하면, 바로 밑줄이 생시지 않는다.<br>텍스 파일을 *.html 확장자를 붙여서 저장하고, 웹브라우저에서 열면 밑줄이 비로소 생긴다.<br>이것은 마크업 언어 방식이다.<br>즉, 마크업 언어는 WYSWYG 방식이 아니다.</p><p>마크다운은 마크업이 너무 복잡하기 때문에 문법을 간단하게 바꾼 것이다.</p><p>예를 들어<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://naver.com&quot;&gt;네이버&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>와 같이 텍스트에 링크를 거는 방식을</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[네이버] (http://naver.com)</span><br></pre></td></tr></table></figure><p>과 같이 간단하게 표현하는 것이다.</p><p>지킬이 홈페이지 생성기라는 의미는 html를 비롯하여 자바스크립트, css 등을 이용하지 않고, 마크다운 형식의 간단한 문법을 이용하여 페이지를 구성하면, 저절로 html,css, 자바스크립트로 구성된 홈페이지로 바꾼다는 뜻이다.</p><p>블로그란 최신 글이 상위에 존재하는 규칙을 비롯한 여러가지 규칙에 따라 내용을 정리해주는 홈페이지 생성기이다.</p><p>1.2 정적 사이트</p><p>대부분의 블로그 소프트웨어는 동적 홈페이지 생성기이다.<br>동적 홈페이지 생성기는 홈페이지를 미리 만들어 두지 않는다.<br>사용자가 홈페이지 접속하고, 페이지를 요청하면, 홈페이지를 제작, 사용자에게 보내 준다.<br>홈페이지 내용이 끊임 없이 변하는 경우, ex. SNS, 검색 등, 동적 페이지를 만들어야 한다.</p><p>그러나 개인 블로그 같은 경우 하루에 업데이트를 몇 번하지 않기 때문에 동적인 사이트 생성기가 필요 없다.<br>정적 사이트 생성기는 동적 사이트 생성기와 달리 데이터베이스를 사용하지 않는다. </p><hr><ol start="2"><li>블로그 포스팅</li></ol><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>*</p>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/13/jekyll1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Java] 데이터 타입</title>
      <link>http://dudri63.github.io/2019/02/13/java3/</link>
      <guid>http://dudri63.github.io/2019/02/13/java3/</guid>
      <pubDate>Wed, 13 Feb 2019 11:35:06 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 데이터 타입&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 기본 타입&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 참조 타입&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3.1&quot;&gt;3.1 배열 타입&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3.2&quot;&gt;3.
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 데이터 타입</a><br><a href="#2">2. 기본 타입</a><br><a href="#3">3. 참조 타입</a><br><a href="#3.1">3.1 배열 타입</a><br><a href="#3.2">3.2 클래스 타입</a><br><a href="#3.3">3.3 인터페이스 타입</a><br><a href="#3.4">3.4 열거 타입</a></p><hr><p><a name="1">1. 데이터 타입</a></p><p><strong>변수(variable)</strong>란 어떤 값을 저장하는 공간이다.<br>변수를 선언할 때 변수에 저장할 수 있는 값의 타입, 즉, 데이터 타입을 함께 선언해야 한다.<br>데이터 타입은 변수의 용도를 정의하기 때문이다.</p><p>자바의 데이터 타입은 키워드로 정의되어 있는 <strong>기본 타입(Primitive Type)</strong>, 기본 타입을 기초로 만들어진 <strong>참조 타입(Reference Type)</strong>이 있다.</p><p><a name="2">2. 기본 타입</a></p><p>자바의 기본 타입은 8개의 키워드로 정의된 것인데, 다음과 같다.</p><p>byte, short, int, long, char, float, double, boolean</p><p>기본 타입을 제외한 나머지 타입은 참조 타입이다.</p><p>데이터 타입을 사용하여 변수를 선언하면 해당 타입에 따라 정해진 메모리 크기가 할당되어 메모리값을 저장하고 사용할 수 있는 상태가 된다.<br>자바에서 제공하는 기본 타입별 메모리 할당 크기는 다음과 같다.</p><div align="center"><br><img src="/image/java3-1.png"><br></div><p><a name="3">3. 참조 타입</a></p><p>참조 타입은 <strong>참조 값(Reference Value)</strong>, 즉, 메모리 주소를 계산할 수 있는 참조 값을 다루기 위한 타입으로, 배열, 클래스, 인터페이스, 열거 타입으로 나뉜다.<br>참조 타입의 변수에는 실제 데이터 값이 저장된 메모리 위치를 찾아갈 때 사용할 값(참조값)이 저장된다.<br>이 후, 저장된 참조 값을 이용해서 필요한 데이터가 있는 실제 메모리 주소를 계산하는 것은 자바 가상 머신에서 담당한다.</p><p><a name="3.1">3.1 배열 타입</a></p><p><strong>배열(Array)</strong>은 같은 데이터 타입을 가진 데이터들을 메모리에 연속적으로 저장하여 만든 데이터들의 그룹이다.<br>변수들을 한데 묶어서 하나의 배열로 만들면, 단 한번만 배열을 선언하면 되고, 각 요소들은 배열의 내부 요소가 되어 다루기가 쉬워진다.<br>배열의 요소를 구별하기 위해 번호를 사용하는데, 이를 <strong>인덱스(index)</strong>라고 한다.<br>인덱스는 0부터 시작한다.<br>구성 형태에 따라서 1차워 배열, 2차원 배열, 3차원 배열도 가능하다.</p><ul><li>1차원 배열의 선언과 생성 및 사용</li></ul><p>1차원 배열을 선언하는 방식은 다음과 같다.</p><p>데이터타입 배열이름 [];        ex. char c[];<br>데이터타입 [] 배열이름;        ex. char[] c;</p><p>선언한 배열을 생성할 때는 배열 생성 명령을 사용해야 한다.<br>배열에 대한 메모리를 생성하기 위해 new 연산자를 사용한다.<br>배열 생성 명령은 다음과 같다.</p><p>new 데이터타입 [배열크기];    ex. c = new char[10];, 이 때, 배열 요소 [0]~c[9]</p><p>기본 타입의 변수를 선언하는 경우, 데이터 타입에 맞는 크기의 메모리 공간이 자동으로 할당, 데이터를 저장할 변수가 생성된다.<br>그러나 배열과 같은 참조 타입의 변수를 선언하면 데이터를 저장할 수 있는 공간이 할당되는 것이 아니라, 메모리 공간에 대한 참조, 즉 메모리 주소 정보(참조 값)를 저장할 수 있는 공간만 확보된다.<br>이 후, 실제 데이터를 저장할 메모리 공간을 생성하려면 new 연산자의 생성식을 사용한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ex_array &#123;</span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line">    int i_arr[];// 배열 i_arr 선언</span><br><span class="line">    i_arr = new int[3];// int형 공간 3개를 메모리에 연속 생성, 시작 주소를 배열변수 i_arr에 대입</span><br><span class="line">    i_arr[0] = 10;// i_arr 초기</span><br><span class="line">    i_arr[1] = 20;</span><br><span class="line">    i_arr[2] = 30; </span><br><span class="line">    System.out.println(&quot;i_arr[0] = &quot; + i_arr[0]);</span><br><span class="line">    System.out.println(&quot;i_arr[1] = &quot; + i_arr[1]);</span><br><span class="line">    System.out.println(&quot;i_arr[2] = &quot; + i_arr[2]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/java3-2.png"><br></div><p>배열 선언과 배열 생성 명령을 다음과 같이 하나의 명령문으로 표현할 수도 있다.</p><p>int i_arr[] = new int[3];</p><p>배열 선언, 배열 생성 명령, 배열 초기화를 다음과 같이 하나의 명령문으로 표현할 수도 있다.</p><p>i_arr[] = {10, 20, 30};</p><p>위와 같은 방식을 사용할 경우, new 연산자와 배열의 크기 지정을 하지 않아도 된다.</p><ul><li>다차원 배열의 선언과 생성 및 사용</li></ul><p>2차원 이상의 배열을 다차원 배열이라고 한다.<br>2차원 배열을 선언하는 방식은 다음과 같다.</p><p>데이터타입 배열이름 [][];    // int i_arr2[][];<br>데이터타입 [][] 배열이름;    // int [][] i_arr2;</p><p>2차원 배열을 생성하는 방식은 다음과 같다.</p><p>new 데이터타입 [배열크기1][배열크기2];</p><p>배열크기 1이 행의 개수, 배열크기 2는 열의 개수이다.<br>배열 요소의 전체 개수는 (배열크기1 * 배열크기2) 이다.</p><p>2차원 배열이 메모리상 저장되는 방식은 ‘행 번호 0의 열 번호 0부터 열 번호 n까지’를 시작으로, ‘행 번호 n의 열 번호 0부터 n까지’ 순차적으로 저장된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class ex_array2 &#123;</span><br><span class="line">  public static void main(String args[]) &#123;</span><br><span class="line">    int i_arr2[][] = new int[2][3];// 2차원 배열 i_arr2 (2행 3열짜리) 선언 및 생성</span><br><span class="line">    i_arr2[0][0] = 10;</span><br><span class="line">    i_arr2[0][1] = 20;</span><br><span class="line">    i_arr2[0][2] = 30;</span><br><span class="line">    i_arr2[1][0] = 100;</span><br><span class="line">    i_arr2[1][1] = 200;</span><br><span class="line">    i_arr2[1][2] = 300;</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;i_arr2[0][0] = &quot; + i_arr2[0][0]);</span><br><span class="line">    System.out.println(&quot;i_arr2[0][1] = &quot; + i_arr2[0][1]);</span><br><span class="line">    System.out.println(&quot;i_arr2[0][2] = &quot; + i_arr2[0][2]);</span><br><span class="line">    System.out.println(&quot;i_arr2[1][0] = &quot; + i_arr2[1][0]);</span><br><span class="line">    System.out.println(&quot;i_arr2[1][1] = &quot; + i_arr2[1][1]);</span><br><span class="line">    System.out.println(&quot;i_arr2[1][2] = &quot; + i_arr2[1][2]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/java3-2.png"><br></div><p>배열 선언, 생성 및 초기화 과정은 다음과 같이 하나의 명령문으로 표현할 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int i_arr2[][] = &#123;&#123;10,20,30&#125;, &#123;100,200,300&#125;&#125;;</span><br></pre></td></tr></table></figure><p>중괄호 내에서 첫 번째 중괄호가 첫 번째 행에 대한 초기값, 두 번째 중괄호는 두 번째 행에 대한 초기값이 된다.</p><hr><p><a name="3.2">3.2 클래스 타입</a></p><p><strong>클래스 타입</strong>은 여러 타입의 변수와 메소드를 그룹으로 묶어서 새롭게 정의한 사용자 정의 타입이다.<br>데이터 타입을 정의할 때는 그 데이터를 연산할 수 있는 메소드가 함께 정의되어야 한다.<br>자바에서 제공하는 기본 타입은 그에 대한 메소드가 이미 정의되어 있으므로 메소드 정의 없이 타입에 대한 변수만 선언하고 사용하는 거이다.<br>배열 타입 역시 사용자 정의 타입이기는 하지만, 이미 자바에 의해 해당 타입에 대해서 이미 정의되어 있는 메소드가 있다.</p><p>클래스 타입은 완전한 새로운 타입을 정의하는 것이기 때문에 자바에서 정의해 놓은 기본 메소들르 사용할 수가 없다.<br>그러므로 클래스로 정의한 데이터 타입을 연산할 수 있는 메소드까지 클래스 타입에 포함시켜 사용자가 정의하여야 한다.</p><ul><li>클래스 타입의 정의와 선언 및 생성</li></ul><p>클래스 타입을 정의할 때는 키워드 class 뒤에 클래스이름을 쓰고, 중괄호 사이에 변수 및 상수에 대한 데이터 멤버와 멤버 메소드를 정의한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class PointXY &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  PointXY(int x, int y) &#123;// 생성자 메소</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  void setX(int x) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">  &#125;</span><br><span class="line">  void setY(int y) &#123;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  void moveXY(int x, int y) &#123;</span><br><span class="line">    this.x += x;</span><br><span class="line">    this.y += y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ex_class &#123;</span><br><span class="line">  public static void main (String args[]) &#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    int j = 20;</span><br><span class="line">    System.out.println(&quot;i = &quot; + i);</span><br><span class="line">    System.out.println(&quot;j = &quot; + j);</span><br><span class="line">    System.out.println(&quot;After PointXY A(i,j)&quot;);</span><br><span class="line">    PointXY A;</span><br><span class="line">    A = new PointXY(i,j);</span><br><span class="line">    System.out.println(&quot;A.x = &quot; + A.x);</span><br><span class="line">    System.out.println(&quot;A.y = &quot; + A.y);</span><br><span class="line">    System.out.println(&quot;After A.setX(15)&quot;);</span><br><span class="line">    A.setX(15);</span><br><span class="line">    System.out.println(&quot;A.x = &quot; + A.x);</span><br><span class="line">    System.out.println(&quot;A.y = &quot; + A.y);</span><br><span class="line">    System.out.println(&quot;After A.moveXY(3,3)&quot;);</span><br><span class="line">    A.moveXY(3,3);</span><br><span class="line">    System.out.println(&quot;A.x = &quot; + A.x);</span><br><span class="line">    System.out.println(&quot;A.y = &quot; + A.y);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/java3-3.png"><br></div><p>메소드 중에서 클래스 이름과 같은 이름의 메소드를 <strong>생성자(Constructor)</strong> 메소드라고 한다.<br>클래스 타입의 변수를 생성할 때마다 자동으로 실행, 데이터 멤버들을 초기화한다.</p><p>클래스 타입도 배열과 마찬가지로 참조 타입이기 때문에 new 명령어를 사용하여 변수에 대한 메모리를 생성하고 그 참조값을 클래스 타입의 변수에 대입해야 한다.</p><p>클래스 타입을 정의한 파일을 컴파일하면 각 클래스마다 별도의 클래스 파일이 생성된다. 그리고 자바 가상 머신이 프로그램을 실행할 때 필요한 클래스 파일들을 자동으로 읽어서 사용한다.</p><hr><p><a name="3.3">3.3 인터페이스 타입</a></p><p><strong>인터페이스 타입</strong>은 여러 클래스 타입에서 공통으로 사용하는 상수와 메소드를 따로 분리하여 추상화시킨 타입이다.<br>클래스 타입과 유사하지만, 데이터 멤버에 상수만 사용할 수 있고, 멤버 메소드를 내용 없이 선언만 한다는 점에서 차이가 있다.</p><ul><li>인터페이스 타입 정의</li></ul><p>키워드 interface 뒤에 인터페이스 이름을 쓰고, 중괄호 사이에 필요한 상수와 메소드들을 선언한다.<br>이 때, 중괄호 내에 있는 메소드는 이름만 있고 실제 내용은 정의하지 않은 <strong>추상 메소드(Abstract Method)</strong>이다.</p><p>예를 들어 서로 다른 도형에 대해 클래스 타입들이 있을 때 도형의 형태에 따라서 넓이를 구하는 방법이 다르므로, 넓이를 구하는 메소드 getArea()를 추상화하여 인터페이스 타입으로 따로 선언할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Shape&#123;</span><br><span class="line">  void getArea();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 코드를 Shape.java로 저장, 컴파일하면 Shape.class라는 클래스 파일이 생성된다.<br>자바 컴파일러는 인터페이스 타입을 클래스 파일로 처리한다.</p><ul><li>인터페이스 타입에 대한 구현 클래스 정의</li></ul><p>인터페이스 타입은 추상화된 타입이기 메소드에 대한 내용이 정의되어 있지 않다.<br>따라서 인터페이스 타입의 추상 메소드의 내용을 정의하여 <strong>구현(implement)</strong>하는 클래스 타입이 필요하다.<br>인터페이스 타입을 구현하는 클래스 타입을 정의할 때는 클래스 이름 뒤에 키워드 implements와 구현할 인터페이스 이름을 추가, 구현하는 멤버 메소드 앞에 키워드 public을 붙인다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">class Triangle implements Shape &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  double area;</span><br><span class="line">  Triangle(int x, int y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  public void getArea() &#123;</span><br><span class="line">    this.area = this.x * this.y / 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Rectangle implements Shape &#123;</span><br><span class="line">  int x, y;</span><br><span class="line">  double area;</span><br><span class="line">  Rectangle(int x, int y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  public void getArea() &#123;</span><br><span class="line">    this.area = this.x * this.y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ex_interface &#123;</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    int i = 10;</span><br><span class="line">    int j = 20;</span><br><span class="line">    System.out.println(&quot;i = &quot; + i);</span><br><span class="line">    System.out.println(&quot;j = &quot; + j);</span><br><span class="line">    System.out.println(&quot;After Triangle A; &amp; A = new Triangle(i,j)&quot;);</span><br><span class="line">    Triangle A;</span><br><span class="line">    A = new Triangle(i,j);</span><br><span class="line">    System.out.println(&quot;After A.getArea()&quot;);</span><br><span class="line">    A.getArea();</span><br><span class="line">    System.out.println(&quot;A.area = &quot; + A.area);</span><br><span class="line">    System.out.println(&quot;After Rectangle B; &amp; B = new Triangle(i,j)&quot;);</span><br><span class="line">    Rectangle B;</span><br><span class="line">    B = new Rectangle(i,j);</span><br><span class="line">    System.out.println(&quot;After B.getArea()&quot;);</span><br><span class="line">    B.getArea();</span><br><span class="line">    System.out.println(&quot;B.area = &quot; + B.area);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/java3-4.png"><br></div><p>인터페이스 타입도 참조 타입이므로 new 명령어를 사용하여 생성 작업을 해주어야 할 것이다.<br>그러나 인터페이스 타입은 그 내부에 추상 메소드가 내용이 없기 때문에 필요한 메모리 크기를 알 수 없다.<br>그리하여 인터페이스 타입의 변수를 생성할 때 인터페이스를 구현한 클래스 타입을 사용한다.</p><p>이에 대한 설명은 아래 예제 코드를 참고한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Shape shape1;</span><br><span class="line">shape1 = new Triangle(10,20);// 클래스 타입을 사용하여 변수 생성</span><br><span class="line">Shape shape2;</span><br><span class="line">shape2 = new Rectangle(20,30);  // 클래스 타입을 사용하여 변수 생성</span><br></pre></td></tr></table></figure></p><hr><p><a name="3.4">3.4 열거 타입</a></p><p>표현할 데이터가 정해진 수의 값만을 가지고 있는 경우가 있다.<br>예를 들어, “요일”을 표현하는 값은 오직 ‘월’, ‘화’, ‘수’, ‘목’, ‘금’, ‘토’, ‘일’이다.<br>7개의 값을 7개의 상수로 선언할 수도 있지만,<br>7개의 상수만을 값으로 사용하는 하나의 타입으로 정의하여 사용할 수 있다.<br>이런 타입을 <strong>열거(enumerate)</strong> 타입이라고 한다.</p><ul><li>열거 타입 정의</li></ul><p>키워드 enum 뒤에 열거 타입의 이름을 쓰고, 중괄호 사이에 선언할 상수들을 콤마로 구분하여 나열한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enum Week&#123;</span><br><span class="line">  MON, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Week.java로 저장한뒤 컴파일하면 Week.class라는 클래스 파일이 생성된다.<br>자바 컴파일러는 열거 타입을 인터페이스 타입과 마찬가지로 클래스 파일로 처리한다.</p><ul><li>열거 타입 변수의 선언과 사용</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class ex_week&#123;</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">  Week myWeek = Week.FRI;</span><br><span class="line">  Week yourWeek = Week.SAT;</span><br><span class="line">  System.out.printf(&quot;MY special day : (%s) %n&quot;, myWeek);</span><br><span class="line">  System.out.printf(&quot;Your special day : (%s) %n&quot;, yourWeek);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/java3-5.png"><br></div><p>열거 타입은 힙 영역에 열거한 상수만큼 저장한다.<br>월, 화, 수, 목, 금, 토, 일을 힙 영역에 저장하였다.<br>그러므로 따로 변수를 생성하지 않고, 힙 영역에 생성된 상수를 참조하면 되기 때문에 new 연산자를 사용하지 않는다.<br>또한, 열거 타입의 변수는 그 타입에 속하는 상수 값만을 대입하여 사용할 수 있다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/13/java3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Java] 자바 식별자</title>
      <link>http://dudri63.github.io/2019/02/12/java2/</link>
      <guid>http://dudri63.github.io/2019/02/12/java2/</guid>
      <pubDate>Tue, 12 Feb 2019 14:14:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;자바에서 사용하는 단어의 종류는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;키워드(Keyword) : 미리 정해둔 의미로만 사용하는 50개의 단어&lt;/li&gt;
&lt;li&gt;상수 값을 표현하는 단어 3개 : true, false, null&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p>자바에서 사용하는 단어의 종류는 다음과 같다.</p><ul><li>키워드(Keyword) : 미리 정해둔 의미로만 사용하는 50개의 단어</li><li>상수 값을 표현하는 단어 3개 : true, false, null</li><li><p>식별자(identifier) : 클래스, 메소드, 변수 등의 이름으로 사용하는 단어</p><div align="center"><br><img src="/image/java2-1.png"><br>▲ 자바 키워드<br></div></li><li><p>식별자 생성 규칙</p><ul><li>하나 이상의 문자로 이루어져야 한다.</li><li>첫 번째 문자는 영문자 또는 ‘$’ 또는 ‘_’이어야 한다.</li><li>‘$’, ‘_’ 이외의 특수문자를 사용할 수 없다.</li><li>문자 길이의 제한이 없다.</li><li>키워드나 상수 값을 표현하는 단어는 식별자로 사용할 수 없다.</li></ul></li></ul><p>여러 개의 식별자를 사용할 때는 식별자 사이를 점으로 연결한다.<br>다음은 명령문 예시이다.</p><ul><li>System.out.println</li></ul><p>System은 클래스 이름, out은 System 클래스 내부 변수의 이름, println은 out 변수에 속하는 메소드 이름이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“CH05 변수, 연산자, 수식”, 냉유’s Log, 2019.2.12, <a href="https://keep-cool.tistory.com/5" rel="external nofollow noopener noreferrer" target="_blank">https://keep-cool.tistory.com/5</a></li><li>이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/12/java2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Java] 자바의 기초</title>
      <link>http://dudri63.github.io/2019/02/12/java1/</link>
      <guid>http://dudri63.github.io/2019/02/12/java1/</guid>
      <pubDate>Tue, 12 Feb 2019 09:55:38 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 자바의 구성&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Hello Java&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 자바 프로그램의 구조&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 자바 실행 과정&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 자바의 구성</a><br><a href="#2">2. Hello Java</a><br><a href="#3">3. 자바 프로그램의 구조</a><br><a href="#4">4. 자바 실행 과정</a></p><hr><p><a name="1">1. 자바의 구성</a></p><p><strong>‘자바 플랫폼(Java Platform)’</strong>은 자바 프로그램을 실행할 수 있게 하는 ‘하드웨어적 프로그램’이다.<br>자바 플랫폼은 자바 API(Application Programming Interface)와 자바 가상 머신으로 구성되어 있다.</p><div align="center"><br><img src="/image/java1-1.png"><br></div><ul><li>JAVA API</li></ul><p>자바 API는 자바 응용프로그램을 만드는 데 필요한 유용한 클래스들과 사용 방법을 문서화하여 제공한다.</p><ul><li>JAVA 가상 머신</li></ul><p>자바 가상 머신은 물리적인 기계 장치가 아니라 추상적인 장치이며, 클래스 파일을 실행할 수 있는 기계어 파일로 번역해 준다.</p><div align="center"><br><img src="/image/java1-2.png"><br><br></div><ol><li>클래스 영역</li></ol><p>실행에 필요한 클래스들을 로드, 저장하는 공간.<br>로드된 클래스의 멤버 메소드들은 메소드 영역에 저장, 상수들은 상수 영역에 저장된다.<br>사용자가 작성한 클래스 코드들도 또한 이 곳에 저장된다.</p><ol start="2"><li>자바 스택 영역</li></ol><p>자바 프로그램을 수행하면서 발생하는 메소드 호출과 복귀에 대한 정보를 생성, 저장, 관리하는 공간이다.</p><ol start="3"><li>힙 영역</li></ol><p>객체를 생성할 때 동적으로 공간을 할당, 객체를 저장하는 공간이다.</p><ol start="4"><li>네이티브 메소드 스택 영역</li></ol><p>자바에는 하드웨어를 직접 제어하는 기능이 없다.<br>그래서 하드웨어를 제어해야 할 경우, C 언어와 같은 다른 언어의 기능을 잠시 빌려서 사용한다.<br>이 때 사용하는 기술이 JNI(Java Native Interface)이다.<br>네이티브 메소드들이 바이트 코드로 변환되면서 사용되고 기록하는 영역이 네이티브 메소드 스택 영역이다.</p><hr><p><a name="2">2. Hello, Java</a></p><p><img src="/image/java1-3.png"></p><p>위 코드를 HelloJava.java 이름을 저장한다.</p><p><img src="/image/java1-4.png"></p><p>$ javac : 자바 소스 파일을 컴파일 한다.<br>자바 컴파일러는 소스 파일을 클래스 파일(*.class, HelloJava.class)로 번역한다.</p><p>$ java : 자바 가상 머신을 동작시킨다. 앞서 컴파일한 클래스 파일을 기계어 코드로 번역 및 실행한다.</p><hr><p><a name="3">3. 자바 프로그램의 구조</a></p><p><img src="/image/java1-5.png"></p><ul><li><strong>클래스(class)</strong></li></ul><p>자바 프로그램을 구성하는 단위.<br>자바 프로그램은 내부적으로 한 개 이상의 클래스로 구성되어 있다.</p><p>위 자바 프로그램에서는 하나의 클래스로 구성이 되어 있다.<br>클래스 이름은 JavaStructure, 중괄호로 묶인 부분이 클래스 본체이다.</p><ul><li><strong>메소드(method)</strong></li></ul><p>클래스 본체는 한 개 이상의 메소드가 있다.<br>메소드는 수행할 명령문들의 묶음이다.</p><p>위 JavaStructure 클래스에서는 두 개의 메소드로 구성이 되어 있다.<br>메소드 이름은 각각 sum, main이며, 중괄호로 묶인 부분이 메소드 본체이다.</p><p>메소드 이름은 개발자가 임의로 정할 수 있지만, main이라는 이름의 메소드가 반드시 한 개 있어야 한다.<br>자바 프로그램의 실행 시작 지점이 main 메소드로 지정되어 있기 때문이다.</p><hr><p><a name="4">4. 프로그램 실행 과정</a></p><p>컴퓨터는 오직 이진수만을 처리한다.<br>따라서 작성한 프로그램(소스코드)를 이진수의 조합, 즉, 기계어로 번역해야 한다.<br>이 때 필요한 도구가 <strong>컴파일러(compiler)</strong>이다.</p><p>C 프로그램(*.c)은 C 컴파일러,<br>C++ 프로그램(*.cpp)은 C++ 컴파일러를<br>통해 기계어로 번역, 실행 가능한 실행파일(*.exe)을 만든다.</p><p>위 컴파일러를 통해 생성된 실행파일은 컴파일러가 동작하는 운영체제에서만 실행할 수 있다.<br>예를 들어 윈도우즈 운영체제에서 컴파일되어 생성된 실행파일은 오직 윈도우즈 운영체제에서만 실행 가능하고, 리눅스 등의 다른 운영체제 시스템에서는 실행되지 않는다.<br>작성한 프로그램을 다른 시스템에서 실행시키려면 다른 시스템의 운영체제에서 다시 컴파일하여 실행 파일을 생성해야 한다.</p><p>이에 반해, 자바로 구현한 프로그램은 어떤 운영체제에서든지 수정하지 않고 사용할 수 있다.<br>왜냐하면 JDK에 포함되어 있는 <strong>자바 가상머신(JVM, Java Virtual Machine)</strong> 때문이다.<br>C나 C++ 컴파일러는 사용할 하드웨어와 운영체제에 꼭 맞춘 기계어 코드 파일을 만들어내는 반면,<br>자바 컴파일러는 클래스 파일이라고 하는 가상 기계어로 된 코드 파일을 생성,<br>자바 가상 머신이 클래스 파일을 진짜 기계어로 번역하여 실행하게 한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“[Java 04] 자바 프로그램의 구조”, 냉유’s Log, 2019.2.12, <a href="https://keep-cool.tistory.com/7" rel="external nofollow noopener noreferrer" target="_blank">https://keep-cool.tistory.com/7</a></li><li>이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/12/java1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[자료구조] 소프트웨어와 자료구조</title>
      <link>http://dudri63.github.io/2019/02/11/ds2/</link>
      <guid>http://dudri63.github.io/2019/02/11/ds2/</guid>
      <pubDate>Mon, 11 Feb 2019 11:25:50 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 소프트웨어 생명주기&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 추상 데이터 타입&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 소프트웨어 생명주기&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;소프트웨어 : 프로그램의 개
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 소프트웨어 생명주기</a><br><a href="#2">2. 추상 데이터 타입</a></p><hr><p><a name="1">1. 소프트웨어 생명주기</a></p><ul><li><p>소프트웨어 : 프로그램의 개발과 운영 및 유지, 보수에 관련된 모든 정보와 작업을 포함하는 개념이다.<br>정확하고 효율적인 소프트웨어를 개발하기 위해서는 개발할 소프트웨어를 정확히 이해하고, 사용할 자료와 자료간의 연산관계를 분석, 자료구조를 정의, 이에 대한 가장 효율적인 구조를 고안하여 개발해야 한다.</p></li><li><p>소프트웨어 생명주기 : Software Life Cycle = 소프트웨어 개발주기(Software Development Cycle)<br>소프트웨어를 체계적으로 개발, 관리하기 위해 소프트웨어 개발 과정을 몇 단계로 구분한 것</p></li></ul><div align="center"><br><img src="/image/ds2-1.png"><br><br>필요한 단계로 피드백을 반복 수행, 완성도를 높임<br></div><ol><li>요구 분석 단계 : Requirement Analysis</li></ol><ul><li>소프트웨어 개발의 첫단계</li><li>개발할 소프트웨어의 기능과 제약조건, 목표 등을 소프트웨어 사용자와 함께 정의하는 단계</li><li>개발 방법, 필요한 자원, 예산을 예측</li><li>요구 명세서를 작성, 요구 명세서는 소프트웨어 개발 완료 여부를 결정짓는 근거</li></ul><ol start="2"><li>시스템 명세 단계 : System Specification</li></ol><ul><li>시스템이 무엇을 수행해야 하는가를 정의.</li><li>시스템 기능 명세서를 작성. 입력 데이터 정의, 입력 데이터로 처리하는 내용, 출력 정의 / 가능한 정확하게 작성해야 한다.</li></ul><ol start="3"><li>설계 단계 : Design</li></ol><ul><li>2단계에서 정의한 기능을 실제 수행할 수 있도록 수행 방법을 논리적으로 결정</li><li>시스템 구조 설계 : 시스템을 구성하는 내부 프로그램, 모듈 간의 관계와 구조를 설계</li><li>프로그램 설계 : 프로그램 내의 각 모듈에서의 처리 절차나 알고리즘을 설계</li><li><p>사용자 인터페이스 설계 : 사용자에게 보이는 부분에 대한 설계</p></li><li><p>하향식 설계 방법<br>무엇을 수행할 것인지 정의 -&gt; 어떻게 수행할 것인지 정의 -&gt; 점점 구체적으로 세부 문제 정의<br>최하위 단계로 분할(divide)된 작은 단위의 문제들을 각각 처리, 전체 문제를 해결(conquer)<br>분할 정복(Divide and Conquer)</p><div align="center"><br><img src="/image/ds2-2.png"><br></div></li><li>상향식 설계 방법<br>최하위 단계에 있는 작은 단위를 먼저 결정, 해결, 이를 이용하여 좀더 큰 단위인 상위 단계의 문제를 해결하는 방법<div align="center"><br><img src="/image/ds2-3.png"><br></div></li><li>객체지향 설계 방법<br>작은 단위의 문제에 대해 문제 해결을 위한 데이터와 처리 방법을 묶어서 객체 생성, 객체들을 연결하여 재사용하는 방법을 사용한다.</li></ul><ol start="4"><li>구현 단계 : Implementation</li></ol><ul><li><p>구현 단계에서는 설계 단계에서 논리적으로 결정한 문제해결 방법(알고리즘)을 C, C++, JAVA 등의 특정 프로그래밍 언어를 사용하여 실제 프로그램을 작성한다.</p></li><li><p>구조화 프로그래밍(Structured Programming)<br>지정문, 조건문, 반복문만을 사용하여 프로그램 작성<br>순차구조, 선택구조, 반복구조의 세 가지 제어구조로 표현하는 기법<br>구조가 간단, 명확, 정확성 검증이 쉽고, 테스트와 유지 보수가 쉽다</p></li><li><p>모듈러 프로그래밍(Modular Programming)<br>프로그램을 여러 개의 작은 모듈(module)로 나누어서 계층 관계를 갖도록 구성<br>각각의 모듈은 구조화 프로그래밍 기법으로 작성, 하나의 기능만을 수행<br>모듈별로 개발, 테스트, 유지 보수가 가능하고, 재사용이 가능하다</p></li><li><p>효과적인 프로그래밍을 위해 프로그램을 명확하게 작성, 임시변수는 되도록 사용하지 않는다.<br>또한 변수명은 일관, 이해하기 쉬운 이름, 같은 문장 최소화, 주석을 사용한다</p></li></ul><ol start="5"><li>테스트 단계 : Test</li></ol><ul><li><p>개발한 시스템이 요구사항을 만족하는지, 실행결과가 예상한 결과와 정확하게 맞는지를 검사, 평가, 오류를 찾아내어 시스템의 완성도를 높인다.</p></li><li><p>단위 테스트(Unit Test)<br>시스템의 최소 구성요소인 모듈들에 대해 개별적으로 시행, 테스트한다.</p></li><li>통합 테스트(Integration Test)<br>단위 테스트를 통과한 모듈을 모아서 전체 시스템을 완성하기 위해 통합적으로 시행하는 테스트.<br>최소의 모듈을 연결, 점진적으로 다른 구성요소를 연결하면서 테스트한다.<ul><li>하향식 테스트</li><li>상향식 테스트</li></ul></li><li>인수 테스트(Acceptance Test)<br>실제 데이터를 사용하여 시스템을 테스트 하는 과정, 실질적으로 사용되기 위해 마지막으로 시행되는 테스트</li></ul><ol start="6"><li>유지 보수 단계</li></ol><ul><li>오류 수정, 디자인 수정, 새로운 요구사항에 대한 기능 추가, 환경 변화에 따른 시스템 교정 등의 활동</li><li><p>소프트웨어 생명주기에서 가장 긴 시간을 차지한다.</p></li><li><p>수정형 유지 보수 : 사용중 발견한 오류를 수정</p></li><li>적응형 유지 보수 : 환경적 변화에 적응하도록 재조정</li><li>완전형 유지 보수 : 성능 향상</li><li>예방형 유지 보수</li><li>개발된 소프트웨어의 품질은 다음과 같은 기준에 따라서 평가한다.<ul><li>정확성</li><li>유지 보수성 : 요구사하이 변동되었을 때 변경사항 처리 정도</li><li>무결성 : 보안성</li><li>사용성 : 사용자가 쉽게 사용할 수 있는 정도</li></ul></li></ul><hr><p><a name="2">2. 추상 데이터 타입</a></p><div align="center"><br><img src="/image/ds2-4.png"><br></div><p><strong>추상화(Abstraction)</strong>란 각종 정보들 중에서 필수적이고 중요한 특징만을 골라서 단순화시키는 작업이다.<br>컴퓨터에서 문제를 해결할 때도 추상화 작업을 적용, 복잡한 문제를 단순화시켜 좀더 쉽게 문제를 해결하는 방법을 찾는다.</p><ul><li>추상화 : ‘무엇(What)인가’를 논리적으로 정의</li><li>구체화 : ‘어떻게(How) 할 것인가’를 실제적으로 표현</li></ul><p><strong>자료 추상화(Data Abstraction)</strong>는 처리할 자료, 연산, 자료형에 대한 추상화 표현이다.</p><ul><li>데이터 : 프로그램의 처리 대상이 되는 모든 것</li><li>연산 : 어떤 일을 처리하는 과정, 연산자에 의해 수행</li><li>데이터 타입 : 처리할 데이터의 집합 + 수행할 수 있는 연산자의 집합<ul><li>시스템 정의 데이터 타입</li><li>사용자 정의 데이터 타입</li></ul></li></ul><p><strong>추상 자료형(ADT, Abstract Data Type)</strong>은 자료와 연산자의 특성을 논리적으로 추상화하여 정의한 자료형이다.</p><div align="center"><br><img src="/image/ds2-5.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/11/ds2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[자료구조] 자료구조 개요</title>
      <link>http://dudri63.github.io/2019/02/10/ds1/</link>
      <guid>http://dudri63.github.io/2019/02/10/ds1/</guid>
      <pubDate>Sun, 10 Feb 2019 08:59:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 자료구조란&lt;/a&gt;&lt;br&gt;1.1 자료구조란&lt;br&gt;1.2 자료구조를 배워야 하는 이유&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 자료구조 분류&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 자료의 표현&lt;/a&gt;&lt;br&gt;3.1 수치 자료의 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 자료구조란</a><br>1.1 자료구조란<br>1.2 자료구조를 배워야 하는 이유<br><a href="#2">2. 자료구조 분류</a><br><a href="#3">3. 자료의 표현</a><br>3.1 수치 자료의 표현<br>3.2 문자 자료의 표현<br>3.3 논리 자료의 표현<br>3.4 포인터 자료의 표현<br>3.5 문자열 자료의 표현</p><hr><p><a name="1">1. 자료구조란</a></p><p>1.1 자료구조란</p><p>컴퓨터는 자료를 처리하는 장치.<br>컴퓨터를 잘 사용한다는 것은 내가 원하는 대로 자료를 잘 처리한다는 뜻이다.<br>그런데 컴퓨터가 처리하는 자료에는 여러가지 형태가 있고, 그에 따라서 특징이 다르다.<br><strong>자료 구조</strong>란 다양한 자료들을 효율적으로 표현,저장,처리하기 위해서 어떻게, 어떤 구조로 구성하고 연산할 것인지를 정의하는 것이다.</p><p>1.2 자료구조를 배워야 하는 이유</p><p>소프트웨어나 프로그램의 개발 프로젝트에서 원하는 결과물을 얻었다고 해서 프로젝트가 성공했다가 할 수 는 없다.<br>얼마나 효율적으로 개발하였고, 사용 및 관리가 될 수 있는가가 중요하다.<br>그러기 위해서는 개발할 소프트웨어를 정확히 이해,<br>사용할 자료와 자료간의 연산 관계를 분석, 최적의 자료구조를 정의,<br>이에 대한 가장 효율적인 구조를 고안하여 개발해야 한다.<br>따라서 자료구조에 대한 이론적,실제적 내용을 반드시 알아야 한다. </p><div align="center"><br><img src="/image/ds1-1.png"><br>나쁜 자료구조와 좋은 자료구조<br></div><hr><p><a name="2">2. 자료구조 분류</a></p><p>자료를 형태에 따라 분류하면 다음과 같다.</p><div align="center"><br><img src="/image/ds1-2.png"><br></div><ul><li>단순 구조 : 데이터 타입에 해당</li><li>선형 구조 : 단순구조와 1:1 관계</li><li>비선형 구조 : 단순구조와 1:다, 다:다 관계</li><li>파일 구조</li></ul><p>표현하고자 하는 자료의 특성, 양, 사용 방법, 연산 종류, 구현에 필요한 용량 등을 고려하여 가장 효율적인 자료구조를 선택하여야 한다.</p><hr><p><a name="3">3. 자료의 표현</a></p><p>컴퓨터에서는 자료를 표현하기 위해 1과 0의 조합으로 구성된 이진수 코드를 사용한다.<br>숫자,문자,그림,소리 등의 다양한 형식의 자료는 컴퓨터 내부에서 오직 1,0의 이진수 코드 형태로 표현, 처리, 저장된다.</p><p>한 자리의 1 또는 0을 표현하는 단위를 <strong>비트(bit)</strong>라고 하는데,<br>비트는 디지털 시스템에서 자료를 표현하는 최소 단위이다.<br>8개의 비트 그룹을 <strong>바이트(Byte)</strong>라고 한다.<br>n개의 비트로 2<sup>n</sup>개의 상태를 표현할 수 있다.</p><div align="center"><br><img src="/image/ds1-3.png"><br>n개의 비트로 2<sup>n</sup>개의 상태 표현<br></div><hr><p>3.1 수치 자료의 표현</p><p>3.1.1 10진수의 표현</p><ul><li>10진수의 <strong>존(Zone) 형식</strong> 표현</li></ul><p>10진수 한 자리를 표현하기 위해서 1바이트(8비트)를 사용하는데, 상위 4비트의 존 영역과 하위 4비트의 수치 영역으로 이루어진다.</p><div align="center"><br><img src="/image/ds1-4.png"><br>존 형식의 구조<br></div><p>존 형식은 항상 1111로 표시,<br>각 영역은 4비트의 이진수이기 때문에 십진수 0~15로 표현할 수 있다.<br>(10은 A, 11은 B, 12는 C, 13은 D, 14는 E, 15는 F로 표기한다.)</p><p>표현하고자 하는 10진수의 자릿수만큼 존 형식을 연결하여 사용한다.<br>이 때, 부호는 최하위 바이트의 존 영역에 나타내는데, 양수일 경우, 1100=C, 음수일 경우, 1101=D로 표기한다.</p><p>다음은 +213, -213의 존 형식이다.</p><div align="center"><br><img src="/image/ds1-5.png"><br><br></div><ul><li>10진수의 <strong>팩(Pack) 형식</strong> 표현</li></ul><p>10진수를 존 형식으로 표현하라 경우, 최하위 바이트에서 부호를 표시하는 존 영역 이외의 다른 존 영역은 항상 1111이 들어가므로 기억 공간을 낭비하고 처리시간을 지연시키게 된다.<br>이에 반해 팩 형식에서는 1바이트에 10진수 두자리를 표현, 최하위 바이트의 하위 4비트에 부호를 표시한다.</p><div align="center"><br><img src="/image/ds1-6.png"><br><br></div><p>3.1.2 2진수의 ‘정수’ 표현</p><p>2진수는 일정한 길이의 n비트로 표현, 최상위 비트(MSB, Most Signficant Bit)인 첫 번째 1비트는 부호를 나타내고, 나머지 n-1 비트는 2진수 값을 표현한다.</p><ul><li><strong>부호절대값 형식</strong>의 표현</li></ul><p>부호절대값 형식은 최상위 비트에 부호를 표시, 나머지 비트에 2진수의 절대값을 표기한다.<br>부호가 양수일 경우, 최상위 비트를 0, 음수일 경우, 1로 한다.</p><p>다음은 +21, -21의 부호절대값 형식이다.<br>단, 1바이트를 사용하여 2진수를 표현한다고 가정한다.</p><div align="center"><br><img src="/image/ds1-7.png"><br><br></div><ul><li><strong>1의 보수(1’s Complement) 형식</strong>의 표현</li></ul><p>1의 보수 형식에서 양수의 표현 방법은 부호절대값 형식과 같고,<br>음수의 표현은 2진수를 1의 보수로 변환하여 표현한다.</p><p>n비트를 사용하여 2진수를 표기할 경우, 1의 보수를 만드는 방법은 전체 n비트를 1로 한 값에서 절대값을 뺀다.</p><p>다음은 +21,-21의 1의 보수 형식이다.<br>단, 1바이트를 사용하여 2진수를 표현한다고 가정한다.</p><div align="center"><br><img src="/image/ds1-8.png"><br><br><img src="/image/ds1-9.png"><br></div><ul><li><strong>2의 보수(2’s Complement) 형식</strong>의 표현</li></ul><p>2의 보수 형식에서 양수의 ㅍ현 방법은 부호절대값 형식과 같고,<br>음수의 표현은 2진술르 2의 보수로 변환하여 표현한다.</p><p>2의 보수를 만드는 방법은 1의 보수에 1을 더해준다.</p><p>다음은 +21, -21의 2의 보수 형식이다.<br>단, 1바이트를 사용하여 2진수를 표현한다고 가정한다.</p><div align="center"><br><img src="/image/ds1-10.png"><br><br><img src="/image/ds1-11.png"><br></div><p>부호절대값 표현 형식, 1의 보수 표현 형식, 2의 보수 표현 형식 모두 양수에 대한 표현 방법은 동이하다.<br>단, 음수를 표현하는 방법이 다르다.</p><ul><li>부호절대값 : n-1비트의 절대값으로 표현, 최상위 비트에 음수 부호 표기</li><li>1의 보수 : n비트의 1의 보수로 표현</li><li>2의 보수 : n비트의 2의 보수로 표현</li></ul><p>3.1.3 2진수의 ‘실수’ 표현</p><p>실수는 소수점을 가지고 있기 때문에 이에 대한 표현 방법이 필요하다.<br>2진수 실수의 표현 방법은 소수점의 위치가 고정되어 있는 <strong>고정 소수점 형식</strong>, 고정되어 있지 않은 <strong>부동 소수점 형식</strong>이 있다.</p><ul><li><strong>고정 소수점 형식</strong>의 표현</li></ul><p>고정소수점 표현 형식은 항상 최상위 비트의 왼쪽 밖에 고정되어 있는 것으로 취급한다.</p><p>ex. 00010101 -&gt; 0.00010101</p><ul><li><strong>부동 소수점 형식</strong>의 표현</li></ul><p>부동소수점 형식은 고정 소수점 형식에 비해 표현 가능한 값의 범위가 크다.<br>그리하여 아주 작은 값이나 아주 큰 값을 표현하는 것이 가능하다.<br>부호, 지수, 소수부, 총 세 부분으로 구성된다.</p><p>다음은 10진수 213에 대한 소수부, 지수에 대한 표현 형식이다.</p><div align="center"><br><img src="/image/ds1-12.png"><br><br></div><p>다음은 2진수의 부동 소수점 형식이다.<br>단, 4바이트를 사용한다고 가정한다.</p><div align="center"><br><img src="/image/ds1-13.png"><br><br></div><br>단, 부호 비트는 양수면 0, 음수면 1을 사용한다.<br><br><strong>**</strong><br><br>3.2 문자 자료의 표현<br><br>컴퓨터 내부에서 문자 자료 역시 1과 0의 2진수 조합으로 표현한다.<br>문자에 대한 2진 코드를 정의해놓은 문자 코드들이 있다.<br>BCD 코드, EBCDIC 코드, ASCII 코드, 유니코드 등이 그 예이다.<br>C를 비롯한 대부분의 프로그래밍 언어는 ASCII 코드를 사용, 자바는 유니코드를 사용한다.<br><br>3.2.1 BCD 코드<br><br><strong>BCD 코드</strong>는 6비트를 사용, 상위 2비트는 존 비트, 하위 4비트는 숫자 비트이다.<br><br>다음은 BCD 코드표이다.<br><br><div align="center"><br><img src="/image/ds1-14.png"><br><br></div><p>10진 숫자, 영어 대문자를 표현할 수 있다.</p><ul><li>존비트 00 : 1~9, 0</li><li>존비트 01 : A~I</li><li>존비트 10 : J~R</li><li>존비트 11 : S~Z<br>영문자 A에 대한 BCD 코드는 010001이다.</li></ul><p>3.2.2 EBCDIC 코드</p><p><strong>EBCDIC 코드</strong>는 8비트를 사용, 상위 4비트는 존 비트, 하위 4비트는 숫자 비트이다.</p><p>다음은 EBCDIC 코드의 구성이다.</p><div align="center"><br><img src="/image/ds1-15.png"><br><br></div><p>다음은 EBCDIC 코드표이다.</p><div align="center"><br><img src="/image/ds1-16.png"><br><br></div><p>10진수 숫자, 영어 대문자와, 소문자, 특수문자를 나타낼 수 있다.</p><ul><li>존비트 AB = 00 : 여분</li><li>존비트 AB = 01 : 특수 문자</li><li>존비트 AB = 10 : 영어 소문자<ul><li>존비트 CD = 00 : a~i</li><li>존비트 CD = 01 : j~r</li><li>존비트 CD = 10 : s~z</li></ul></li><li>존비트 AB = 11 : 영어 대문자<ul><li>존비트 CD = 00 : A~I</li><li>존비트 CD = 01 : J~R</li><li>존비트 CD = 10 : S~Z</li><li>존비트 CD = 11 : 숫자 0~9</li></ul></li></ul><p>3.2.3 ASCII 코드</p><p><strong>ASCII 코드</strong>는 7비트를 사용, 상위 3비트는 존 비트, 하위 4비트는 숫자 비트이다.</p><p>다음은 ASCII 코드표이다.</p><div align="center"><br><img src="/image/ds1-17.png"><br><br></div><p>10진수 숫자, 영어 대문자, 소문자, 특수문자를 나타낼 수 있다.<br>EBCDIC 코드와 유사하지만 ASCII 코드를 더 많이 사용한다.</p><p>데이터 통신용으로 ASCII 코드를 사용할 경우, 패리티 비트를 최상위 비트로 추가하여 8비트 형식으로 사용하기도 한다.</p><hr><p>3.3 논리 자료의 표현</p><p>논리자료는 논리값을 표현하기 위한 자료 형식이다.<br>논리값이란 참(True)과 거짓(False)의 두 가지 상태 중에서 하나를 표시하기 때문에 1비트로도 표현이 가능하다.<br>그러나 일반적으로 컴퓨터 내부에서는 1바이트를 사용한다.<br>1바이트를 사용하여 논리 자료를 표현하는 경우, 참, 거짓의 논리값을 표현하기 위한 방법들은 다음과 같다.</p><ol><li>참 : 00000001, 거짓 : 00000000</li><li>참 : 11111111, 거짓 : 00000000</li><li>참 : 8비트 중 어느 하나 이상의 비트가 1, 거짓 : 00000000</li></ol><hr><p>3.4 포인터(참조) 자료의 표현</p><p>포인터 자료는 메모리의 주소를 표현하고 사용하기 위한 자료 형식이다.<br>자료를 저장하고 있는 변수나 특정 위치에 대한 메모리상의 주소를 저장하고 주소 연산에 사용한다.<br>포인터 자료를 사용하면 복잡한 자료구조 연산을 메모리상에서의 주소 연산만으로 처리할 수 있다.</p><hr><p>3.5 문자열 자료의 표현</p><p>문자열(String) 자료는 하나의 문자만 표현할 수 있는 문자 자료와 달리 여러 문자로 이루어진 문자의 그룹을 하나의 자료로 취급한다.<br>그리하여 메모리상에 연속적으로 저장하는 자료 형식이다.</p><p>하나의 문자열 자료에 포함된 부분 문자열을 표현하는 방법들은 다음과 같다.</p><ol><li>부분문자열 사이에 ‘구분자’를 두고 연속 저장하는 방법<br><img src="/image/ds1-18.png"></li><li>가장 긴 부분문자열의 길이에 맞추어 ‘고정 길이’로 연속 저장하는 방법<br><img src="/image/ds1-19.png"></li><li>부분문자열을 연속 저장하고 각 부분문자열에 대한 ‘포인터’를 사용하는 방법<br><img src="/image/ds1-20.png"></li></ol><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>이지영, 『자바로 배우는 쉬운 자료 구조』. 서울: (주)한빛아카데미, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/10/ds1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 백트래킹 기법 (해 탐색)</title>
      <link>http://dudri63.github.io/2019/02/09/algo40/</link>
      <guid>http://dudri63.github.io/2019/02/09/algo40/</guid>
      <pubDate>Sat, 09 Feb 2019 07:54:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 백트래킹 기법&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. BacktrackTSP 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 백트래킹 기법&lt;/a&gt;&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 백트래킹 기법</a><br><a href="#2">2. BacktrackTSP 알고리즘</a><br><a href="#3">3. 시간복잡도</a></p><hr><p><a name="1">1. 백트래킹 기법</a></p><p><strong>‘백트래킹(Backtracking)</strong> 기법’은 해를 찾는 도중에 ‘막히면’ 되돌아가서 다시 해를 찾아가는 기법이다.<br>백트래킹 기법은 <strong>최적화(optimization) 문제</strong>와 <strong>결정(decision) 문제</strong>를 해결할 수 있다.<br>결정 문제란 문제의 조건을 만족하는 해가 존재하는지의 여부를 yes or no로 답하는 문제이다.<br>예시로 미로 찾기, 해밀토니안 사이클, 서양 장기 여왕 말, 부분 집합의 합 문제 등이 있다.</p><p>이전 포스팅에서 근사 알고리즘으로 해결한, NP-완전 문제인 <a href="https://dudri63.github.io/2019/02/04/algo35/">여행자 문제 (TSP)</a>를 백 트래킹 기법으로 해결하는 과정을 살펴본다. </p><hr><p><a name="2">2. BacktrackTSP 알고리즘</a></p><p>TSP를 위한 백트래킹 알고리즘은 다음과 같다.<br>단, bestSolution은 현재까지 찾은 가장 우수한 해이며, (tour,tour의 거리)로 나타낸다.<br>이 때, tour는 점의 순서이다.</p><p>tour = [시작점]            // tour는 점의 순서(sequence)<br>bestSolution = (tour, ∞)    // tour는 시작점만 가지므로 거리는 가장 큰 상수로 일단 초기화한다.<br>BacktrackTSP(tour)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (tour가 완전한 해이면)</span><br><span class="line">  if (tour의 거리 &lt; bestSolution의 거리) // 더 짧은 해를 찾았으면</span><br><span class="line">     bestSolution = (tour, tour의 거리)</span><br><span class="line">else &#123;</span><br><span class="line">  for (tour를 확장 가능한 각 점 v에 대해서)&#123;</span><br><span class="line">    newTour = tour + v // 기존 tour의 뒤에 점 v를 추가한다.</span><br><span class="line">    if (newTour의 거리 &lt; bestSolution의 거리)</span><br><span class="line">    BacktrackTSP(newTour)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>다음의 그림에 대해서 BacktrackTSP 알고리즘이 수행되는 과정을 살펴본다.<br>단, A가 시작점이다.</p><div align="center"><br><img src="/image/algo40-1.png"><br></div><ul><li>시작점이 A이므로 tour=[A], bestSolution = ([A], ∞)이다.<br>BacktrackTSP(tour)를 호출한다.</li><li>line 1 : [A]가 완전한 해가 아니므로, line 5의 for-루프가 수행</li><li>line 5 : tour=[A]를 확장할 수 있는 점은 B, C, D, E이다.<br>각 점에 대해서 for-루프가 수행된다.</li><li>점 B에 대해서 수행되는 경우를 가정한다.<br>line 6 : newTour = [A,B], newTour의 거리는 2가 된다.<br>line 7~8 : newTour의 거리 2가 bestSolution ∞보다 짧으므로, BacktrackTSP([A,B])를 재귀 호출한다.<ul><li>line 1 : [A,B]가 완전한 해가 아니므로, line 5의 for-루프가 수행</li><li>line 5 : tour=[A,B]를 확장할 수 있는 점은 C, D, E이다.<br>각 점에 대해서 for-루프가 수행된다.</li><li>점 C에 대해서 수행되는 경우를 가정한다.<br>line 6 : newTour = [A,B,C], newTour의 거리는 5가 된다.<br>line 7~8 : newTour의 거리 5가 bestSolution ∞보다 짧으므로, BackTrackTSP([A,B,C])를 재귀 호출한다.<br>…<br>이와 같이 계속 탐색을 진행하면 다음과 같은 첫 번째 완전한 해를 찾는다.<br>이 때, bestSolution=([A,B,C,D,E,A],30)이다.<br><img src="/image/algo40-2.png"></li><li>첫 번째 완전한 해를 찾은 후에 다음과 같이 수행, 더 짧은 해를 찾으므로 bestSolution=([A,B,C,E,D,A],18)이 된다.</li></ul></li><li>다음은 tour=[A,B]에 대해서 모든 수행을 마친 결과이다.<br>bestSolution=([A,B,E,C,D,A], 16)이 된다.<br><img src="/image/algo40-3.png"></li><li>다음은 tour=[A,C]에 대해서 모든 수행을 마친 결과이다.<br>bestSolution보다 더 우수한 해는 탐색되지 않았다.<br>x 표시는 중간 단계에서 이미 bestSolution보다 짧음이 확정되어 가지치기가 된 것이다.<br><img src="/image/algo40-4.png"></li><li>다음은 tour=[A,D]에 대해서 모든 수행을 마친 결과이다.<br>bestSolution보다 더 우수한 해는 탐색되지 않았다.<br><img src="/image/algo40-5.png"></li><li>tour=[A,E]에 대해서 모든 수행을 마치면, bestSolution보다 더 우수한 해는 탐색되지 않는다.<br>(그림 생략)</li><li>최종해=[A,B,E,D,D,A]이고, 거리=16이다.<br><img src="/image/algo40-6.png"></li></ul><hr><p><a name="3">3. 시간 복잡도</a></p><p>백트래킹 알고리즘의 시간 복잡도는 상태 공간 트리(state space tree)의 노드 수와 비례한다.<br>상태 공간 트리란 시작 상태인 [A]로부터 점들 tour에 추가하여 확장시켜 탐색한 모든 상태들로 형성된 트리를 말한다.<br>n개의 점이 있는 입력 그림에 대해서 BacktrackTSP 알고리즘이 탐색하는 최대 크기의 상태 공간 트리는 다음과 같다.</p><div align="center"><br><img src="/image/algo40-7.png"><br></div><p>위 트리의 leaf 노드 수만 하여도 (n-1)!이다.<br>이는 모든 경우를 다 검사하여 해를 찾는 완결탐새의 시간복잡도와 같다.<br>그러나 일반적으로 백트래킹 기법은 ‘가지치기’를 하므로 완결탐색보다 훨씬 효율적이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“9장 해 탐색 알고리즘”, 서강대학교 컴퓨터공학과, 2019. 2. 10, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjntMzW0LDgAhUCUt4KHb9RCkMQFjACegQICBAC&amp;url=http%3A%2F%2Fhompi.sogang.ac.kr%2F%40bb%2Fbboard.asp%3Fdb%3Dscsctrack_lecture2%26mode%3Ddownload%26num%3D28%26filename%3D09_backtracking.pdf&amp;usg=AOvVaw0X7DEzoPSOfKwWg0OUnvC0" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwjntMzW0LDgAhUCUt4KHb9RCkMQFjACegQICBAC&amp;url=http%3A%2F%2Fhompi.sogang.ac.kr%2F%40bb%2Fbboard.asp%3Fdb%3Dscsctrack_lecture2%26mode%3Ddownload%26num%3D28%26filename%3D09_backtracking.pdf&amp;usg=AOvVaw0X7DEzoPSOfKwWg0OUnvC0</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/09/algo40/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] Relational Data model</title>
      <link>http://dudri63.github.io/2019/02/08/db5/</link>
      <guid>http://dudri63.github.io/2019/02/08/db5/</guid>
      <pubDate>Fri, 08 Feb 2019 12:40:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1.&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. Relational Data model&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Relational data model : 관계형 데이터 모델&lt;ul&gt;
&lt;li&gt;represen
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1.</a></p><hr><p><a name="1">1. Relational Data model</a></p><ul><li>Relational data model : 관계형 데이터 모델<ul><li>representational(logical) model 중 가장 대중적인 모델</li><li>데이터를 <strong>관계(Relation)</strong>들의 집합으로 표현</li><li>My sql, Msl sql : R DBMS, 관계형 데이터 모델을 생성하는 DBMS<ul><li>DBMS 종류에 따라서 ‘표현 데이터 모델’이 달라짐. ex. 관계형, 계층형, 망형</li></ul></li><li>ex. 학생 relation<br><img src="/image/db5-1.png"></li></ul></li></ul><hr><p><a name="2"></a></p><p><a name="2">2. key attribute</a></p><p>Key는 entity type 내에 서로 다른 entity들을 구별할 수 있는 유일한 기준이 되는 attribute.</p><ol><li><p>후보키(Candidate Key)</p><ul><li>Entity type을 구성하는 속성들 중에서 Entity를 유일하게 식별할 수 있는 속성들의 부분집합</li><li>모든 Entity type은 반드시 하나 이상의 후보키를 가져야 한다.</li><li>Entity type에 있는 모든 Entity에 대해서 유일성과 최소성을 만족시켜야 한다.</li><li>ex. &lt;학생&gt; entity type에서 ‘학번’이나 ‘주민등록 번호’ attribute는 서로 다른 entity들을 유일하게 &gt;구별할 수 있다. 그러므로 후보키가 되어 기본키로도 사용할 수 있다.</li></ul></li><li><p>기본키(Primary Key)</p><ul><li>후보키들 중에서 선태한 주키(Main Key)</li><li>한 Entity type에서 특정 entity를 유일하게 구별할 수 있는 속성</li><li>Null 값을 가질 수 없다.</li><li>기본키로 정의된 속성에는 동일한 값이 중복되어 저장할 수 없다.</li><li>ex. &lt;학생&gt; entity type에는 ‘학번’이나 ‘주민등록 번호’가 기본키가 될 수 있다.</li></ul></li><li><p>대체키(Alternate Key)</p><ul><li>후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키들을 일컫음</li><li>‘보조키’라고도 한다.</li></ul></li><li><p>슈퍼키(Super Key)</p><ul><li>슈퍼키는 한 entity type 내에 있는 속성들의 집합으로 구성된 키, 모든 entity들은 슈퍼키로 구성된 속<br>성의 집합과 동일한 값을 지니지 않는다.</li><li>모든 entity들에 대하여 유일성은 만족, 그러나 최소성을 만족시키지 못함.</li><li>ex. &lt;학생&gt; entity type에서는 ‘학번’, ‘주민등록 번호’, ‘학번’+’주민등록 번호’, ‘학번’+’주민등록 번<br>호’+’성명’ 등으로 슈퍼키를 구성할 수 있다. 이 때, ‘학번’+’주민등록 번호’, ‘학번’+’주민등록 번호’+’성&gt;명’ 등이 최소성을 만족하지 못하는 경우이다.</li></ul></li></ol><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>*</p>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/08/db5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 클러스터링 문제 (근사)</title>
      <link>http://dudri63.github.io/2019/02/08/algo39/</link>
      <guid>http://dudri63.github.io/2019/02/08/algo39/</guid>
      <pubDate>Fri, 08 Feb 2019 03:12:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 클러스터링 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 클러스터링 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 클러스터링 문제</a></p><p>n개의 점이 2차원 평면에 주어질 때, 점들 간의 거리를 고려하여 k개의 그룹으로 나눈다.<br><strong>‘클러스터링(Clustering)’ 문제</strong>는 입력으로 주어진 n개의 점을 k개의 그룹으로 나누고, 각 그룹의 중심이 되는 k개의 점을 선택하는 문제이다.<br>단, 가장 큰 반경을 가진 그룹의 직경이 최소가 되도록 k개의 점이 선택되어야 한다.</p><p>n개의 점들 중에서 k개의 선택을 선택할 때, 하나씩 선택한다.</p><p>다음은 k개의 선택을 하는 예제이다.</p><div align="center"><br><img src="/image/algo39-1.png"><br></div><br>첫 번째 센터가 랜덤하게 정해졌다고 가정한다.<br><br><div align="center"><br><img src="/image/algo39-2.png"><br></div><br>위 그림에서 두 번째 센터는 어떤 것이 더 적합한가?<br>첫 번째 센터에서 가장 가까운 점, 가장 먼 점이 고려 대상이다.<br><br>2개의 센터가 서로 가까이 있는 것보다 멀리 떨어져 있는 것이 좋다.<br><br><div align="center"><br><img src="/image/algo39-3.png"><br></div><br>세 번째 센터는 첫 번째와 두 번째 센터에서 가장 멀리 떨어진 점을 선택한다.<br><br><strong>**</strong><br><br><a name="2">2. 알고리즘</a><br><br>다음은 위 그림과 같이 센터를 정하는 방법에 기반을 둔 근사 알고리즘이다.<br><br>Approx_k_Clusters<br>입력: 2차 평면상의 n개의 점 x<sub>i</sub>, i=0,1,…,n-1, 그룹의 수  k&gt;1<br>출력: k개의 클러스터 및 각 클러스터의 센터<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">C[1]=r, 단, xr은 n개의 점 중에서 랜덤하게 선택된 점이다.</span><br><span class="line">for j = 2 to k &#123;</span><br><span class="line">  for i = 0 to n-1</span><br><span class="line">    if (xi≠센터)</span><br><span class="line">      xi와 각 센터까지의 거리를 계산, xi와 가장 가까운 센터까지의 거리를 D[i]에 저장</span><br><span class="line">  &#125;</span><br><span class="line">    C[j]=i, 단, i는 배열 D의 가장 큰 원소의 인덱스, xi는 센터가 아니다.</span><br><span class="line">&#125;</span><br><span class="line">센터가 아닌 각 점 xi로부터 앞서 찾은 k개의 센터까지 거리를 각각 계산, 그 중에 가장 짧은 거리의 센터를 찾는다. 이 때 점 xi는 가장 가까운 센터의 클러스터에 속하게 된다</span><br><span class="line">return 배열 C와 각 클러스터에 속한 점들의 리스트</span><br></pre></td></tr></table></figure><br><br>(클러스터는 일종의 그룹이라고 생각하는 편이 좋을 거 같다.)<br><br>다음 2차원 평면에 놓인 점들에 대하여 위 알고리즘을 적용한다.<br><br><div align="center"><br><img src="/image/algo39-4.png"><br></div><p>위 그림에서 4개의 센터, 4개의 그룹으로 나눈다.</p><div align="center"><br><img src="/image/algo39-5.png"><br></div><p>line 1 : 임의의 점 하나를 첫 번째 센터 C1으로 정함<br>line 2 : j=2, 2번째 센터를 찾는다.<br>line 3~5 : C1을 제외한, 각 점 x<sub>i</sub>에서 C1 까지의 거리 D[i]를 계산</p><div align="center"><br><img src="/image/algo39-6.png"><br></div><p>line 6 : C1으로부터 거리가 가장 먼 점을 다음 센터 C2로 정한다.</p><p>line 2 : j=3, 3번째 센터를 찾는다.</p><div align="center"><br><img src="/image/algo39-7.png"><br></div><p>line 3~5 : C1, C2를 제외한, 각 점 x<sub>i</sub>에서 C1, C2 까지의 거리를 계산, 그 중 작은 값을 D[i]에 저장</p><p>D[1] = min{18,33} = 18<br>D[2] = min{19,25} = 19<br>D[3] = min{20,30} = 20<br>D[4] = min{22,17} = 17<br>…<br>와 같이 배열 D에 값이 저장된다.</p><div align="center"><br><img src="/image/algo39-8.png"><br></div><p>line 6 : 배열 D에서 가장 큰 값을 가진 원소의 인덱스가 C3이 된다.<br>즉, D[3]의 값이 가장 큼, C[3] = x<sub>3</sub></p><p>line 2 : j=4, 4번째 센터를 찾는다.<br>line 3~5 : C1, C2, C3를 제외한, 각 점 x<sub>i</sub>에서 C1, C2, C3까지의 거리를 계산, 그 중 작은 값을 D[i]에 저장</p><div align="center"><br><img src="/image/algo39-9.png"><br></div><p>line 6 : 배열 D에서 가장 큰 값을 가진 원소의 인덱스가 C4가 된다.</p><div align="center"><br><img src="/image/algo39-10.png"><br></div><p>line 7 : 센터가 아닌 각 점 x<sub>i</sub>로부터 위에서 찾은 4개의 센터까지의 거리를 각각 계산, 그 중 가장 짧은 거리의 센터를 찾음<br>각 점 x<sub>i</sub>는 가장 가까운 센터의 그룹에 속하게 된다.</p><p>line 8 : 4개의 센터와 각 점이 속한 그룹의 센터를 리턴</p><hr><p><a name="3">3. 시간복잡도</a></p><p>line 1 : 임의의 점 선택, O(1) 시간<br>line 3~5 : 각 점에서 각 센터까지의 거리를 계산, O(kn)<br>line 6 : 그 중에서 최댓값을 찾음 O(n)<br>그런데 line 2의 for-루프가 (k-1)회 반복, O(1)+(k-1)*(O(kn)+O(n))이다.<br>line 7 : 각 점으로부터 k개의 센터까지의 거리를 각각 계산, 최솟값을 찾음. O(kn) 시간 소요.<br>따라서 O(1)+(k-1)*(O(kn)+O(n))+O(kn)=O(k<sup>2</sup>n)이다.</p><hr><p><a name="4">4. 근사 비율</a></p><p>최적해가 만든 클러스터 중 가장 큰 직경을 OPT라고 한다.<br>OPT의 하한을 간접적으로 찾기 위해서, Approx_K_Clusters 알고리즘이 k개의 센터를 모두 찾은 뒤 (k+1)번째 센터를 찾는 상황을 가정한다.</p><div align="center"><br><img src="/image/algo39-11.png"><br></div><p>C5에서 가장 가까운 센터인 C3까지의 거리를 d라고 한다.<br>위 5개의 센터 점을 4개의 클러스터로 분할해야 한다.<br>따라서 4개의 센터 중에서 2개는 하나의 클러스터에 속해야만 한다.<br>위 그림에서는 C3, C5가 하나의 클러스터에 속한다.<br>그러므로 최적해의 가장 큰 그룹의 직경인 OPT는 d보다 작을 수 없다.</p><p>Approx_K_Clusters 알고리즘이 계산한 근사해의 가장 큰 그룹의 직경을 OPT’라고 한다.<br>센터가 아닌 어떤 점 중에서 센터와의 거리가 d보다 큰 경우는 없다.<br>따라서 각 클러스터의 중심으로 반경 d 이내에 클러스터에 속하는 모든 점들이 위치한다.<br>OPT’&lt;=2d</p><p>OPT &gt; d &gt;= OPT’/2<br>2OPT &gt; OPT’</p><p>따라서 Apporx_k_Clusters의 알고리즘의 근사비율은 2를 넘지 않는다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/08/algo39/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 작업 스케줄링 문제 (근사)</title>
      <link>http://dudri63.github.io/2019/02/08/algo38/</link>
      <guid>http://dudri63.github.io/2019/02/08/algo38/</guid>
      <pubDate>Fri, 08 Feb 2019 02:11:04 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 작업 스케줄링 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 작업 스케줄링 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 작업 스케줄링 문제</a></p><p><strong>‘작업 스케줄링(Job Scheduling)</strong> 문제’는 n개의 작업, 각 작업의 수행 시간 t<sub>i</sub>, i = 1,2,3,…,n, 그리고 m개의 동일한 기계가 주어질 때, 모든 작업이 가장 빨리 종료되도록 작업을 기계에 배정하는 문제이다. 단, 한 작업은 배정된 기계에서 연속적으로 수행, 기계는 1번에 하나의 작업만을 수행한다.</p><p>작업 스케줄링 문제를 해결하기 위한 가장 간단한 방법은 그리디 알고리즘을 이용하는 것이다.<br>즉, 배정된 작업이 가장 빨리 끝나는 기계에 새 작업을 배정하는 것이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>Approx_JobScheduling<br>입력: n개의 작업, 각 작업 수행 시간 t<sub>i</sub>, i= 1,2,…,n, 기계 M<sub>j</sub>, j = 1,2,…,m<br>출력: 모든 작업이 종료된 시간<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">for j = 1 to m// 초기화</span><br><span class="line">  L[j] = 0</span><br><span class="line">for i = 1 to n// n개의 작업을 배정</span><br><span class="line">  min = 1</span><br><span class="line">  for j = 2 to m &#123;</span><br><span class="line">    if (L[j]&lt;L[min])&#123;</span><br><span class="line">      min = j</span><br><span class="line">    &#125;</span><br><span class="line">  작업 i를 기계 Mmin에 배정</span><br><span class="line">  L[min] = L[min] + ti</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return 가장 늦은 작업 종료 시간</span><br></pre></td></tr></table></figure></p><p>작업의 수행시간이 각각 5, 2, 4, 3, 4, 7, 9, 2, 4, 1이고, 4개의 기계가 있을 때 위 알고리즘을 적용한 결과는 다음과 같다.</p><div align="center"><br><img src="/image/algo38-1.png"><br></div><div align="center"><br><img src="/image/algo38-2.png"><br></div><div align="center"><br><img src="/image/algo38-3.png"><br></div><p>가장 늦게 끝나는 작업의 종료 시간인 13을 리턴한다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>Approx_JobScheduling 알고리즘은 n개의 작업을 하나씩 가장 빨리 끝나는 기계에 배정한다.<br>이러한 기계를 찾기 위해 for-루프가 (m-1)번 수행된다.<br>따라서 O(m) 시간 동안 기계의 작업 종료 시간을 살핀다.<br>또한, n개의 작업을 배정하고, 마지막 line 10에서 배열을 탐색한다.<br>n*O(m) + O(m) = O(nm)</p><hr><p><a name="4">4. 근사 비율</a></p><p>Approx_JobScheduling 알고리즘의 근사해를 OPT’, 최적해를 OPT라고 한다.<br>OPT’ &lt;= 2*OPT이다.<br>왜냐하면 근사해는 최적해의 2배를 넘지 않는다.<br>그 이유는 다음과 같다.</p><div align="center"><br><img src="/image/algo38-4.png"><br></div><p>가장 마지막으로 배정된 작업 i가 T부터 수행, OPT’ = T + t<sub>i</sub>이다.<br>또한, T’는 작업 i를 제외한 평균 종료 시간이다.<br>따라서 T &lt;= T’이다.</p><div align="center"><br><img src="/image/algo38-5.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/08/algo38/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 통 채우기 (근사)</title>
      <link>http://dudri63.github.io/2019/02/08/algo37/</link>
      <guid>http://dudri63.github.io/2019/02/08/algo37/</guid>
      <pubDate>Fri, 08 Feb 2019 01:22:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 통 채우기 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 통 채우기 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 통 채우기 문제</a></p><p><strong>‘통 채우기(Bin Packing)</strong> 문제’는 n개의 물건이 주어지고, 통(bin)의 용량이 C일 때, 주어진 모든 물건을 가장 적은 수의 통에 채우는 문제이다. 단, 각 물건의 크기는 C보다 크지 않다.</p><p>이 문제에 대한 간단한 답은 그리디 알고리즘으로 해결하는 것이다.<br>그리디 방법은 ‘무엇에 욕심을 낼 것인가’에 따라서 4종류로 분류할 수 있다.</p><ul><li><strong>최초 접합</strong>(First Fit) : 첫 번째 통부터 차례대로 살펴보며, 가장 여유가 있는 통에 새 물건을 넣는다.</li><li><strong>다음 적합</strong>(Next Fit) : 직전에 물건을 넣은 통에 여유가 있으면 새 물건을 넣는다.</li><li><strong>최선 적합</strong>(Best Fit) : 기존의 통 중에서 새 물건이 들어가면 남는 부분이 가장 적은 토에 새 물건을 넣는다.</li><li><strong>최악 적합</strong>(Worst Fit) : 기존의 통 중에서 새 물건이 들어가면 남는 부분이 가장 큰 통에 새 물건을 넣는다.</li></ul><p>각 방법으로 새 물건을 기존 통에 넣을 수 없으면, 새로운 통에 새 물건을 넣는다.</p><p>다음은 통의 용량 C=10, 물건의 크기가 각각 [7,5,6,4,2,3,7,5]일 때, 최초 적합, 다음 적합, 최선 적합, 최악 적합을 적용하였을 때의 결과이다.</p><div align="center"><br><img src="/image/algo37-1.png"><br>처음 적합<br></div><div align="center"><br><img src="/image/algo37-2.png"><br>다음 적합<br></div><div align="center"><br><img src="/image/algo37-3.png"><br>최선 적합<br></div><div align="center"><br><img src="/image/algo37-4.png"><br>최악 적합<br></div><div align="center"><br><img src="/image/algo37-5.png"><br>최적 해<br></div><p>상기 4종류의 그리디 알고리즘 이외에도 최후 적합(Last Fit), 감소순 최초 적합(First Fit Decrease), 감소순 최선 적합(Best Fit Decrease) 등의 그리디 방법이 있다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 각 그리디 방법에 대한 근사 알고리즘이다.</p><p>Approx_BinPacking<br>입력: n개의 물건의 각각의 크기<br>출력: 모든 물건을 넣는 데 사용된 통의 수<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">B = 0 // 사용된 통의 수</span><br><span class="line">for i = 1 to n &#123;</span><br><span class="line">  if (물건 i를 넣을 여유가 있는 기존의 통)</span><br><span class="line">    그리디 방법에 따라 정해진 통에 물건 i를 넣는다.</span><br><span class="line">  else</span><br><span class="line">    새 통에 물건 i를 넣는다.</span><br><span class="line">    B = B + 1  // 통의 수 1 증가</span><br><span class="line">&#125;</span><br><span class="line">return B</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>새 물건을 넣을 때마다 기존의 통들을 살펴보아야 한다.<br>이 경우, 통의 수가 n을 넘지 않으므로 수행시간은 O(n<sup>2</sup>)이다.</p><p>단, 다음 적합의 경우, 직전에 사용된 통만 살펴보기 때문에 O(n)이다.</p><hr><p><a name="4">4. 근사 비율</a></p><ul><li>최초 적합, 최선 적합, 최악 적합</li></ul><p>모든 물건을 넣는 데 사용된 통의 수는 최적 해에서 사용된 통의 수의 2배를 넘지 않는다.<br>왜냐하면 2개 이상의 통이 1/2 이하로 차 있을 수 없기 때문이다.<br>만일 2개의 통이 각각 1/2 이하로 차 있다면, 각 방법은 새 통을 사용하지 않고, 2개의 통에 있는 물건을 1통으로 합친다.<br>최적해에서 사용된 통의 수를 OPT라고 하면, OPT &gt;= (모든 물건의 크기의 합)/C, C는 통의 크기.<br>각 방법이 사용한 통의 수가 OPT’라면, 다음과 같은 부등식이 성립한다.<br>(OPT’의 통 중 기껏해야 1개의 통이 1/2 이하로 차 있다. 또한, (OPT’-1)개의 통에 각각 1/2 넘게 물건을 채 울 때 그 물건의 크기의 합은 ((OPT’-1)*C/2보다 크다.)</p><p>(모든 물건의 크기의 합) &gt; (OPT’-1)*C/2<br>-&gt; (모든 물건의 크기의 합)/C &gt; (OPT’-1)/2<br>-&gt; OPT &gt;= (모든 물건의 크기의 합)/C &gt; (OPT’-1)/2<br>-&gt; OPT &gt; (OPT’-1)/2<br>-&gt; 2OPT &gt; OPT’-1<br>-&gt; 2OPT + 1 &gt; OPT’<br>-&gt; 2OPT &gt;= OPT’</p><p>따라서 이 때의 근사 비율은 2이다.</p><ul><li>다음 적합</li></ul><p>다음 적합은 직전에 사용된 통에 들어 있는 물건의 크기의 합과 새 물건의 크기의 합이 통의 용량보다 클 때만, 새 통에 새 물건을 넣는다.<br>이웃한 두 통의 합은 한 통의 full 용량인 C를 반드시 넘는다.<br>그러므로 다음과 같은 부등식이 성립한다.</p><p>(모든 물건의 크기의 합) &gt; OPT’/2*C<br>-&gt; (모든 물건의 크기의 합)/C &gt; OPT’/2<br>-&gt; OPT &gt; OPT’/2<br>-&gt; 2OPT &gt; OPT’</p><p>따라서 다음 적합의 근사 비율은 2이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/08/algo37/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] ER model</title>
      <link>http://dudri63.github.io/2019/02/04/db4/</link>
      <guid>http://dudri63.github.io/2019/02/04/db4/</guid>
      <pubDate>Mon, 04 Feb 2019 08:37:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. ER model&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Entity, Attribute, Entity type&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. Relationship, relationship type&lt;/a&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. ER model</a><br><a href="#2">2. Entity, Attribute, Entity type</a><br><a href="#3">3. Relationship, relationship type</a><br><a href="#4">4. Weak entity type, Weak relationship type</a><br><a href="#5">5. Higher-degree relationship</a></p><hr><p><a name="1">1. ER model</a></p><ul><li>ER model : Entity-Relationship data model<ul><li>high-levl(conceptual) data model 중 가장 대중적인 모델</li><li>구성요소 : Entity, Attribute, Relationship, Constraint</li><li>ex. 회사의 ER data model<br><img src="/image/db4-1.png"></li></ul></li></ul><hr><p><a name="2">2. Entity, Attribute, Entity type</a></p><ul><li>Entity : 현실세계에서 독립적인 실체로 존재하는 것</li><li>Attribute : Entity를 묘사하는 특징들<ul><li>동그라미로 표현</li><li>type<ul><li>composite or simple, composite은 하나의 동그라미에 또다른 동그라미가 달린 형태</li><li>single-valued of multivalued(이중타원)</li><li>stored or derived(테우리가 점선)</li><li>NULL values</li><li>Complex attributes</li></ul></li></ul></li><li>Entity type : 같은 attribute를 가지는 entity들의 집합<ul><li>네모로 표현</li><li>보통 entity가 하나로만 구성된 entity type은 만들지 않는다.(예외는 있음)</li><li>key attribute : entity type 내에 서로 다른 entity들을 구별할 수 있는 유일한 기준이 되는 attribute.<ul><li>ER model에서 밑줄을 그어 표기한다.</li></ul></li></ul></li></ul><hr><p><a name="3">3. RelationShip, RelationShip type</a></p><ul><li>RelationShip <ul><li>한 entity type의 attribute가 또다른 entity type을 언급할 때, relationship으로 참조를 나타낸다.</li><li>참조하는 attribute를 relationship type으로 변경한다.</li></ul></li><li>RleationShip type<ul><li>마름모로 표현</li><li>degree : 참여하는 entity type의 갯수</li><li>entity type과 relationship type 사이에 role name 지정 가능. recursive relationship type은 반드시 role name을 지정해야 한다.</li><li>ex. reculsive relationship type<br><img src="/image/db4-2.png"><br>위 경우, SUPERVISION relationship type에 참여하는 entity가 오직 하나, employee인데, 스스로를 referencint하고 있다. 이 때 role name은 각각 Supervisor, Supervisee.</li><li>Cardinality ratio constraint : entity가 참여할 수 있는 relationship instance의 최대갯수/ 1:1, 1:N, N:M</li><li>Participation consraint(참여 제약) : total or partial<ul><li>total : 하나 이상의 개체가 참여, 2줄로 표기</li><li>partial : 선택적인 참여, 1줄로 표기</li></ul></li><li>ex. 학생, 강의의 Cardinality ratio, 참여 제약<br><img src="/image/db4-3.png"><br>학생은 꼭 수강할 필요가 없음 -&gt; partial<br>과목은 항상 수강생이 있어야 함 -&gt; total<br>한 학생은 여러개의 과목을 수강할 수 있음 -&gt; M<br>한 과목을 수강하는 학생은 여러 명이 있을 수 있음 -&gt; N<br><img src="/image/db4-4.png"><br>사원은 소속 부서가 있어야 함 -&gt; total<br>사원이 없는 소속 부서는 없음 -&gt; total<br>한 부서에는 여러 명의 사원이 있을 수 있음 -&gt; N<br>한 사원은 오직 한 부서에만 소속됨 -&gt; 1</li><li>Attribute of relationship type<ul><li>relationship type에도 attribute가 있을 수 있음</li><li>1:1인 경우 어느 한 쪽의 entity type으로 이동할 수 있다.</li><li>1:N인 경우 N쪽의 entity type으로 이동할 수 있다.</li><li>M:N인 경우 이동할 수 없다.</li></ul></li></ul></li></ul><hr><p><a name="4">4. Weak Entity type, Weak RelationShip type</a></p><ul><li>Weak Entity type<ul><li>entity type의 특별한 한 종류</li><li>이중 사각형으로 표기</li><li>스스로 key attribute를 가지지 못한다.</li><li>partial key : weak entity type의 key<ul><li>점선 밑줄로 표기</li><li>부분키라고도 한다.</li><li><strong>있을 수도 있고, 없을 수도 있다.</strong></li></ul></li><li>단독으로 존재할 수 없으며, 자신을 소유하고 있는 Owner entity tpye의 key와 합쳐서 entity를 구분할 수 있음</li></ul></li><li>Weak Relationship type<ul><li>weak entity type이 onwer entity type과 연관될 때의 relationship type</li><li>이중 마름모로 표기</li></ul></li><li>ex. 사원과 부양가족 관계<br><img src="/image/db4-5.png"><br>DEPENDENT entity type은 스스로 내부 entity들을 구별할 수 없다.<br>따라서 Owner entity type인 Employee의 Ssn key와 partial key인 Name을 합쳐서 key로 사용한다.</li></ul><hr><p><a name="5">5. Higher-degree relationship</a></p><ul><li>일부 데이터베이스 디자인 툴에서는 무조건 binary relationship types만을 허용한다.<ul><li>이 경우, 하나의 relationship type에 세 개 이상의 entity type이 참여하지 못한다.</li></ul></li><li>higher-degree relationship은 툴에 따라 변경할 필요가 있다.</li><li>툴에 따라 변경할 필요가 있다.</li><li>ex. tenary relationship type의 변경<br><img src="/image/db4-6.png"><br><img src="/image/db4-7.png"><br>SUPPLY relationship type을 weak entity tpye으로 변경하였다.</li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/db4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] DB Design</title>
      <link>http://dudri63.github.io/2019/02/04/db3/</link>
      <guid>http://dudri63.github.io/2019/02/04/db3/</guid>
      <pubDate>Mon, 04 Feb 2019 07:54:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. DB Design&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Procedure of DB Design&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. DB Design&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DB desi
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. DB Design</a><br><a href="#2">2. Procedure of DB Design</a></p><hr><p><a name="1">1. DB Design</a></p><ul><li>DB design<ul><li>데이터베이스 스키마를 결정하는 것</li><li>다양한 디자인 방법론들이 존재한다.</li><li>본 포스팅에서는 여러 유저들과 애플리케이션에 의해 공유, 조직에 중요한 데이터베이스임을 가정한다.</li></ul></li><li>Information System<ul><li>특정 기관을 위해 데이터를 수집, 조직하여 저장된 정보를 생성하고 분배하는 수단</li><li>DBS를 이용하기 위해 조직상황을 제공</li><li>DB designer는 제공받은 Information System을 이용하여 Design</li><li>오늘날 micro life cycle</li></ul></li><li>DB design 목표<ul><li>한 개 또는 그 이상의 데이터베이스의 logical, physical design</li><li>현실 세계의 필요 사항을 정확하게 반영</li><li>정확한 평가가 어려움</li><li>정확도, 성능, 자연스러움 중요</li></ul></li><li>DB design 절차<ol><li>요구 수집, 분석</li><li>Conceptual DB design</li><li>DBMS 선택</li><li>Logical design</li><li>Physical design</li><li>시스템 구현 및 튜닝<div align="center"><br><img src="/image/db3-1.png"><br></div></li></ol></li></ul><hr><p><a name="2">2. Procedure of DB Design</a></p><ul><li>Phase 1 : 요구 수집, 분석<ul><li>정보를 수집한 뒤 분석</li><li>요구되는 기술들을 학습 또는 분석</li><li>현재의 기능 환경을 이해</li><li>ex. 회사 DB design을 위한 요구 수집, 분석<br><img src="/image/db3-2.png"><br><img src="/image/db3-3.png"></li></ul></li><li>Phase 2 : Conceptual DB design<ul><li>Conceptual 스키마 디자인 (ER dadta mdoel 등을 이용)</li><li>접근법<ul><li>Centralized(one shot) schema design approach (good option)</li><li>View integration approach (bad option)</li></ul></li><li>전략<ul><li>Top-dwon</li><li>Bottom-up</li></ul></li><li>ex. 회사 DB design을 위한 Coceptual DB design<br><img src="/image/db3-4.png"></li></ul></li><li>Phase 3 : DBMS 선택<ul><li>기술적, 경제적 문제를 고려하여 DBMS를 선택</li><li>DBMS마다 지원하는 데이터 타입이 다름, 하드웨어 타입에 따른 DBMS 이식성이 다름을 유의</li></ul></li><li>Phase 4 : Logical design<ul><li>data moel mapping (conceptual data model -&gt; representaion data model)</li><li>ex. 회사 DB design을 위한 Logical design<br><img src="/image/db3-5.png"></li></ul></li><li>Phase 5 : Physical design<ul><li>특정 파일 구조, 데이터베이스 access path를 선정</li><li>response time, space utilization, transaction throughput 등이 고려됨</li><li>이 과정은 DBMS에 의해 결정됨</li></ul></li><li>Phase 6 : 시스템 구현 및 튜닝</li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/db3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정점 커버 문제 (근사)</title>
      <link>http://dudri63.github.io/2019/02/04/algo36/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo36/</guid>
      <pubDate>Mon, 04 Feb 2019 06:48:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 정점 커버 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 정점 커버 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 정점 커버 문제</a></p><p><strong>‘정점 커버(Vertex Cover)’</strong> 문제는 주어진 그래프 G=(V,E)에서 각 선분의 양 끝점들 중에서 적어도 하나의 끝점을 포함하는 점들의 집합들 중에서 최소 크기의 집합을 찾는 문제이다.<br>정점 커버를 살펴보면, 그래프의 모든 선분이 정점 커버에 속한 점에 인접해 있다.<br>즉 정점 커버는 점들의 집합인데, 그래프의 모든 선분들이 집합내 점들 중 어느 하나라도 연결이 되있어야 한다.</p><p>구체적인 예는 다음과 같다.</p><div align="center"><br><img src="/image/algo36-1.png"><br></div><p>그래프 G에서 정점 커버는 다음과 같다.<br>{1,2,3}, {1,2}, {1,3}, {2,3}, {1}<br>{2}, {3}은 정점 커버가 아니다. 왜냐하면 선분(1,3)과 선분(1,2)를 각각 커버하지 못하기 때문이다.<br>정점 커버 문제는 최소 크기의 집합을 찾는 것이므로 해는 {1}이다.</p><p>주어진 그래프의 모든 선분을 커버하려면 일단 어떤 점을 선택해야 하는지 고려해야 한다.<br>우선 차수(degree)가 높은 점을 우선 선택하면 많은 수의 선분이 커버될 수 있다.<br>이 전략은 <a href="https://dudri63.github.io/2019/01/25/algo15/">‘집합 커버문제’</a>의 근사 알고리즘에서 사용된 것이다. 이 때의 근사 비율은 logn이다.</p><p>또 다른 방법은 점을 선택하는 대신에 선분을 선택하는 것이다.<br>선분을 선택하면 선택된 선분의 양 끝점에 인접한 선분이 모두 커버된다.<br>이 때 정점 커버는 선택된 각 선분의 양 끝점들로 이루어진 집합이다.</p><p>본 포스팅에서는 후자의 방법을 선택하여 정점 커버 문제를 해결한다.</p><p>정점 커버를 만들어가는 과정에서, 새로운 선분은 자신의 양 끝점들이 이미 선택된 선분의 양 끝점들의 집합에 포함되지 않을 때에만 중복을 피하기 위해 선택된다.</p><div align="center"><br><img src="/image/algo36-2.png"><br></div><br>예를 들어, 위 G 그래프에서 1개의 선분이 임의로 선택되었을 때, 선택된 선분 주변의 6개의 선분(점선으로 표시된 선분)은 정점 커버를 위한 선분으로서 선택되지 않는다. 왜냐하면 이미 선택된 선분(파란색 선분)의 양끝점(파란색 점)들이 점선으로 표시된 선분을 모두 커버하기 때문이다.<br><br>이러한 방식으로 선분을 선택하다가 더 이상 선분을 추가할 수 없을 때 중단한다.<br>이렇게 선택된 선분의 집합을 ‘극대 매칭(Maximal Matching)’이라고 한다.<br>매칭(matching)이란 각 선분의 양 끝점들이 중복되지 않는 선분의 집합이다.<br>극대 매칭은 이미 선택된 서분에 기반을 두고 새로운 선분을 추가하려 해도 더 이상 추가할 수 없는 매칭이다.<br><br><strong>**</strong><br><br><a name="2">2. 알고리즘</a><br><br>다음은 극대 매칭을 이용한 정점 커버를 위한 근사 알고리즘이다.<br><br>Approx_Matching_VC<br>입력: 그래프 G=(V,E)<br>출력: 정점 커버<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">입력 그래프에서 극대 매칭 M을 찾는다.</span><br><span class="line">return 매칭 M의 선부의 양 끝점들의 집합</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/image/algo36-3.png"><br></div><p>위 그림에서는 극대 매칭으로서 선분 a, b, c, d, e, f가 선택되었다.<br>근사해는 선분 a, b, c, d, e, f의 양 끝점들의 집합이다.<br>이 경우 12개의 점이다.<br>오른쪽 그래프는 최적해로서 7개의 점으로 구성되어 있다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>Approx_Matching_VC 알고리즘의 시간복잡도는 주어진 그래프에서 극대 매칭을 찾는 과정의 시간복잡도와 같다.<br>극대 매칭을 찾기 위해 하나의 선분 e를 선택한 후 e의 양 끝점들 중 적어도 하나가 이미 선택된 선분의 끝점이라면 e를 그래프에서 제거, 그렇지 않으면 e를 매칭에 추가한다.<br>이 후 e의 양 끝점에 인접한 모든 선분들을 그래프에서 제거해야 한다.<br>따라서 O(n) 시간이 걸린다.<br>입력 그래프의 선분수가 m이면, 각 선분에 대해서 O(n) 시간이 걸리므로, Approx_Matching_VC 알고리즘의 시간복잡도는 O(n)*m = O(nm))이다.</p><hr><p><a name="4">4. 근사 비율</a></p><p>Approx_Matching_VC 알고리즘의 근사 비율을 계산하기 위해 극대 매칭을 ‘간접적인’ 최적해로 사용한다.</p><p>Approx_Matching_VC 알고리즘은 극대 매칭의 각 선분의 양 끝점들의 집합을 정점 커버의 근사해로서 리턴, 근사해의 값은 극대 매칭의 선분 수의 2배이다.<br>(극대 매칭의 선분의 양 끝점들의 수) / (극대 매칭의 선분 수) = 2</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo36/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 여행자 문제 (근사)</title>
      <link>http://dudri63.github.io/2019/02/04/algo35/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo35/</guid>
      <pubDate>Mon, 04 Feb 2019 05:52:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 여행자 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 근사 비율&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 여행자 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 근사 비율</a></p><hr><p><a name="1">1. 여행자 문제</a></p><p><strong>‘여행자 문제(Traveling Salesman Problem, TSP)’</strong>는 여행자가 임의의 한 도시에서 출발하여 다른 모든 도시를 1회씩만 방문하고 다시 출발했던 도시로 돌아오는 여행 경로의 거리를 최소하하는 문제이다.<br>여기서 다루는 여행자 문제의 조건은 다음과 같다.</p><ul><li>도시 A에서 도시 B로 가는 거리 = 도시 B에서 도시 A로 가는 거리 (대칭성)</li><li>도시 A에서 도시 B로 가는 거리 &lt; 도시 A에서 도시 C를 경유하여 도시 B로 가는 거리 (삼각 부등식 특성)</li></ul><p>TSP를 위한 근사 알고리즘을 고안하려면, 먼저 다항식 시간 알고리즘을 가지면서 유사한 특성을 가진 문제를 찾아서 활용해보는 것이 좋다.<br>이전에 다룬 <a href="https://dudri63.github.io/2019/01/21/algo12/">‘최소 신장 트리 문제(MST)’</a>가 TSP와 유사한 특정을 가진다.<br>최소 신장 트리는 모든 점을 사이클 없이 연결하는 트리 중에서 트리 선분의 가중치의 합이 최소인 트리이다.<br>따라서 모든 점을 연결하고, 선분의 가중치의 합이 최소인 최소 신장 트리의 특서을 응용, 시작도시를 제외한 다른 모든 도시를 트리 선분을 따라 1번씩 방문하도록 경로를 찾는다.</p><p>이러한 과정을 아래의 그림을 이용하여 이해할 수 있다.</p><div align="center"><br><img src="/image/algo35-1.png"><br></div><p>그래프 G에서 크러스컬 또는 프림 알고리즘을 이용하여 최소 신장 트리를 찾는다.<br>임의의 도시(그림에서는 1번)에서 출발하여 트리의 선분을 따라서 모든 도시를 방문하고 돌아오는 도시의 방문 순서를 구한다.<br>[1 2 4 3 4 5 4 6 7 6 4 2 1]<br>마지막으로 이 순서를 따라서 도시를 방문하되 중복 방문하는 도시를 순서에서 제거, 여행자 문제의 근사해를 구한다.<br>단, 출발 도시와 도착 도시는 같으므로 중복을 허용한다.<br>[1 2 4 3 5 6 7 1]</p><p>중복하여 방문하는 도시를 제거하는 과정이 삼각형 부등식 원리가 적용된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 최소 신장 트리에 기반한 여행자 문제의 근사 알고리즘이다.</p><p>Approx_MST_TSP<br>입력: n개의 도시, 각 도시 간의 거리<br>출력: 출발 도시에서 각 도시를 1번씩만 방문, 출발 도시로 돌아오는 도시 순서<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">입력에 대해서 최소 신장 트리를 찾는다.</span><br><span class="line">최소 신장 트리에서 임의의 도시로부터 출발하여 트리의 선분을 따라서 모든 도시를 방문하고 다시 출발했던 도시로 돌아오는 도시 방문 순서를 찾는다.</span><br><span class="line">return 이전 단계에서 찾은 도시 순서에서 중복되어 나타는 도시레르 제거한 도시 순서</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간복잡도</a></p><p>line 1 : 최소 신장 트리를 찾음. 크러스컬이나 프림 알고리즘의 시간 복잡도<br>line 2 : 트리 선분을 따라서 도시 방문 순서를 찾는데 O(n) 시간이 걸림. 왜냐하면 트리의 선분 수가 (n-1)이기 때문이다.<br>(추후 논의 필요)<br>line 3 : line 2에서 찾은 도시 방문 순서를 따라가며, 중복된 도시를 제거 O(n) 시간.</p><p>따라서 크러스컬이나 프림 알고리즘의 시간복잡도와 같다.</p><hr><p><a name="4">4. 근사비율</a></p><p>여행자 문제의 최적해를 실질적으로 알 수는 없다.<br>‘간접적인’ 최적해인 최소 신장 트리 선분의 가중치의 합(M)을 최적해의 값으로 활용한다.<br>실제의 최적해의 값은 M보다 항상 크다.</p><p>line 2 : 최소 신장 트리의 선분을 따라서 도시 방문 순서를 찾을 때 각 선분이 2번 사용된다. 경로의 총 길이는 2M<br>line 3 : 삼각 부등식의 원리 이용, 새로운 도시 방문 순서를 만듬. 경로의 길이가 짧아짐</p><p>알고리즘의 근사비율은 2M/M=2보다 크지 않다.<br>즉, 근사해의 값이 최적해의 값의 2배를 넘지 않는다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“제 8장 근사 알고리즘”, 창원대학교 정보 시각화 연구실, 2019. 2. 4, <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r" rel="external nofollow noopener noreferrer" target="_blank">https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwi8tdO9vaHgAhUFNrwKHWUdBQUQFjADegQIABAC&amp;url=http%3A%2F%2Fivis.kr%2Fimages%2F6%2F6f%2F8%25EC%259E%25A5%25EA%25B7%25BC%25EC%2582%25AC%25EC%2595%258C%25EA%25B3%25A0%25EB%25A6%25AC%25EC%25A6%2598.pdf&amp;usg=AOvVaw1kJL1wlCTDoYjsRLAisv-r</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo35/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 근사 알고리즘</title>
      <link>http://dudri63.github.io/2019/02/04/algo34/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo34/</guid>
      <pubDate>Mon, 04 Feb 2019 05:45:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;NP-완전 문제들은 실생활의 광범위한 영역에 활용되지만, 불행히도 이 문제들을 다항식 시간에 해결할 수 있는 알고리즘이 아직 발견되지 않았다.&lt;br&gt;또한 그렇다고 해서 이 문제들을 다항식 시간에 해결할 수 없다고 증명이 되지도 않았다.&lt;br&gt;그러
        
      
      </description>
      
      <content:encoded><![CDATA[<p>NP-완전 문제들은 실생활의 광범위한 영역에 활용되지만, 불행히도 이 문제들을 다항식 시간에 해결할 수 있는 알고리즘이 아직 발견되지 않았다.<br>또한 그렇다고 해서 이 문제들을 다항식 시간에 해결할 수 없다고 증명이 되지도 않았다.<br>그러나 대부분의 학자들은 다항식 시간 알고리즘으로 NP-완전 문제를 해결할 수 없을 것이라고 생각한다.<br>NP-완전 문제들을 해결하려면 보통 다음의 세 가지 중 하나를 포기한다.</p><ul><li>다항식 시간에 해를 찾는 것</li><li>모든 입력에 대해 해를 찾는 것</li><li>최적 해를 찾는 것</li></ul><p><strong>‘근사(Approximation) 알고리즘’</strong>은 세 번째 것을 포기한다.<br>즉, 최적해에 근사한 해를 찾는 대신 다항식 시간의 복잡도를 가진다.<br>그러나 근사 알고리즘은 최적해를 구하는 것이 아니기 때문에 근사해가 최적해에 얼마나 근사한 것인지를 나타내는 <strong>근사 비율(Approximaton ratio)</strong>을 알고리즘과 함께 제시하여야 한다.</p><p>근사 비율은 근사해의 값과 최적해의 값의 비율로서, 1.0에 가까울수록 정확도가 높은 것이 된다.<br>그런데 근사 비율을 계산하려면 최적해를 알아야 하는 모순이 또한 발생한다.<br>따라서 최적해를 대신할 수 있는 <strong>간접적인</strong> 최적해를 찾고, 이를 최적해로 삼아서 근사 비율을 계산한다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo34/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 계산 복잡도 이론</title>
      <link>http://dudri63.github.io/2019/02/04/algo33/</link>
      <guid>http://dudri63.github.io/2019/02/04/algo33/</guid>
      <pubDate>Mon, 04 Feb 2019 04:26:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 쉬운 문제, 어려운 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. P 문제, NP 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. NP 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 문제의 환원&lt;/a&gt;&lt;br&gt;&lt;a h
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 쉬운 문제, 어려운 문제</a><br><a href="#2">2. P 문제, NP 문제</a><br><a href="#3">3. NP 알고리즘</a><br><a href="#4">4. 문제의 환원</a><br><a href="#5">5. NP-하드 문제, NP-완전 문제</a></p><hr><p><a name="1">1. 쉬운 문제, 어려운 문제</a></p><p>컴퓨터를 사용하여 특정한 계산 문제를 풀기 위해서는, 그 문제에 해당되는 알고리즘을 컴퓨터에게 알려주어야 한다.<br>이 때, 컴퓨터공학자들의 주된 관심사는 그 <strong>알고리즘이 문제를 얼마나 빨리 해결할 수 있느냐</strong>이다.<br>그리하여 알고리즘의 시간복잡도라는 개념이 출현하였고, 시간복잡도에 따라 알고리즘을 분류할 수 있다.</p><ul><li>쉬운(tractable) 문제 : 다항식 시간복잡도를 가진 알고리즘으로 해결 가능</li><li>어려운(intractable) 문제 : 다항식보다 큰 시간복잡도를 가진 알고리즘으로 해결</li></ul><p>만약 어떤 알고리즘이 개발되었다고 하더라도, 그 알고리즘이 다항식 시간에 동작하지 않는다면 어려운 문제라고 간주한다.<br>왜냐하면 다항식 시간에 동작하지 않는다는 것은 너무나도 비효율적인 알고리즘이기 때문이다.<br>예를 들어 O(25<sup>n</sup>)의 시간복잡도를 갖는 알고리즘은 n이 커지면, 사실상 해결하기가 어렵다.<br>그리하여 다항식보다 큰 시간복잡도를 갖는다면, 우주가 온 힘을 모아도 풀기 어렵다.<br>물론, 다행히도 수학,과학적으로 중요한 많은 문제들이 다항식 시간 알고리즘을 갖는다.</p><hr><p><a name="2">2. P문제, NP 문제</a></p><p>답이 yes or no로 반환되는 문제를 <strong>‘결정(decsion) 문제’</strong>라고 한다.<br>예를 들어, 다음과 같은 질문은 결정 문제라고 한다.</p><p>각 도시를 1번씩만 방문하고 시작도시로 돌아오는 경로의 거리가 K보다 짧은 경로가 있는가?</p><p><strong>P 문제</strong>와 <strong>NP 문제</strong>는 모두 위와 같은 결정 문제의 분류에 해당한다.<br>P문제와 NP 문제에 대한 개념은 다음과 같다.</p><ul><li>P 문제 : 결정 문제들 중에서 <strong>쉽게 풀리는 것</strong>들을 모아놓은 집합<br>(Polynomial)</li><li>NP 문제 :  결정 문제들 중에서 <strong>적어도 검산은 쉽게 할 수 있는 것</strong>들을 모아놓은 집합<br>(Non-deterministic Polynomial)</li></ul><p>어떤 결정 문제가 주어졌을 때, 다항식 시간 이내에 그 문제의 답을 yes or no로 계산해낼 수 있는 알고리즘이 존재한다면, 그 문제는 P문제이다.<br>이에 반해, 어떤 결정 문제의 답이 yes일 때, 그 문제의 답이 yes라는 것을 입증하는 <strong>힌트</strong>가 주어지면, 그 힌트를 사용해서 문제의 답이 정말로 yes라는 것을 다항식 시간 이내에 확인할 수 있는 문제가 NP문제이다.</p><p>예를 들어, {-5,6,1,2,-10,-7,13}과 같이 정수로 이루어진 집합과 다음과 같은 결정 문제가 주어진 상황을 가정한다.</p><p>‘이 집합의 부분집합들 중에서 원소의 합이 0이 되는 집합이 존재하는가?’</p><p>위 문제는 아직까지 다항식 시간 알고리즘이 알려져 있지 않다.<br>단순하게 생각해도, 모든 경우의 부분집합을 테스트하지 않는 이상 yes or no로 답하기가 어렵다.<br>그런데, 누군가가 {6,1,-7}이라는 힌트를 제공하면,<br>힌트가 주어진 집합의 부분집합이라는 것을 확인,<br>부분집합의 원소들의 합이 0이라는 것을 확인함으로써,<br>원래 문제의 답을 yes로 답할 수 있게 된다.<br>따라서 위 문제는 NP 문제인 것을 확실시할 수 있다.</p><p>만약 어떤 P 문제가 주어지고, 그 문제의 답이 YES라고 하면, 그 문제의 답에 관한 힌트를 받더라도 그냥 무시, 곧바로 그 문제의 답이 YES라는 것을 쉽게 확인할 수 있을 것이다.<br>따라서 <strong>모든 P문제는 저절로 NP 문제도 된다.</strong><br>즉, P⊂NP이다.</p><div align="center"><br><img src="/image/algo33-5.png"><br></div><p>하지만 그 반대인 NP⊂P에 대해서는 참인지 거짓인지 아직 알려지지 않았다.<br>만약 모든 NP 문제가 P 문제인 경우, 즉, 모든 NP 문제가 다항 시간에 풀 수 있는 알고리즘이 존재함을 증명할 경우, P=NP문제라는 결론이 된다.<br>이는 밀레니엄 문제 중 하나로서, 100만 달러가 걸린 문제이지만 아직 풀리지가 않았다.<br>많은 컴퓨터공학자들은 P=NP일리가 없다고 믿고 있지만, 올바른 증명을 아직 찾아내지 못하였다.</p><hr><p><a name="3">3. NP 알고리즘</a></p><p>NP 알고리즘의 정의는 다음과 같다.</p><p>NP 알고리즘은 </p><ul><li>첫 번째 단계에서 주어진 입력에 대해서 하나의 해를 ‘추측’하고, </li><li>두 번째 단계에서 그 해를 다항식 시간에 확인, 그 해가 ‘맞다’라고 답한다.<br>즉 해가 맞는지 아닌지를 다항시간 내에 판별할 수 있다.</li></ul><p>NP 알고리즘은 해를 찾는 알고리즘이 아니라, 해를 다항식 시간에 확인하는 알고리즘이다.</p><p>P 문제가 NP 문제에 속하는 이유는 NP 알고리즘을 이용하여 설명할 수도 있다.<br>일단, P 문제를 해결한 데 다항식 시간이 걸리는 것은 자명하다.<br>그리고 P 문제를 위한 NP 알고리즘은 해를 추측하는 단계(1)를 생략,<br>해를 확인하는 단계 대신에 해를 직접 다항식 시간에 구하고,<br>확인 결과를 ‘맞다’라고 하면 되기 때문이다.</p><p>다음은 NP 알고리즘을 적용하는 예이다.<br>주어진 문제는 다음과 같다.</p><p>각 도시를 한 번씩만 방문하고 시작도시로 돌아오는 경로 중 가장 짧은 경로는 무엇인가?</p><p>위 문제는 일단 결정 문제가 아니기 때문에 결정 문제로 변형하여야 한다.<br>변형한 문제는 다음과 같다.</p><p>각 도시를 한 번씩만 방문하고 시작도시로 돌아오는 경로의 거리가 K보다 짧은 경로가 있는가?</p><p>문제의 답은 그러한 경로가 있으면 ‘yes’, 없으면 ‘no’가 된다.<br>8개 도시(A B C D E F G H)에 대한 여행자 문제의 NP-알고리즘은 다음과 같다.<br>단, A가 시작도시이다.</p><ol><li>하나의 해를 추측한다. A G D H F E B C를 추측했다고 가정한다.</li><li>추측한 해의 값을 계산한다. 해의 값 = (A~G) + (G~D) + … + (B~C)</li><li>해의 값이 K보다 작으면 ‘맞다’라고 대답한다.</li></ol><p>두 번째 단계에서 계산에 소요되는 시간은 선형 시간임을 알 수 있다.<br>8개 도시 간 거리를 합하는 데 걸리는 시간은 8번의 덧셈 연산, 계산된 해의 값과 K를 비교하는 데 1번의 비교 연산이 걸리기 때문이다.</p><hr><p><a name="4">4. 문제의 환원</a></p><p>문제 A를 해결하기 위해서 문제 B를 해결하는 알고리즘을 이용하려는 경우를 가정한다.<br>이를 위해, 문제 A의 입력을 문제 B의 입력 형태로 변환시키는 것은 <strong>문제의 환원(변환)</strong>이라고 한다.<br>변환된 입력으로 문제 B를 해결하는 알고리즘을 수행 가능하고, 또한, 수행 결과로서 나온 해를 문제 A의 해로 변환하여 문제 A를 해결할 수 있다.</p><p>이에 대한 예제는 다음과 같다.<br>문제 A는 부분 집합의 합을 구하는 문제,<br>문제 B는 동일한 크기로 분할하는 문제이다.</p><ul><li>부분 집합의 합 문제: 정수들의 집합 S에 대하여 S의 부분 집합들 중에서 원소의 합이 K가 되는 부분 집합을 찾는 문제</li><li>분할 문제 : 정수들의 집합 S에 대하여 S를 분할, 원소들의 합이 같은 2개의 부분 집합을 찾는 문제<br>예를 들어, S={20, 35, 45, 70, 80}이 주어지면, X={20,35,70}, Y={45,80}이 해이다.</li></ul><p>‘부분 집합의 합 문제’의 입력인 집합 S를 ‘분할 문제’의 입력으로 변환할 때 t를 집합 S에 추가한다.<br>단, t = s-2K<br>(s는 집합 S의 모든 원소의 합) </p><p>‘부분 집합의 합 문제’를 해결하기 위해, 집합 S’= S∪{t}를 입력으로 하는 ‘분할 문제’를 위한 알고리즘을 이용한다.<br>‘분할 문제’의 경우, 알고리즘의 해인 2개의 집합 X, Y는 각 집합에 속한 원소의 합(s-K)이 같다.<br>왜냐하면 집합 S’의 모든 원소의 합은 s+t = s+(s-2K) = 2s-2k이기 때문이다.</p><p>‘분할 문제’의 해인 X와 Y 중에서 t를 가진 집합에서 t를 제거한 집합이 ‘부분 집합의 합 문제’의 해가 된다.<br>왜냐하면 만일 X에 t가 속해 있었다면, X에서 t를 제외한 원소의 합 (s-K)-t = (s-K)-(s-2K) = s-K-s+2K = K가 되기 때문이다.<br>그러므로 ‘부분 집합의 합 문제’의 해는 X-{t}이다.</p><div align="center"><br><img src="/image/algo33-2.png"><br></div><p>위 경우의 시간복잡도는 다음의 3단계 시간복잡도의 합이다.</p><ol><li>문제 A의 입력을 문제 B의 입력으로 변환하는 시간</li><li>문제 B를 위한 알고리즘이 수행되는 시간</li><li>문제 B의 해를 문제 A의 해로 변환하는 시간</li></ol><p>위에서 첫 단계, 세 번째 단계는 단순한 입출력 변환, 다항식 시간에 수행된다.<br>따라서 문제 변환의 시간복잡도는 두 번째 시간복잡도에 따라 결정된다.<br>두 번째 단계가 다항식 시간이 걸리면, 문제 A도 다항식 시간에 해결된다.</p><hr><p><a name="5">5. NP-하드 문제, NP-완전 문제</a></p><div align="center"><br><img src="/image/algo33-3.png"><br></div><p>문제 A와 문제 B 사이에 이러한 관계가 성립하면, 문제 A가 문제 B로 다항식 시간에 변환(polynomial time reduction) 가능하다고 한다.</p><p>어느 문제 A에 대해서, 만일 모든 NP 문제가 문제 A로 다항식 변환이 가능하다면, 문제 A는 <strong>NP-하드(NP-난해) 문제</strong>이다.</p><p>간단하게, NP-하드 문제는 위 여행자 문제나 부분집합의 합 문제와 같이 모든 경우의 수를 전부 확인해보는 방법 이외에는 정확한 답을 구할 수 있는 뾰족한 수가 없는 문제들을 뜻하기도 한다.</p><div align="center"><br><img src="/image/algo33-4.png"><br></div><p><strong>NP-완전 문제</strong>에 대한 정의는 다음과 같다.</p><p>문제 A가 NP-완전 문제가 되려면,</p><ol><li>문제 A는 NP문제이고, 동시에</li><li>문제 A는 NP-하드 문제이다.</li></ol><p>만약 NP-완전 문제가 P문제라면, ‘모든 NP 문제가 P 문제’라는 것이 증명된다.<br>만약 이것이 증면되면 그 동안의 알고리즘에 대한 연구가 완전히 바뀌게 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>‘P-NP 문제’, 나무위키, 2019. 2. 10, <a href="https://namu.wiki/w/P-NP%20%EB%AC%B8%EC%A0%9C" rel="external nofollow noopener noreferrer" target="_blank">https://namu.wiki/w/P-NP%20%EB%AC%B8%EC%A0%9C</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/04/algo33/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] 데이터 모델, DBMS 구조</title>
      <link>http://dudri63.github.io/2019/02/03/db2/</link>
      <guid>http://dudri63.github.io/2019/02/03/db2/</guid>
      <pubDate>Sun, 03 Feb 2019 10:23:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Data Abstraction&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Data model&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. Data Schema, Instance&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 3-
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Data Abstraction</a><br><a href="#2">2. Data model</a><br><a href="#3">3. Data Schema, Instance</a><br><a href="#4">4. 3-level arcitecture, Data independence</a><br><a href="#5">5. DB language</a></p><hr><p><a name="1">1. Data Abstraction</a></p><ul><li>데이터 추상화<ul><li>현실세계의 사물을 개념화, 단순화하고 데이터적인 측면과 기능적인 측면으로 분리 정의</li><li>데이터에 대한 조작을 효과적으로 수행할 수 있는 수단을 제공해주는 작업 또는 기능</li><li>데이터 필수 특징 강조</li><li>프로그램-데이터 독립 허가</li><li>DBMS가 제공하는 기능</li></ul></li></ul><hr><p><a name="2">2. Data model</a></p><ul><li>데이터 모델<ul><li>데이터베이스의 구조를 묘사하는 개념들의 집합</li><li>데이터 추상화가 그 목적</li><li>데이터 구조를 결정</li><li>연산에 대한 내용도 포함</li></ul></li><li>데이터 모델 목록<ul><li>High-level (Conceptual Data model)<ul><li>E-R data moel (Entity-Relationship)이 가장 대중적이다.</li><li>E-R data model : Entity - 현실 세계의 개념이나 사물, Attribute - entitiy의 속성,성질, Relationship - 둘 이상의 entity간의 관계 </li></ul></li><li>Low-level (Pyhsical Data Model)<ul><li>data가 어떻게 file로서 저장되는 지를 묘사한다.(데이터 저장 방법)</li><li>포맷, 순서, 접근 경로 등을 기술</li></ul></li><li>Representation data model<ul><li>Relational data moel 이 가장 대중적이다.</li><li>Relational data moel : 대부분의 DBMS에서 사용, 모든 정보를 ‘표’로 표현</li><li>hierarchical data moel, network data model 등도 있다.</li></ul></li><li>Object-oriented data model<ul><li>conceptual data model에 가까운 새로운 data model</li><li>객체 지향 특성을 가진다.</li></ul></li></ul></li></ul><hr><p><a name="3">3. Database Schema, Instance</a></p><ul><li>데이터베이스 스키마<ul><li>데이터베이스의 묘사(meta db에 포함되어 있음)</li><li>데이터베이스의 구조, 데이터 타입, 제약 조건 등을 포함</li><li>데이터베이스 카탈로그에 저장된다.(meta db는 catalog 형태로 저장됨)</li><li>DDL을 이용하여 DB designer가 변경</li><li>자주 변경되지 않는 편이 좋다.<br><div align="center"><br><img src="/image/db2-1.png"></div></li></ul></li></ul><p></p><ul><li>데이터베이스 인스턴스<ul><li>특정 순간에 데이터베이스에 있는 데이터들</li><li>DML의 update 기능에 의해 자주 변경됨</li><li>현실 세계의 변화 반영이 필수적이다.</li><li>= database state, snapshot<div align="center"><br><img src="/image/db2-2.png"><br></div></li></ul></li></ul><hr><p><a name="4">4. 3-level architecture, Data Independence</a></p><ul><li>3-level architecture<ul><li>DBMS의 특징을 지원하게 위해 고안되었다.<ul><li>프로그램과 데이터 격리</li><li>데이터의 다중뷰 지원</li></ul></li><li>데이터를 3단계(internal level, conceptual level, external level)로 관리<ul><li>이 때 관리를 받는다는 것은 DBMS에 의한 것이다.</li><li>Internal level : 데이터베이스의 물리적인 저장소 구조를 묘사</li><li>Conceptual level : 유저들을 위한 전체 데이터베이스 구조를 묘사</li><li>External level : 특정 그룹의 유저들이 관심있는 데이터베이스의 일부분을 묘사</li></ul></li></ul></li><li>데이터 독립성<ul><li>Data Independence</li><li>3-level arichitecture에 의해 상위 level에 영향을 주지 않고, 해당 level이 바뀔 수 있는 것</li><li>Logical data independece : conceptual level의 변화가 external level에 영향을 주지 않음</li><li>Physical data independence : physical levle의 변화가 conceptual level에 영향을 주지 않음<div align="center"><br><img src="/image/db2-3.png"><br></div></li></ul></li></ul><p>cf. Data model : DB Designer에게 필요한 내용, 3-level arichitecture : DBMS에게 필요한 내용</p><hr><p><a name="5">5. DB language</a></p><ul><li>DDL (Data Definition Language)<ul><li>Schema를 정의(define)하기 위해 이용된다.</li><li>주로 DB designer에 의해 이용</li></ul></li><li>DML (Data Manipulation Language)<ul><li>DB로의 검색, 삽입, 삭제, 업데이트 등을 가능하게 한다.</li><li>DML Commands는 host language에 내장 가능</li><li>Application programmer에 의해 주로 이용된다.</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/db2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] DBS, DB, DBMS, 이용자, DB approach</title>
      <link>http://dudri63.github.io/2019/02/03/db1/</link>
      <guid>http://dudri63.github.io/2019/02/03/db1/</guid>
      <pubDate>Sun, 03 Feb 2019 07:19:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Database System&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Database&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. DBMS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. Database Users&lt;/a&gt;&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Database System</a><br><a href="#2">2. Database</a><br><a href="#3">3. DBMS</a><br><a href="#4">4. Database Users</a><br><a href="#5">5. DB Approach</a></p><hr><p><a name="1">1. Database System</a></p><ul><li>DBS(데이터베이스 시스템) : 자료를 데이터베이스에 저장, 관리하며 필요한 정보를 제공하는 컴퓨터 기반 시스템이다.</li><li>DBS 구성요소 :<ul><li>Database (DB)</li><li>Database management system (DBMS)</li><li>Database users</li></ul></li></ul><hr><p><a name="2">2. Database</a></p><ul><li>데이터베이스<ul><li>상호 관련있는 데이터들의 집합<ul><li>데이터란 의미가 있고, 저장할 수 있는 것이다.</li></ul></li><li>현실 세계의 정보들을 나타낸다.</li><li>특정한 목적을 위하여 설계된다.</li><li>현실 세계의 정보인 sotred data와 stored data를 위한 데이터인 meta data가 저장된다.</li><li>데이터베이스의 예 :<ul><li>University database</li><li>Company database</li></ul></li></ul></li></ul><hr><p><a name="3">3. DBMS</a></p><ul><li>DBMS (Database Management System)<ul><li>데이터베이스를 관리하는 프로그램</li><li>데이터베이스 이용자(user)와 데이터베이스간의 Interface<ul><li>DBMS를 이용하여 이용자는 쉽게 데이터베잇를 생성 및 유지할 수 있다.</li></ul></li></ul></li><li>DBMS의 주요 기능<ul><li>정의 : 데이터에 대한 형식, 구조, 제약조건들을 명세<ul><li>이 때, 데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.(meta data)</li></ul></li><li>구축 : DBMS가 관리하는 기억 장치에 데이터를 저장</li><li>조작 : 특정한 데이터를 검색하기 위한 질의, 데이터 갱신, 보고서 생성 기능 등</li><li>공유 : 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능</li><li>보호 : 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호</li><li>유지보수 : 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능</li></ul></li></ul><hr><p><a name="4">4. Database Users</a></p><ul><li>End Users : application programmer에 의해 개발된 application program을 통해 database에 접근하는 사람들</li><li>Application Programmers : 애플리케이션 개발자<ul><li>시스템 분석에 관한 지식, host language(ex. JSP, ASP)를 알고 있어야 한다.</li><li>SQL의 DML(Data Manipulation Language)을 알아야 한다.</li></ul></li><li>Database designers<ul><li>database를 설계하기 위한 현실 세계의 요구사항들을 파악한다.</li><li>저장될 데이터, 적절한 구조를 선정</li><li>SQL의 DDL(Data definition Language)을 알아야 한다.</li></ul></li><li>DBA (Database Administrators)<ul><li>데이터베이스 접근 권한을 설정한다.</li><li>데이터베이스 운영, 관리를 책임진다.</li></ul></li></ul><div align="center"><br><img src="/image/db1-1.png"><br></div><hr><p><a name="5">5. DB Approach</a></p><ul><li>DB Approach<ul><li>data를 유지하는 저장소는 한 개 있다.(여러 저장소를 사용하지 않는다.)</li><li>저장소는 다양한 유저들에 의해 접근될 수 있다.</li></ul></li><li>DB Approach 특징<ul><li>자기기술성(Self-describing nature of a database system)</li><li>프로그램과 데이터 격리(Insulation between programs and data)</li><li>데이터 추상화(Data abstraction)</li><li>데이터의 다중뷰(multiple view) 지원</li><li>data 공유 &amp; 멀티유저(multi user)</li></ul></li></ul><hr><ul><li>자기기술성<ul><li>데이터베이스 시스템은 데이터베이스에 포함된 데이터 + 설명(meta)</li><li>파일 시스템과 구별되는 특징</li><li>데이터베이스 카탈로그(meta database)는 stored database와 같은 방식으로 접근할 수 있다.</li><li>DBMS가 데이터의 삽입 및 삭제를 데이터/구조적 종속 없이 가능하게 해준다.</li></ul></li><li>프로그램과 데이터 격리<ul><li>단일한 응용 프로그램 내에서 데이터를 개별적으로 관리하는 방식은 데이터 구조 등이 변경되면 응용 프로그램도 수정되어야 한다.</li><li>하지만 데이터베이스는 저장 구조 등을 수정하는 것이 응용 프로그램에 영향을 미치지 않는다.</li></ul></li><li>데이터 추상화 <ul><li>복잡한 데이터베이스의 구조에 대한 정보를 감추고, 각 사용자에게는 ‘뷰’를 제공한다.</li><li>실제로는 복잡한 구조지만 상부 이용자에게는 간단하게 보이도록 한다.</li></ul></li><li>데이터 다중뷰 지원<ul><li>뷰 : 데이터베이스의 subset</li><li>이용자마다 다른 목적을 커버 가능하다.</li><li>각 이용자에게 필요한 것만 보이게 함으로써 보안성을 높일 수 있다.</li><li>처리 시간이 걸린 다는 단점이 있다.</li></ul></li><li>data 공유 &amp; 멀티유저(multi user)<ul><li>DBMS는 다수 유저의 동시 접근을 허가한다.</li><li>‘동시성 제어’</li></ul></li></ul><hr><p>cf. 데이터베이스의 추가적인 특징</p><ul><li>데이터베이스는 동일한 내용의 데이터가 중복되어 있지 않아야 하고, 다양한 접근 방식이 마련되어 있어야 하며, 검색이나 갱신이 효율적으로 이루어질 수 있도록 해야 한다.</li><li>RAM, ROM 같은 주기억장치가 아닌 컴퓨터에서 사용할 수 있는 보조기억장치에 저장된다.</li></ul><p>cf. 파일 시스템</p><p>데이터 독립성, 데이터 중복성, 무결성 보장, 동시 접근 등에 문제가 있음<br>-&gt; DB approach의 장점과 대비</p><hr><ul><li>DB Approach의 장점<ul><li>중복 최소화</li><li>권한 없는 접근 제한</li><li>storage stucture 제공 및 효율적인 검색 프로세싱 가능(Indexes, Buffering, Caching, etc.)</li><li>Backup, Recovery</li><li>다양한 이용자 interface를 제공</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li><li>데이터베이스, 위키피디아, 2019. 2. 3, <a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C" rel="external nofollow noopener noreferrer" target="_blank">https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C</a></li><li>데이터베이스, 나무위키, 2019. 2. 3, <a href="https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2" rel="external nofollow noopener noreferrer" target="_blank">https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/db1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 외부 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo32/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo32/</guid>
      <pubDate>Sun, 03 Feb 2019 06:17:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 외부 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 외부 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 외부 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 외부 정렬</a></p><p><strong>‘외부 정렬(External Sort)’</strong>은 입력 크기가 매우 커서 읽고 쓰는 시간이 오래 걸린느 보조 기억 장치에 입력을 저장할 수 밖에 없는 상태에서 수행되는 정렬을 일컫는다.<br>예를 들어, 컴퓨터의 주기억 장치의 용량이 1GB이고, 정렬할 입력의 크기가 100GB이면, 어떤 내부정렬 알고리즘으로도 정렬할 수 없다.</p><p>외부 정렬은 입력을 분할, 주기억 장치에서 수용할 만큼의 데이터에 대해서만 내부정렬을 수행, 그 결과를 보조 기억 장치에 저장한다.<br>예를 들어, 100GB의 데이터를 1GB만큼씩 주기억 장치로 읽어 들이고, 퀵 정렬과 같은 내부정렬 알고리즘을 이용하여 정렬, 이 후, 다른 보조 기억 장치에 저장한다.<br>이것을 반복하면 원래의 입력 100GB가 100개씩 정렬된 블록으로 분할되어 보조 기억 장치에 저장된다.</p><div align="center"><br><img src="/image/algo32-1.png"><br></div><p>그 다음으로 정렬된 블록들을 하나의 정렬된 거대한 블록(100GB)으로 만들어야 한다.<br>이를 위해 합병(merge)를 반복 수행한다.<br>즉, 블록들을 부분적으로 주기억 장치에 읽어 들여서, 합병을 수행, 부분적으로 보조 기억 장치에 쓰는 과정을 반복한다.</p><p>다음은 1GB 블록 2개가 2GB 블록 1개로 합병되는 과정이다.</p><div align="center"><br><img src="/image/algo32-2.png"><br><img src="/image/algo32-3.png"><br></div><p>2개의 블록을 부분적으로 주기억 장치로 읽어들인다.</p><p>나머지 98개의 블록에 대해서 위 과정을 49회 추가로 반복하면, 2GB 블록 50개가 만들어진다.<br>그 다음에는 2GB 블록 2개씩 짝을 지워 합병시키는 과정을 25회 반복하여, 4GB 블록 25개가 만들어진다.<br>이러한 방식으로 계속 합병을 진행하면, 블록 크기가 2배씩 커지고, 블록의 수는 1/2씩 줄어들어 결국 100GB 블록 1개만 남는다.</p><p>외부정렬 알고리즘은 보조 기억 장치에서의 읽고 쓰기를 최소화하는 것이 중요하다.<br>왜냐하면 보조 기억 장치의 접근시간(access time)이 오래 걸리기 때문이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>ExternalSort<br>입력: 입력 데이터 저장된 입력 HDD<br>출력: 정렬된 데이터가 저장된 출력 HDD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">입력 HDD에 저장된 입력을 크기가 M만큼씩 주기억 장치에 읽어 들인 후 내부 정렬 알고리즘으로 정렬하여 별도의 HDD에 저장한다. 다음 단계에서는 별도의 HDD는 입렬 HDD로 사용, 입력HDD는 출력 HDd로 사용된다.</span><br><span class="line">while (입력 HDD에 저장된 블록 수 &gt; 1) &#123;</span><br><span class="line">  입력 HDD에 저장된 블록을 2개씩 선택, 각각의 블록으로부터 데이터를 부분적으로 주기억 장치에 읽어 들여서 합병을 수행한다. 이때 합병된 결과는 출력 HDD에 저장한다. 단, 입력 HDD가 저장된 블록 수가 홀수일 때에는 마지막 블록은 그대로 출력 HDD에 저장한다.</span><br><span class="line">&#125;</span><br><span class="line">return 출력 HDD</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>외부정렬은 전체 데이터를 몇 번 처리하는가를 가지고 시간복잡도를 측정한다.<br>전체 데이터를 읽고 쓰는 것을 <strong>패스(pass)</strong>라고 한다.</p><p>위 알고리즘의 경우, while-루프를 마치면 1 패스가 수행된 것이다.<br>그러므로 while-루프가 수행된 횟수가 알고리즘의 시간복잡도가 된다.</p><p>입력 크기가 N, 메모리 크기가 m이면, line 3이 한번 수행될 때마다 블록 크기가 2M,4M, 2<sup>k</sup>M으로 증가한다. 만일 마지막에 만들어진 블록 1개의 크기가 2<sup>k</sup>M이면, 이 블록은 입력 전체가 합병된 결과를 가지고 있다. 즉, 2<sup>k</sup>M = N이다.<br>따라서 k = log<sub>2</sub>(N/M)이고, k는 while-루프가 수행된 횟수이다.<br>그러므로 외부정렬의 시간복잡도는 O(log(N/M))이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo32/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
