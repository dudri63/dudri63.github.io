<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Seo&#39;s Blog</title>
    <link>http://dudri63.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Sun, 03 Feb 2019 11:46:41 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>[DataBase] 데이터 모델, DBMS 구조</title>
      <link>http://dudri63.github.io/2019/02/03/db2/</link>
      <guid>http://dudri63.github.io/2019/02/03/db2/</guid>
      <pubDate>Sun, 03 Feb 2019 10:23:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Data Abstraction&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Data model&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. Data Schema, Instance&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 3-
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Data Abstraction</a><br><a href="#2">2. Data model</a><br><a href="#3">3. Data Schema, Instance</a><br><a href="#4">4. 3-level arcitecture, Data independence</a><br><a href="#5">5. DB language</a></p><hr><p><a name="1">1. Data Abstraction</a></p><ul><li>데이터 추상화<ul><li>현실세계의 사물을 개념화, 단순화하고 데이터적인 측면과 기능적인 측면으로 분리 정의</li><li>데이터에 대한 조작을 효과적으로 수행할 수 있는 수단을 제공해주는 작업 또는 기능</li><li>데이터 필수 특징 강조</li><li>프로그램-데이터 독립 허가</li><li>DBMS가 제공하는 기능</li></ul></li></ul><hr><p><a name="2">2. Data model</a></p><ul><li>데이터 모델<ul><li>데이터베이스의 구조를 묘사하는 개념들의 집합</li><li>데이터 추상화가 그 목적</li><li>데이터 구조를 결정</li><li>연산에 대한 내용도 포함</li></ul></li><li>데이터 모델 목록<ul><li>High-level (Conceptual Data model)<ul><li>E-R data moel (Entity-Relationship)이 가장 대중적이다.</li><li>E-R data model : Entity - 현실 세계의 개념이나 사물, Attribute - entitiy의 속성,성질, Relationship - 둘 이상의 entity간의 관계 </li></ul></li><li>Low-level (Pyhsical Data Model)<ul><li>data가 어떻게 file로서 저장되는 지를 묘사한다.(데이터 저장 방법)</li><li>포맷, 순서, 접근 경로 등을 기술</li></ul></li><li>Representation data model<ul><li>Relational data moel 이 가장 대중적이다.</li><li>Relational data moel : 대부분의 DBMS에서 사용, 모든 정보를 ‘표’로 표현</li><li>hierarchical data moel, network data model 등도 있다.</li></ul></li><li>Object-oriented data model<ul><li>conceptual data model에 가까운 새로운 data model</li><li>객체 지향 특성을 가진다.</li></ul></li></ul></li></ul><hr><p><a name="3">3. Database Schema, Instance</a></p><ul><li>데이터베이스 스키마<ul><li>데이터베이스의 묘사(meta db에 포함되어 있음)</li><li>데이터베이스의 구조, 데이터 타입, 제약 조건 등을 포함</li><li>데이터베이스 카탈로그에 저장된다.(meta db는 catalog 형태로 저장됨)</li><li>DDL을 이용하여 DB designer가 변경</li><li>자주 변경되지 않는 편이 좋다.<br><div align="center"><br><img src="/image/db2-1.png"></div></li></ul></li></ul><p></p><ul><li>데이터베이스 인스턴스<ul><li>특정 순간에 데이터베이스에 있는 데이터들</li><li>DML의 update 기능에 의해 자주 변경됨</li><li>현실 세계의 변화 반영이 필수적이다.</li><li>= database state, snapshot<div align="center"><br><img src="/image/db2-2.png"><br></div></li></ul></li></ul><hr><p><a name="4">4. 3-level architecture, Data Independence</a></p><ul><li>3-level architecture<ul><li>DBMS의 특징을 지원하게 위해 고안되었다.<ul><li>프로그램과 데이터 격리</li><li>데이터의 다중뷰 지원</li></ul></li><li>데이터를 3단계(internal level, conceptual level, external level)로 관리<ul><li>이 때 관리를 받는다는 것은 DBMS에 의한 것이다.</li><li>Internal level : 데이터베이스의 물리적인 저장소 구조를 묘사</li><li>Conceptual level : 유저들을 위한 전체 데이터베이스 구조를 묘사</li><li>External level : 특정 그룹의 유저들이 관심있는 데이터베이스의 일부분을 묘사</li></ul></li></ul></li><li>데이터 독립성<ul><li>Data Independence</li><li>3-level arichitecture에 의해 상위 level에 영향을 주지 않고, 해당 level이 바뀔 수 있는 것</li><li>Logical data independece : conceptual level의 변화가 external level에 영향을 주지 않음</li><li>Physical data independence : physical levle의 변화가 conceptual level에 영향을 주지 않음<div align="center"><br><img src="/image/db2-3.png"><br></div></li></ul></li></ul><p>cf. Data model : DB Designer에게 필요한 내용, 3-level arichitecture : DBMS에게 필요한 내용</p><hr><p><a name="5">5. DB language</a></p><ul><li>DDL (Data Definition Language)<ul><li>Schema를 정의(define)하기 위해 이용된다.</li><li>주로 DB designer에 의해 이용</li></ul></li><li>DML (Data Manipulation Language)<ul><li>DB로의 검색, 삽입, 삭제, 업데이트 등을 가능하게 한다.</li><li>DML Commands는 host language에 내장 가능</li><li>Application programmer에 의해 주로 이용된다.</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/db2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[DataBase] DBS, DB, DBMS, 이용자, DB approach</title>
      <link>http://dudri63.github.io/2019/02/03/db1/</link>
      <guid>http://dudri63.github.io/2019/02/03/db1/</guid>
      <pubDate>Sun, 03 Feb 2019 07:19:25 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. Database System&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. Database&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. DBMS&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. Database Users&lt;/a&gt;&lt;br&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. Database System</a><br><a href="#2">2. Database</a><br><a href="#3">3. DBMS</a><br><a href="#4">4. Database Users</a><br><a href="#5">5. DB Approach</a></p><hr><p><a name="1">1. Database System</a></p><ul><li>DBS(데이터베이스 시스템) : 자료를 데이터베이스에 저장, 관리하며 필요한 정보를 제공하는 컴퓨터 기반 시스템이다.</li><li>DBS 구성요소 :<ul><li>Database (DB)</li><li>Database management system (DBMS)</li><li>Database users</li></ul></li></ul><hr><p><a name="2">2. Database</a></p><ul><li>데이터베이스<ul><li>상호 관련있는 데이터들의 집합<ul><li>데이터란 의미가 있고, 저장할 수 있는 것이다.</li></ul></li><li>현실 세계의 정보들을 나타낸다.</li><li>특정한 목적을 위하여 설계된다.</li><li>현실 세계의 정보인 sotred data와 stored data를 위한 데이터인 meta data가 저장된다.</li><li>데이터베이스의 예 :<ul><li>University database</li><li>Company database</li></ul></li></ul></li></ul><hr><p><a name="3">3. DBMS</a></p><ul><li>DBMS (Database Management System)<ul><li>데이터베이스를 관리하는 프로그램</li><li>데이터베이스 이용자(user)와 데이터베이스간의 Interface<ul><li>DBMS를 이용하여 이용자는 쉽게 데이터베잇를 생성 및 유지할 수 있다.</li></ul></li></ul></li><li>DBMS의 주요 기능<ul><li>정의 : 데이터에 대한 형식, 구조, 제약조건들을 명세<ul><li>이 때, 데이터베이스에 대한 정의 및 설명은 카탈로그나 사전의 형태로 저장된다.(meta data)</li></ul></li><li>구축 : DBMS가 관리하는 기억 장치에 데이터를 저장</li><li>조작 : 특정한 데이터를 검색하기 위한 질의, 데이터 갱신, 보고서 생성 기능 등</li><li>공유 : 여러 사용자와 프로그램이 데이터베이스에 동시에 접근하도록 하는 기능</li><li>보호 : 하드웨어나 소프트웨어의 오동작 또는 권한이 없는 악의적인 접근으로부터 시스템을 보호</li><li>유지보수 : 시간이 지남에 따라 변화하는 요구사항을 반영할 수 있도록 하는 기능</li></ul></li></ul><hr><p><a name="4">4. Database Users</a></p><ul><li>End Users : application programmer에 의해 개발된 application program을 통해 database에 접근하는 사람들</li><li>Application Programmers : 애플리케이션 개발자<ul><li>시스템 분석에 관한 지식, host language(ex. JSP, ASP)를 알고 있어야 한다.</li><li>SQL의 DML(Data Manipulation Language)을 알아야 한다.</li></ul></li><li>Database designers<ul><li>database를 설계하기 위한 현실 세계의 요구사항들을 파악한다.</li><li>저장될 데이터, 적절한 구조를 선정</li><li>SQL의 DDL(Data definition Language)을 알아야 한다.</li></ul></li><li>DBA (Database Administrators)<ul><li>데이터베이스 접근 권한을 설정한다.</li><li>데이터베이스 운영, 관리를 책임진다.</li></ul></li></ul><div align="center"><br><img src="/image/db1-1.png"><br></div><hr><p><a name="5">5. DB Approach</a></p><ul><li>DB Approach<ul><li>data를 유지하는 저장소는 한 개 있다.(여러 저장소를 사용하지 않는다.)</li><li>저장소는 다양한 유저들에 의해 접근될 수 있다.</li></ul></li><li>DB Approach 특징<ul><li>자기기술성(Self-describing nature of a database system)</li><li>프로그램과 데이터 격리(Insulation between programs and data)</li><li>데이터 추상화(Data abstraction)</li><li>데이터의 다중뷰(multiple view) 지원</li><li>data 공유 &amp; 멀티유저(multi user)</li></ul></li></ul><hr><ul><li>자기기술성<ul><li>데이터베이스 시스템은 데이터베이스에 포함된 데이터 + 설명(meta)</li><li>파일 시스템과 구별되는 특징</li><li>데이터베이스 카탈로그(meta database)는 stored database와 같은 방식으로 접근할 수 있다.</li><li>DBMS가 데이터의 삽입 및 삭제를 데이터/구조적 종속 없이 가능하게 해준다.</li></ul></li><li>프로그램과 데이터 격리<ul><li>단일한 응용 프로그램 내에서 데이터를 개별적으로 관리하는 방식은 데이터 구조 등이 변경되면 응용 프로그램도 수정되어야 한다.</li><li>하지만 데이터베이스는 저장 구조 등을 수정하는 것이 응용 프로그램에 영향을 미치지 않는다.</li></ul></li><li>데이터 추상화 <ul><li>복잡한 데이터베이스의 구조에 대한 정보를 감추고, 각 사용자에게는 ‘뷰’를 제공한다.</li><li>실제로는 복잡한 구조지만 상부 이용자에게는 간단하게 보이도록 한다.</li></ul></li><li>데이터 다중뷰 지원<ul><li>뷰 : 데이터베이스의 subset</li><li>이용자마다 다른 목적을 커버 가능하다.</li><li>각 이용자에게 필요한 것만 보이게 함으로써 보안성을 높일 수 있다.</li><li>처리 시간이 걸린 다는 단점이 있다.</li></ul></li><li>data 공유 &amp; 멀티유저(multi user)<ul><li>DBMS는 다수 유저의 동시 접근을 허가한다.</li><li>‘동시성 제어’</li></ul></li></ul><hr><p>cf. 데이터베이스의 추가적인 특징</p><ul><li>데이터베이스는 동일한 내용의 데이터가 중복되어 있지 않아야 하고, 다양한 접근 방식이 마련되어 있어야 하며, 검색이나 갱신이 효율적으로 이루어질 수 있도록 해야 한다.</li><li>RAM, ROM 같은 주기억장치가 아닌 컴퓨터에서 사용할 수 있는 보조기억장치에 저장된다.</li></ul><p>cf. 파일 시스템</p><p>데이터 독립성, 데이터 중복성, 무결성 보장, 동시 접근 등에 문제가 있음<br>-&gt; DB approach의 장점과 대비</p><hr><ul><li>DB Approach의 장점<ul><li>중복 최소화</li><li>권한 없는 접근 제한</li><li>storage stucture 제공 및 효율적인 검색 프로세싱 가능(Indexes, Buffering, Caching, etc.)</li><li>Backup, Recovery</li><li>다양한 이용자 interface를 제공</li></ul></li></ul><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>Elmasri, Navathe,『Fundamentals of Database System』, Pearson, 2011</li><li>데이터베이스, 위키피디아, 2019. 2. 3, <a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C" rel="external nofollow noopener noreferrer" target="_blank">https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EA%B4%80%EB%A6%AC_%EC%8B%9C%EC%8A%A4%ED%85%9C</a></li><li>데이터베이스, 나무위키, 2019. 2. 3, <a href="https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2" rel="external nofollow noopener noreferrer" target="_blank">https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4#s-2</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/db1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 외부 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo32/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo32/</guid>
      <pubDate>Sun, 03 Feb 2019 06:17:45 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 외부 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 외부 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 외부 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 외부 정렬</a></p><p><strong>‘외부 정렬(External Sort)’</strong>은 입력 크기가 매우 커서 읽고 쓰는 시간이 오래 걸린느 보조 기억 장치에 입력을 저장할 수 밖에 없는 상태에서 수행되는 정렬을 일컫는다.<br>예를 들어, 컴퓨터의 주기억 장치의 용량이 1GB이고, 정렬할 입력의 크기가 100GB이면, 어떤 내부정렬 알고리즘으로도 정렬할 수 없다.</p><p>외부 정렬은 입력을 분할, 주기억 장치에서 수용할 만큼의 데이터에 대해서만 내부정렬을 수행, 그 결과를 보조 기억 장치에 저장한다.<br>예를 들어, 100GB의 데이터를 1GB만큼씩 주기억 장치로 읽어 들이고, 퀵 정렬과 같은 내부정렬 알고리즘을 이용하여 정렬, 이 후, 다른 보조 기억 장치에 저장한다.<br>이것을 반복하면 원래의 입력 100GB가 100개씩 정렬된 블록으로 분할되어 보조 기억 장치에 저장된다.</p><div align="center"><br><img src="/image/algo32-1.png"><br></div><p>그 다음으로 정렬된 블록들을 하나의 정렬된 거대한 블록(100GB)으로 만들어야 한다.<br>이를 위해 합병(merge)를 반복 수행한다.<br>즉, 블록들을 부분적으로 주기억 장치에 읽어 들여서, 합병을 수행, 부분적으로 보조 기억 장치에 쓰는 과정을 반복한다.</p><p>다음은 1GB 블록 2개가 2GB 블록 1개로 합병되는 과정이다.</p><div align="center"><br><img src="/image/algo32-2.png"><br><img src="/image/algo32-3.png"><br></div><p>2개의 블록을 부분적으로 주기억 장치로 읽어들인다.</p><p>나머지 98개의 블록에 대해서 위 과정을 49회 추가로 반복하면, 2GB 블록 50개가 만들어진다.<br>그 다음에는 2GB 블록 2개씩 짝을 지워 합병시키는 과정을 25회 반복하여, 4GB 블록 25개가 만들어진다.<br>이러한 방식으로 계속 합병을 진행하면, 블록 크기가 2배씩 커지고, 블록의 수는 1/2씩 줄어들어 결국 100GB 블록 1개만 남는다.</p><p>외부정렬 알고리즘은 보조 기억 장치에서의 읽고 쓰기를 최소화하는 것이 중요하다.<br>왜냐하면 보조 기억 장치의 접근시간(access time)이 오래 걸리기 때문이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>ExternalSort<br>입력: 입력 데이터 저장된 입력 HDD<br>출력: 정렬된 데이터가 저장된 출력 HDD<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">입력 HDD에 저장된 입력을 크기가 M만큼씩 주기억 장치에 읽어 들인 후 내부 정렬 알고리즘으로 정렬하여 별도의 HDD에 저장한다. 다음 단계에서는 별도의 HDD는 입렬 HDD로 사용, 입력HDD는 출력 HDd로 사용된다.</span><br><span class="line">while (입력 HDD에 저장된 블록 수 &gt; 1) &#123;</span><br><span class="line">  입력 HDD에 저장된 블록을 2개씩 선택, 각각의 블록으로부터 데이터를 부분적으로 주기억 장치에 읽어 들여서 합병을 수행한다. 이때 합병된 결과는 출력 HDD에 저장한다. 단, 입력 HDD가 저장된 블록 수가 홀수일 때에는 마지막 블록은 그대로 출력 HDD에 저장한다.</span><br><span class="line">&#125;</span><br><span class="line">return 출력 HDD</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>외부정렬은 전체 데이터를 몇 번 처리하는가를 가지고 시간복잡도를 측정한다.<br>전체 데이터를 읽고 쓰는 것을 <strong>패스(pass)</strong>라고 한다.</p><p>위 알고리즘의 경우, while-루프를 마치면 1 패스가 수행된 것이다.<br>그러므로 while-루프가 수행된 횟수가 알고리즘의 시간복잡도가 된다.</p><p>입력 크기가 N, 메모리 크기가 m이면, line 3이 한번 수행될 때마다 블록 크기가 2M,4M, 2<sup>k</sup>M으로 증가한다. 만일 마지막에 만들어진 블록 1개의 크기가 2<sup>k</sup>M이면, 이 블록은 입력 전체가 합병된 결과를 가지고 있다. 즉, 2<sup>k</sup>M = N이다.<br>따라서 k = log<sub>2</sub>(N/M)이고, k는 while-루프가 수행된 횟수이다.<br>그러므로 외부정렬의 시간복잡도는 O(log(N/M))이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo32/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 기수 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo31/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo31/</guid>
      <pubDate>Sun, 03 Feb 2019 05:53:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 기수 정렬&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 기수 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;‘&lt;strong&gt;기수 정렬(Radix Sort)’&lt;/strong&gt;이란 비교정렬이 아니고, 숫자를 부분적으로 비교하는 정렬
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 기수 정렬</a></p><hr><p><a name="1">1. 기수 정렬</a></p><p>‘<strong>기수 정렬(Radix Sort)’</strong>이란 비교정렬이 아니고, 숫자를 부분적으로 비교하는 정렬이다.<br><strong>‘기(Radix)’</strong>는 특정 진수를 나타내는 숫자들이다.<br>예를 들어, 10진수의 기는 0,1,2,…,9이고, 2진수의 기는 0,1이다.</p><p>기수 정렬은 제한적인 범위 내에 있는 숫자에 대해서 각 자릿수별로 정렬하는 알고리즘이다.<br>기수 정렬의 가장 큰 장점은 어느 비교정렬 알고리즘보다 빠르다는 것이다.</p><p>아래의 예제는 5개의 3자리 십진수가 입력으로 들어왔을 때의 기수 정렬이다.</p><div align="center"><br><img src="/image/algo31-1.png"><br></div><p>먼저 각 숫자의 1의 자리만 비교하여 작은 수부터 큰 수로 정렬한다.<br>이 후, 10의 자리만을 각각 비교하여 정렬한다.<br>단, 10의 자리 숫자가 같을 경우 1의 자리 숫자가 작은 것이 위로 향하도록 한다.</p><p>입력에 중복된 숫자가 있을 때, 정렬된 후에도 중복된 숫자의 순서가 입력에서의 순서와 동일하면 정렬 알고리즘이 ‘안정성(Stability)’을 갖는다.<br>안정한 정렬 알고리즘은 중복된 숫자에 대해 앞서 있던 숫자가 정렬된 후에도 앞서 있고,<br>불안정한 정렬 알고리즘은 정렬 후에 그 순서가 반드시 지켜지지는 않는다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>RadixSort<br>입력: n개의 r진수의 k자리 숫자<br>출력: 정렬된 숫자<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to k</span><br><span class="line">  각 숫자의 i자리 숫자에 대해 안정한 행렬을 수행한다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><hr><p><a name="3">3. 시간 복잡도</a></p><p>for-루프가 k번 반복한다.<br>한 번 루프가 수행될 때 n개의 숫자의 i자릿수를 읽으며, r개로 분류하여 개수를 세고, 그 결과에 따라 숫자가 이동하므로 O(n+r)이 된다.<br>따라서 총 시간복잡도는 O(k(n+r)) = O(n)이다.<br>(통상적으로 k나 r은 n보다 매우 작다.)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo31/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정렬 문제의 하한 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/03/algo30/</link>
      <guid>http://dudri63.github.io/2019/02/03/algo30/</guid>
      <pubDate>Sun, 03 Feb 2019 03:22:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;합병 정렬, 퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 힙 정렬의 공통점은 숫자의 비교가 부분적이 아닌 숫자 대 숫자로 이루어진다는 것이다.&lt;br&gt;이러한 정렬을 &lt;strong&gt;비교 정렬(Comparison Sort)&lt;/strong
        
      
      </description>
      
      <content:encoded><![CDATA[<p>합병 정렬, 퀵 정렬, 버블 정렬, 선택 정렬, 삽입 정렬, 쉘 정렬, 힙 정렬의 공통점은 숫자의 비교가 부분적이 아닌 숫자 대 숫자로 이루어진다는 것이다.<br>이러한 정렬을 <strong>비교 정렬(Comparison Sort)</strong>이라고 한다.<br>비교 정렬의 경우에 한해서 문제를 해결하기 위해 필요한 최소 비교 횟수는 어떻게 알 수 있는가?</p><p>어떤 주어진 문제에 대하여 시간복잡도의 <strong>하한(Lower Bound)</strong>이라 함은 어떠한 알고리즘도 문제의 하한보다 빠르게 해를 구할 수 없음을 의미한다.<br>구체적으로 어떤 문제가 가지고 있는 고유한 특성 때문에 어떠한 알고리즘일지라도 해를 구하려면 적어도 하한의 시간복잡도만큼 필요하다는 뜻이다.</p><hr><ol><li>n개의 숫자가 저장된 배열에서 최댓값을 찾는 문제의 하한을 고려한다.<br>즉, 최댓값을 찾기 위해 숫자들을 적어도 몇 번 비교해야 하는지 파악하는 것이다.</li></ol><p>이 문제는 어떤 알고리즘을 이용하여 탐색하던지 간에 적어도 (n-1)번의 비교가 필요하다.<br>왜냐하면 어떤 방식이라도 각 숫자를 적어도 한 번 비교해야 하기 때문이다.</p><ol start="2"><li>n개의 숫자를 비교정렬하는 데 필요한 최소의 비교 횟수, 즉 정렬 문제의 하한을 고려한다.</li></ol><p>예를 들어, 서로 다른 숫자 x,y,z에 대하여 정렬에 필요한 모든 경우의 숫자 대 숫자 비교는 다음 그림과 같다.</p><div align="center"><br><img src="/image/algo30-1.png"><br></div><p>비교 결과가 ‘참’이면 왼쪽으로, ‘거짓’이면 오른쪽으로 분기된다.<br>각 leaf 노드에는 루트로부터의 비교 결과에 따른 정렬된 결과가 저장된다.<br>이러한 트리를 <strong>‘결정 트리(Decision Tree)’</strong>라고 한다.<br>결정 트리의 특징은 다음과 같다.</p><ul><li>leaf 노드의 수는 3!=6이다.</li><li>결정 트리는 이진트리(Binary Tree)이다.</li><li>결정트리에는 정렬을 함에 있어 불필요한 내부 노드가 없다.</li></ul><p>leaf 노드의 수가 3!인 이유는 서로 다른 숫자 3개가 정렬되는 모든 경우의 수가 3!이기 때문이다.<br>결정트리는 각 내부 노드의 비교가 ‘참’일 때와 ‘거짓’일 때 각각 1개의 자식 노드를 가지기 때문에 이진트리이다.<br>또한, 중복 비교를 하는 노드들이 있으나 모두 필요한 내부 노드이다.</p><p>따라서 서로 다른 3개의 숫자들을 비교정렬하기 위해서는 적어도 3번 비교해야 한다.<br>즉, n개의 서로 다른 숫자들을 정렬하기 위해서는 적어도 n번 비교해야 한다.<br>n개의 서로 다른 숫자들을 비교졍렬하는 결정 트리의 높이가 비교 정렬의 하한이 된다.<br>비교 정렬의 하한은 O(nlogn)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/03/algo30/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 힙 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo29/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo29/</guid>
      <pubDate>Fri, 01 Feb 2019 12:48:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 힙 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 힙 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘힙(
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 힙 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 힙 정렬</a></p><p><strong>‘힙(Heap)’</strong>은 <strong>힙 조건</strong>을 만족하는 <strong>완전 이진 트리(Complete Binary Tree)</strong>이다.</p><p>힙 조건이란 각 노드의 값이 자식 노드의 값보다 커야 한다는 것을 말한다.<br>노드의 값은 <strong>‘우선순위(Priority)’</strong>라고 일컫는다.<br>따라서 힙의 루트에는 가장 높은 우선순위(가장 큰 값)가 저장되어 있다.<br>(단, 값이 작을수록 우선순위가 높은 경우도 있다.)</p><p>완전 이진트리란 마지막 레벨을 제외하고 모든 노드가 채워져 있고, 마지막 레벨은 왼쪽부터 채워지는 이진 트리이다.<br>n개의 노드를 가진 힙은 완전 이진 트리이므로, 힙의 노드가 log<sub>2</sub>n이다.</p><p>아래 그림은 힙의 노드들이 배열에 저장된 모습을 보여준다.</p><div align="center"><br><img src="/image/algo29-1.png"><br></div><p>배열 A에 힙을 저장한다면, A[0]은 비워 두고, A[1]부터 A[n]까지에 힙 노드들을 층별로 왼쪽부터 저장한다.이런 방식으로 저장하면, 트리에서 부모 노드와 자식 노드의 관계를 배열의 인덱스로 쉽게 표현할 수 있다.</p><ul><li>A[i]의 부모 노드 : A[i/2], ex. A[7]=10의 부모 노드 -&gt; A[7/2]=A[3]=80</li><li>A[i]의 왼쪽 자식 노드 : A[2i], ex. A[4]=50의 왼쪽 자식 노드 -&gt; A[4*2]=A[8]=20</li><li>A[i]의 오른쪽 자식 노드 : A[2i+1], ex. A[4]=50의 오른쪽 자식 노드 -&gt; A[4*2+1]=A[9]=40</li></ul><p><strong>‘힙 정렬(Heap Sort)’</strong>은 힙 자료 구조를 이용하는 정렬 알고리즘이다.<br>오름차순의 정렬을 위해 입력 배열을 큰 숫자가 높은 우선순위를 가지는 <strong>최대힙(Maximum heap)</strong>을 만든다.<br>루트에 저장된 가장 큰 수를 배열의 가장 끝으로 이동시킨다.<br>그리고 루트에 새로 저장된 숫자로 인해 위배된 힙 조건을 해결하며 힙 조건을 만족시키고, 힙 크기를 1개 줄인다.<br>이 과정을 반복하여 나머지 숫자들을 정렬하는 것이 힙 정렬 알고리즘이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>HeapSort<br>입력: 입력이 A[1]부터 A[n]까지 저장된 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">배열 A의 숫자에 대해서 힙 자료 구조를 만든다.</span><br><span class="line">heapSize = n// 힙의 크기를 조절</span><br><span class="line">for i=1 to n-1</span><br><span class="line">  A[1] &lt;-&gt; n-1// 루트와 힙의 마지막 노드를 교환한다.</span><br><span class="line">  heapSize = heapSize - 1// 힙의 크기를 1 감소시킨다.</span><br><span class="line">  DownHeap()// 위배된 힙 조건을 만족시킨다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><ul><li>line 1 : 배열 A를 힙으로 만든다.</li><li>line 2 : 현재의 힙의 크기를 나타내는 변수인 heapSize를 n으로 초기화시킨다.</li><li>line 3~6 : for루프가 (n-1)번 수행된다. (n-1)번 수행하는 루프가 종료된 후 루트인 A[1] 홀로 힙을 구성, A[1]에 있는 숫자가 가장 작은 수이므로 루프를 수행할 필요가 없기 때문이다.</li><li>line 4 : 루트와 힙의 마지막 노드와 교환, 루트에는 힙에서 가장 큰 수가 저장되어 있었음.</li><li>line 5 : 힙의 크기를 1 줄인다.</li><li>line 4에서 힙의 마지막 노드와 힙의 루트를 바꾸어 놓았기 때문에 새로이 루트에 저장된 값이 자식 노드의 값보다 작아서 힙 조건이 위배된다.</li><li>line 6 : DownHeap을 수행, 위배된 힙 조건을 해결한다.</li></ul><p>위 과정은 아래 그림으로 설명할 수 있다.</p><div align="center"><br><img src="/image/algo29-2.png"><br></div><p>우선 위 그림은 line 4에서 힙의 루트(90)와 마지막 노드(40)를 바꾸고, 힙의 노드 수를 1개 줄이는 과정이다.<br>이 작업이 끝나면 힙 조건이 위배되고, 이를 해결하기 위해 DownHeap을 수행한다.<br>DownHeap 수행 과정은 아래와 같다.</p><div align="center"><br><img src="/image/algo29-3.png"><br></div><p>새로이 루트에 저장된 40이 루트의 자식 노드들(60,80)보다 작아서 힙 조건 위배, 자식 노드들 중에서 가장 큰 자식인 80과 루트 40을 교환한다.</p><div align="center"><br><img src="/image/algo29-4.png"><br></div><p>40은 또다시 자식 노드들중 하나인 70보다 작기 때문에 힙 조건에 위배, 70과 40을 교환한다.</p><div align="center"><br><img src="/image/algo29-5.png"><br></div><p>힙 조건을 만족하므로 DownHeap을 종료한다.</p><div align="center"><br><img src="/image/algo29-6.png"><br></div><p>힙의 루트(80)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-7.png"><br></div><p>힙의 루트(70)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-8.png"><br></div><p>힙의 루트(60)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와 같다.</p><div align="center"><br><img src="/image/algo29-9.png"><br></div><p>힙의 루트(50)와 마지막 노드(20)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-10.png"><br></div><p>힙의 루트(40)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-11.png"><br></div><p>힙의 루트(30)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.</p><div align="center"><br><img src="/image/algo29-12.png"><br></div><p>힙의 루트(20)와 마지막 노드(10)을 교환한 후, 힙의 노드 수를 1개 줄이고, DownHeap을 수행한 결과는 위와<br> 같다.<br>힙의 크기가 1이 되었으므로 힙 정렬을 마친다.<br>결과로서 배열이 정렬되었음 확인할 수 있다.</p><p>for-루프를 반복할 때마다 힙에서 가장 큰 수를 힙의 마지막 노드와 교환한다.<br>선택 정렬에서 최솟값을 찾는 대신에 최댓값을 찾아서 배열의 뒷부분으로부터 정렬하는 것과 같다.<br>또한 선택정렬은 순차탐색으로 최솟값을 찾는 것에 비해 힙 정렬은 힙 자료구조를 이용하여 최댓값을 찾는다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1에서 힙을 만드는데 O(n) 시간이 걸린다.<br>line 2는 변수를 초기화, O(1) 시간이 걸린다.<br>line 3~6은 for-루프가 (n-1)번 수행, 루프 내부에서 line 4~5에서 O(1)시간이 걸리고, DownHeap은 O(log<sub>2</sub>n) 시간이 거린다.<br>(힙의 높이는 log<sub>2</sub>n을 넘지 않음, 최악의 경우 leaf 노드까지 내려가며 교환한 경우를 가정한다.)<br>힙 정렬의 시간복잡도는 O(n) + (n-1)*O(logn) = O(nlogn)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo29/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 쉘 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo28/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo28/</guid>
      <pubDate>Fri, 01 Feb 2019 10:23:40 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 쉘 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. 응용&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 쉘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 쉘 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a><br><a href="#4">4. 응용</a></p><hr><p><a name="1">1. 쉘 정렬</a></p><p>버블 정렬이나 삽입 정렬이 수행되는 과정을 살펴보면, 이웃하는 원소의 숫자들끼리의 자리를 이동함으로써 정렬이 이루어진다.<br>그렇기 때문에 위 두 정렬의 경우, 배열되는 과정이 굉장히 느리다.<br>특히 삽입 정렬은 배열의 마지막 원소가 입력에서 가장 작은 숫자라면, 그 숫자가 배열의 맨 앞으로 이동할 때, 다른 모든 숫자들이 1칸씩 오른쪽으로 이동하여야 한다.</p><p><strong>‘쉘 정렬(Shell Sort)’</strong>은 이러한 단점을 보완하기 위해서 삽입 정렬을 이용하여 배열 뒷부분의 작은 숫자을 앞부분으로 ‘빠르게’ 이동시키고, 동시에 앞부분의 큰 숫자는 뒷부분으로 이동시키며, 가장 마지막에는 삽입 정렬을 수행한다.</p><p>다음 예제를 통해 쉘 정렬의 아이디어를 이해한다.</p><div align="center"><br><img src="/image/algo28-1.png"><br><br></div><ul><li>먼저 간격(gap)이 5가 되는 숫자끼리 그룹을 만든다. 만들어지는 그룹은 다음과 같다.<br>[30,80,50], [60,40,30], [90,20,40], [10,10,90], [40,60,80]</li></ul><p><img src="/image/algo28-2.png"></p><ul><li>각 그룹내에서 정렬된 결과를 1줄에 나열하면 다음과 같다.</li></ul><p><img src="/image/algo28-3.png"></p><p><img src="/image/algo28-4.png">  </p><ul><li><p>완벽하지는 않지만 대체로 큰 수가 뒤로, 작은 수가 앞으로 이동하였음을 확인할 수 있다.</p></li><li><p>이 후, 간격을 5보다 작게 하여 또 다시 그룹별로 삽입 정렬을 수행한다.</p></li><li><p>마지막에는 간격(gap)을 1로 하여 수행한다. 이는 삽입 정렬 그 자체이다.</p></li></ul><hr><p><a name="2">2. 알고리즘</a></p><p>ShellSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">for each gap h = [h0 &gt; h1 &gt; ... &gt; hk = 1]// 큰 gap부터 차례로</span><br><span class="line">  for i = h to n-1</span><br><span class="line">    CurrentElement = A[i];</span><br><span class="line">    j = i;</span><br><span class="line">    while (j&gt;=h) and (A[j-h] &gt; CurrentElement) &#123;</span><br><span class="line">      A[j] = A[j-h];</span><br><span class="line">      j = j - h;</span><br><span class="line">    &#125;</span><br><span class="line">  A[j] = CurrentElement;</span><br><span class="line">&#125;</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>앞의 예제에 위 알고리즘을 적용하여 쉘 정렬의 과정을 살핀다.</p><ol><li>h = 5 (간격이 5일 때)</li></ol><ul><li>i = 5,6,7,8,9일 때</li></ul><p><img src="/image/algo28-5.png"> </p><ul><li>i = 10,11,12,13,14일 때</li></ul><p><img src="/image/algo28-6.png"> </p><p><img src="/image/algo28-7.png"> </p><ol start="2"><li>h = 3 (간격이 3일 때)</li></ol><ul><li>3개의 그룹으로 나뉘어지고, 각 그룹의 원소는 5개씩이다.</li></ul><p><img src="/image/algo28-8.png"> </p><p><img src="/image/algo28-9.png"> </p><ol start="3"><li>h = 1 (간격이 1일 때, 삽입 정렬과 동일)</li></ol><p><img src="/image/algo28-10.png"> </p><p>쉘 정렬의 수행 속도는 간격 선정에 따라서 좌우된다.<br>지금까지 알려진 가장 좋은 성능을 보이는 간격은 1, 4, 10, 23, 57, 132, 301, 701이다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>쉘 정렬의 최악 경우의 시간 복잡도는 O(n<sup>2</sup>)이다.<br>히바드(Hibbard) 간격 2<sup>k</sup>-1을 사용하면 쉘 정렬의 시간복잡도는 O(n<sup>1.5</sup>)이다.<br>또한 다양한 실험을 통해 쉘 정렬의 시간복잡도는 O(n<sup>1.25</sup>)까지 줄일 수 있다고 알려져 있다.</p><hr><p><a name="4">4. 응용</a></p><p>쉘 정렬은 입력 크기가 매우 크지 않은 경우에 매우 좋은 성능을 보인다.<br>쉘 정렬은 임베디드(Embedded) 시스템에서 주로 사용되는데, 쉘 정렬의 특징인 간격에 따른 그룹별 정렬 방식이 하드웨어로 정렬 알고리즘을 구현하는 데 매우 적합하기 때문이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo28/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 삽입 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo27/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo27/</guid>
      <pubDate>Fri, 01 Feb 2019 09:22:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 삽입 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 삽입 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 삽입 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 삽입 정렬</a></p><p><strong>‘삽입 정렬(Insertion Sort)’</strong>은 배열을 정렬된 부분(앞부분)과 정렬이 안 된 부분(뒷부분)으로 나누고, 정렬이 안 된 부분의 가장 왼쪽 원소를 정렬된 부분의 적절한 위치에 삽입하여 정렬되도록 하는 과정을 반복한다.</p><p>정렬이 안 된 부분의 숫자 하나가 정렬된 부분에 ‘삽입’됨으로써, 정렬된 부분의 원소 수가 1개 늘어나고, 정렬이 안 된 부분의 원 소 수는 1개 줄어든다.<br>이를 반복하여 수행, 마지막에는 정렬이 안 된 부분에 원소가 아무것도 남지 않게 된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>InsertionSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for i = 1 to n-1 &#123;// A[0]는 정렬이 된 상태로 본다</span><br><span class="line">  CurrentElement = A[i] // 정렬이 안된 부분의 가장 왼쪽 원소</span><br><span class="line">  j &lt;- i-1// 정렬이 된 부분의 가장 오른쪽 원소를 지칭</span><br><span class="line">  while (j &gt;=0) and (A[j] &gt; CurrentElement) &#123; // CurrentElement가 더 작으면</span><br><span class="line">    A[j+1] = A[j] // 정렬이 된 부분의 가장 오른쪽 원소를 오른쪽으로 한칸 이동</span><br><span class="line">    j &lt;- j-1</span><br><span class="line">  &#125;</span><br><span class="line">  A[j+1] &lt;- CurrentElement// 비어있는 부분으로 CurrentElement 이동</span><br><span class="line">&#125;</span><br><span class="line">return A</span><br></pre></td></tr></table></figure></p><p>다음의 배열에 대해 삽입 정렬이 수행되는 과정을 확인한다.</p><div align="center"><br><img src="/image/algo27-1.png"><br><br></div><ul><li><p>i=1, CurrentElement = A[1] = 10, j = i-1 = 0<br><img src="/image/algo27-2.png"><br><img src="/image/algo27-3.png"><br>A[j]= A[0] = 40 &gt; CurrentElement = 10, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-4.png"><br>j=-1, while-문 만족하지 않음<br>A[j+1] = A[0]에 CurrentElement 저장</p></li><li><p>i=2, CurrentElement = A[2] = 50, j = i-1 = 1<br><img src="/image/algo27-5.png"><br>A[j] = A[1] = 40 &lt; CurrentElement = 50, while-문 만족하지 않음, 자리 이동 없음</p></li><li><p>i=3, CurrentElement = A[3] = 90, j = i-1 = 2<br><img src="/image/algo27-6.png"><br>A[j] = A[2] = 50 &lt; CurrentElement = 90, while-문 만족하지 않음, 자리 이동 없음</p></li><li><p>i=4, CurrentElement = A[4] = 20, j = i-1 = 3<br><img src="/image/algo27-7.png"><br><img src="/image/algo27-8.png"><br>A[j] = A[3] = 90 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-9.png"><br>A[j] = A[2] = 50 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-10.png"><br>A[j] = A[1] = 40 &gt; CurrentElement = 20, 한 칸 이동, j &lt;- j-1<br><img src="/image/algo27-11.png"><br>A[j] = A[0] = 10 &lt; CurrentElement = 20, while-문 만족하지 않음<br>A[j+1] = A[1]에 CurrentElement 저장</p></li><li><p>i=5, CurrentElement = A[5] = 80,<br><img src="/image/algo27-12.png"></p></li><li><p>i=6, CurrentElement = A[6] = 30,<br><img src="/image/algo27-13.png"></p></li><li><p>i=7, CurrentElement = A[7] = 60,<br><img src="/image/algo27-14.png"></p></li></ul><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1 : for-루프가 (n-1)번 수행<br>line 4 : while-루프가 i=1일 때, 최대 1회 수행, i=2일 때, 최대 2회 수행, … i=n-1일 때, 최대 n-1회 수행<br>while-루프 내부의 수행시간은 O(1)</p><p>따라서, n(n-1)/2 * O(1) = O(n<sup>2</sup>)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo27/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 선택 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo26/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo26/</guid>
      <pubDate>Fri, 01 Feb 2019 08:53:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 선택 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 선택 정렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘선
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 선택 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간복잡도</a></p><hr><p><a name="1">1. 선택 정렬</a></p><p><strong>‘선택 정렬(Selection Sort)’</strong>은 입력 배열 전체에서 최솟값을 ‘선택’하여 배열의 0번 원소와 자리를 바꾸고, 다음에는 0번 원소를 제외한 나머지 원소에서 최솟값을 선택하여 배열의 1번 원소와 자리를 바꾼다. 이러한 방식으로 마지막에 2개의 원소 중에서 작은 값을 선택, 자리를 바꿈으로서 정렬을 마친다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>SelectionSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for i = 0 to n-2 // 크기가 n인 배열은 n-1번 까지 있음. 마지막 칸은 제외하니 n-2까지 정렬시킨다.</span><br><span class="line">  min = i </span><br><span class="line">  for j = i+1 to n-1 &#123;  // A[i]보다 작은 값이 A[i+1]~A[n-1]까지 있으면, 그 중 가장 작은 값을 선택</span><br><span class="line">    if (A[j] &lt; A[min])</span><br><span class="line">      min = j</span><br><span class="line">  &#125;</span><br><span class="line">  A[i] &lt;-&gt; A[min]// A[i]와 가장 작은 값을 위치 변경</span><br><span class="line">&#125;</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>다음 배열이 선택 정렬 알고리즘에 의해 정렬되는 과정을 본다.</p><div align="center"><br><img src="/image/algo26-1.png"><br></div><ul><li>i=0, A[0]~A[7] 중 min=1</li></ul><p><img src="/image/algo26-2.png">  </p><ul><li>i=1, A[1]~A[7] 중 min=4</li></ul><p><img src="/image/algo26-3.png">  </p><ul><li>i=2, A[2]~A[7] 중 min=6</li></ul><p><img src="/image/algo26-4.png">  </p><p>…</p><ul><li>i=6, A[6]~A[7] 중 min=7</li></ul><p><img src="/image/algo26-5.png">  </p><hr><p><a name="3">3. 시간 복잡도</a></p><p>line 1의 for-루프는 (n-1)번 수행된다.<br>line 3의 for-루프는 i=1,2,3,…일 때, 각각 (n-2), (n-2), (n-4), …번 수행된다.<br>루프 내부의 if-조건이 ‘참’일 때 자리바꿈 O(1) 시간이 걸린다.<br>따라서 시간복잡도는 n*(n-1)/2 * O(1) = O(n<sup>2</sup>)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo26/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 버블 정렬 (정렬)</title>
      <link>http://dudri63.github.io/2019/02/01/algo25/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo25/</guid>
      <pubDate>Thu, 31 Jan 2019 16:37:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 버블 정렬&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 버블 벙렬&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;‘
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 버블 정렬</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 버블 벙렬</a></p><p><strong>‘버블 정렬(Bubble Sort)’</strong>은 이웃하는 숫자를 비교하여 작은 수를 앞쪽으로 이동시키는 과정을 반복하여 정렬하는 알고리즘이다.<br>배열을 좌우가 아니라 상하로 그리면 정렬하는 과정에서 작은 수가 ‘거품’처럼 위로 올라가는 것이 연상된다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>BubbleSort<br>입력: 크기가 n인 배열 A<br>출력: 정렬된 배열 A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for pass = 1 to n - 1</span><br><span class="line">  for i = 1 to n - pass</span><br><span class="line">    if (A[i-1] &gt; A[i])// 위의 원소가 아래의 원소보다 크면</span><br><span class="line">      A[i-1] &lt;-&gt; A[i] // 서로 자리를 바꾼다.</span><br><span class="line">return 배열 A</span><br></pre></td></tr></table></figure></p><p>다음의 배열에 대해 버블 정렬이 수행되는 과정을 확인한다.</p><div align="center"><br><img src="/image/algo25-1.png"><br></div><ul><li>패스 1</li></ul><p><img src="/image/algo25-2.png">  </p><ul><li>패스 2</li></ul><p><img src="/image/algo25-3.png">  </p><ul><li>패스 3</li></ul><p><img src="/image/algo25-4.png">  </p><ul><li>패스 4</li></ul><p><img src="/image/algo25-5.png">  </p><ul><li>패스 5~7의 결과는 패스 4의 결과와 동일하다.</li></ul><p><strong>배열의 가장 아래부터 정렬되는 것을 확인할 수 있다.</strong></p><hr><p><a name="3">3. 시간복잡도</a></p><p>pass = 1이면 (n-1)번 비교, pass = 2이면 (n-2)번 비교, pass = (n-1)이면 1번 비교한다.<br>따라서 총 비교 횟수는 n(n-1)/2이다.<br>그리고 if-조건이 참일 경우 자리바꾸는 시간 O(1)이 걸린다.<br>최악의 경우를 가정하고 시간복잡도를 구하면, O(n<sup>2</sup>)이 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“6장정렬알고리즘”, 영산대학교 교수블로그, 2019. 2. 1, <a href="https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=6%C0%E5%C1%A4%B7%C4%BE%CB%B0%ED%B8%AE%C1%F2(1).pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo25/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 정렬 알고리즘</title>
      <link>http://dudri63.github.io/2019/02/01/algo24/</link>
      <guid>http://dudri63.github.io/2019/02/01/algo24/</guid>
      <pubDate>Thu, 31 Jan 2019 15:39:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;정렬 알고리즘&lt;/strong&gt; 분류는 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;기본 정렬 알고리즘&lt;/strong&gt; : 버블 정렬, 선택 정렬, 삽입 정렬&lt;/li&gt;
&lt;li&gt;보다 &lt;strong&gt;효율적인 정렬 알고리즘&lt;/str
        
      
      </description>
      
      <content:encoded><![CDATA[<p><strong>정렬 알고리즘</strong> 분류는 다음과 같다.</p><ul><li><strong>기본 정렬 알고리즘</strong> : 버블 정렬, 선택 정렬, 삽입 정렬</li><li>보다 <strong>효율적인 정렬 알고리즘</strong> : 쉘 정렬, 힙 정렬, 합병 정렬, 퀵 정렬, 기수 정렬</li></ul><p>특히 기수 정렬은 제한된 크기 이내의 숫자로 구성되어 있을 때 매우 효율적이다.</p><p>정렬 알고리즘은 또한 <strong>내부정렬(Internal Sort)</strong>과 <strong>외부 정렬(External Sort)</strong>로도 분류할 수 있다.</p><ul><li>내부 정렬 : 입력의 크기가 메인 메모리의 공간보다 크지 않은 경우 수행, 앞서 언급한 정렬 알고리즘들은 모두 내부 정렬 알고리즘들이다.</li><li>외부 정렬 : 입력의 크기가 메인 메모리의 공간보다 큰 경우 수행, 보조 기억 장치에 있는 입력을 여러 번에 나누어 주기억 장치에 읽어들인 후, 정렬하여 보조 기억 장치에 다시 저장하는 과정을 반복한다.</li></ul><p>앞으로 포스팅하는 모든 정렬 알고리즘은 오름차순으로 정렬하겠다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/02/01/algo24/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝/머신러닝] TensorFlow</title>
      <link>http://dudri63.github.io/2019/01/30/adl2/</link>
      <guid>http://dudri63.github.io/2019/01/30/adl2/</guid>
      <pubDate>Wed, 30 Jan 2019 13:14:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. TensorFlow&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. TensorFlow 예제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. TensorFlow 구조&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#4&quot;&gt;4. placeholder&lt;/
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. TensorFlow</a><br><a href="#2">2. TensorFlow 예제</a><br><a href="#3">3. TensorFlow 구조</a><br><a href="#4">4. placeholder</a><br><a href="#5">5. Tesnor, Ranks, Shapes, Types</a></p><hr><p><a name="1">1. TensorFlow</a></p><p><strong>텐서플로우(TensorFlow)</strong>는 구글에서 만든 오픈 소스 라이브러리이다.<br>텐서플로우는 데이터 플로우 그래프(Data Flow Graph)를 이용하여 수 계산(Numerical Computation)을 할 수 있다는 특징이 있다.<br>또한, ‘파이썬(Python)’ 언어를 이용하여 텐서플로우를 활용할 수 있다.</p><p>Data Flow Graph란 다음 그림과 같은 것이다.</p><div align="center"><br><img src="/image/ald2-1.png"><br></div><br>‘노드’와 노드간을 연결하는 ‘엣지’로 구성되어 있는 것을 그래프라고 한다.<br>Data Flow Graph에서 노드는 하나의 operation이다.<br>엣지는 데이터(tensor)이다.<br>데이터들은 연속적으로 연산하여 결과를 추출하는 것이 Data Flow Graph의 방식이다.<br><br><div align="center"><br><img src="/image/ald2-2.png"><br></div><p>리눅스 환경에서 텐서플로우를 설치한 후, 파이썬에서 텐서플로우 모듈을 import 및 버전 정보를 확인한 결과는 위와 같다.</p><hr><p><a name="2">2. TensorFlow 예제</a></p><div align="center"><br><img src="/image/ald2-3.png"><br></div><p>“Hello, TensorFlow!”라는 내용의 constant 노드를 만들고, 변수 hello에 이를 할당한다.<br>(computation 그래프 내에 노드 1개가 만들어진 형태이다.)<br>이 후, session을 만든 뒤 실행(run)시켰다.<br>(computation 그래프를 실행하기 위해서는 session을 만들어야 한다.)</p><p>(b’라는 문자열은 간단하게 byte string이라는 의미이다. 프로그램 동작과는 무관하다)</p><hr><div align="center"><br><img src="/image/ald2-5.png"><br><br><img src="/image/ald2-4.png"><br></div><p>a와 b라는 노드가 있고, ‘+’라는 노드로 연결되는 간단한 그래프를 만든 것이다.</p><p>node1은 ‘3’이라는 내용, data type은 float32인 constant 노드이다.<br>node2는 ‘4’라는 내용의 constant 노드이다. node2는 암묵적으로 node1과 마찬가지로 data type이 float32임을 유의한다.<br>node3은 node1, node2를 더하는 add 노드이다.</p><p>이 후, node1, node2, node3를 print() 함수를 이용하여 출력하면, 각각의 노드들은 Tensor이며, 그 내용들을 확인할 수 있다. 결과값을 확인할 수는 없다.</p><p>결과값을 확인하기 위해서 1. session을 만들고, 2. 해당 session에 원하는 노드들을 넣은 뒤 3. run한다.</p><hr><p><a name="3">3. TensorFlow 구조</a></p><div align="center"><br><img src="/image/ald2-6.png"><br></div><p>텐서플로우의 구조는 위와 같은데 기존의 프로그래밍과는 조금 다르다.</p><ol><li>먼저 그래프를 빌드한다.</li><li>session을 만든 뒤 run한다.</li><li>결과로 graph내의 값을 업데이트한다.</li></ol><hr><p><a name="4">4. plcaeholder</a></p><p>위에서는 그래프를 만들면서, 각 노드들의 숫자들을 지정하였다.<br>그렇다면, 그래프를 미리 만들어 놓고, 실행시키는 단계에서 값을 던지고 싶다면 어떻게 해야할까?</p><p>constant 노드가 아니라, <strong>placeholder</strong>라는 특별한 노드를 사용한다.</p><div align="center"><br><img src="/image/ald2-7.png"><br><img src="/image/ald2-8.png"><br></div><p>a, b, adder_node, 총 3개의 placeholder 노드를 만들었다.<br>이 후, session을 생성한 뒤, feed_dict로 a, b 노드에 값을 할당한 뒤 실행시킨다.<br>1개의 값이 아닌 여러개의 값을 넘겨줄 수도 있다.</p><hr><p><a name="5">5. Tensor, Ranks, Shapes, Types</a></p><p>5.1. Tensor</p><p>TensorFlow 프로그램은 모든 데이터를 <strong>tensor</strong> 데이터 구조를 사용해서 표현한다.<br>TensorFlow의 tensor는 n-차원 배열 또는 리스트라고 생각할 수 있다.<br>하나의 tesnor는 정적 타입, 동적 차원을 가지고 있다.<br>그리고 Computation 그래프의 노드들은 오직 tensor만을 전달할 수 있다.</p><p>5.2. Rank</p><p>TensorFlow 시스템에서 tensor는 <strong>rank</strong>라는 차원 단위로 표현된다.</p><div align="center"><br><img src="/image/ald2-9.png"><br></div><br>위 표는 rank에 따른 tensor의 형식이다.<br><br>5.3. Shape<br><br>TensorFlow 문서는 tensor 차원을 표현할 때, 세 가지 기호를 사용한다.<br>rank, shape, 차원수가 그것들이다.<br>다시 말하면, tensor의 차원을 알기 위해서 rank, shape, 차원수를 살펴볼 수 있다.<br><div align="center"><br><img src="/image/ald2-10.png"><br></div><p>5.4. Data Types</p><p>Tensor는 차원 말고도 <strong>데이터 타입</strong>을 갖는다. 아래의 데이터 타입을 tensor에 지정할 수 있다.</p><div align="center"><br><img src="/image/ald2-11.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>랭크, 크기, 타입-텐서플로우 문서 한글 번역본, 텐서플로우, 2019. 1. 30, <a href="https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\_types.html" rel="external nofollow noopener noreferrer" target="_blank">https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/resources/dims\_types.html</a></li><li>섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/tensorflow%ec%9d%98-%ec%84%a4%ec%b9%98%eb%b0%8f-%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-operations/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/30/adl2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[딥러닝/머신러닝] 머신러닝이란</title>
      <link>http://dudri63.github.io/2019/01/30/adl1/</link>
      <guid>http://dudri63.github.io/2019/01/30/adl1/</guid>
      <pubDate>Wed, 30 Jan 2019 10:32:44 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 이세돌과 알파고&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 머신러닝이란&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 이세돌과 알파고&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 이세돌과 알파고</a><br><a href="#2">2. 머신러닝이란</a></p><hr><p><a name="1">1. 이세돌과 알파고</a></p><p>그동안 바둑이라는 게임은 경우의 수가 너무 많고, 사람의 순간적인 직관이 매우 중요한 것으로 여겨졌다.<br>따라서 바둑이라는 종목에 한해서는 컴퓨터가 인간을 넘어서기 힘들 것으로 꽤 오랜 시간 간주되었다.<br>그러나 이세돌 9단이 알파고에게 4:1로 패배하였다.</p><div align="center"><br><img src="/image/ald1-1.png"><br></div><p>인공지능이란 무엇인가에 대하여 많은 이목이 쏠린 역사적인 사건이다.<br>인공지능은 과연 사람처럼 직관적인 의사결정을 할 수 있는 것인가?</p><div align="center"><br><img src="/image/ald1-2.png"><br></div><p>Dr.Andrew Ng에 의하면 오늘날의 시대를 살기 위해서는 머신러닝 학습이 필수적이라고 이야기한다.<br>또한, 머신러닝을 잘 활용하는 사람이 Super Power를 지닐 수 있다고 한다.</p><hr><p><a name="2">2. 머신러닝이란</a></p><p><strong>머신러닝(Machine Learning)</strong>이란 일종의 소프트웨어, 프로그램이다.<br>그러나 기존 프로그래밍 기법과는 차이점이 있다.</p><p>기존 explicit programming이란 개발자가 환경에 따라서 프로그램이 어떻게 반응할지를 정의한다.<br>그런데 explicit하게, 즉, 명확하게 프로그래밍하기 어려운 경우가 있다.<br>예를 들어, 스팸 메일을 필터링하는 프로그램을 작성할 때 모든 경우를 고려하여 스팸 or not을 결정하기가 어렵다.</p><p>머신러닝의 시작은 상황이 복잡할 때 모든 경우를 일일이 프로그래밍하지 않고, ‘어떤 현상이나 자료에서 자동적으로 배우는 것은 어떨까?’라는 생각이다.<br>즉, 머신러닝은 프로그램인데, 개발자가 모든 경우를 명확하게 프로그래밍 하지 않고, 프로그램이 스스로 학습하여 배운 뒤 처리할 수 있도록 하는 것이라고 할 수 있다.</p><div align="center"><br><img src="/image/ald1-3.png"><br></div><p>머신러닝은 학습하는 방법에 따라서 Supervised Learning, Unsupervised Learning으로 구분할 수 있다.<br>Supervised Learning은 정해져있는 데이터(labeled, training set)를 이용하여 학습하는 것이다.<br>예를 들어, 개나 고양이 사진들의 label을 각각 개, 고양이로 달고 학습을 시킬 수 있다.</p><div align="center"><br><img src="/image/ald1-4.png"><br></div><p>그런데, 모든 경우 label을 달 수 있는 것은 아니다.<br>Google news는 자동적으로 유사한 뉴스들을 grouping을 한다.<br>또한, 유사한 단어들을 grouping하는 것도 특정한 label을 달기 어렵다.<br>이 경우 Unsupervised Learning(학습)하여야 한다.</p><p>머신러닝에서 대부분의 문제들은 Supervised Learning으로 해결할 수 있다.<br>Supervised Learning의 예는 다음과 같다.</p><p><div align="center"><br><img src="/image/ald1-5.png"><br>X: feature, Y: label<br></div></p><ul><li>label이 정해져 있는 feature들을 가지고 학습을 한다.<br>(네모칸 안에 있는 표를 training data set이라고 한다.)</li><li>이 후, 내가 모르는 X<sub>test</sub>의 label을 물어보면, ML은 Y=3이라고 대답한다.</li></ul><p>알파고의 원리도 위와 다르지 않다.<br>기존 바둑 기사들이 둔 기보를 이용하여 학습한 뒤, 이세돌 9단과 대결할 때, 학습한 것을 바탕으로 각 수를 놓는 것이다.</p><p>Supervised Learning의 Type은 다음과 같다.</p><ol><li>공부한 시간에 따른 시험 성적(0~100) 예상 : regression</li><li>공부한 시간에 따른 시험 결과(pass or fail) 예상 : binary classification</li><li>공부한 시간에 따른 시험 성적(A,B,C,D,F) 예상 : multi-label classification</li></ol><p>ML을 이용한 공부한 시간에 따른 시험 성적(0~100) 예상이 어떻게 되는지는 다음과 같다.</p><p><div align="center"><br><img src="/image/ald1-6.png"><br>왼쪽 표는 training data set이다.<br></div><br>regression 모델을 왼쪽 표를 이용하여 training한다. 이 후, x=7(7시간)일 때, y(점수)를 물어보면, 학습한 것을 바탕으로 y=70을 내놓는다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>섹션 0.오리엔테이션, 섹션 1.머신러닝의 개념과 용어/기본적인 Machine Learning의 용어와 개념 설명, 모두를 위한 딥러닝-기본적인 머신러닝와 딥러닝 강좌, 2019. 1. 30, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ec%88%98%ec%97%85-%ec%86%8c%ea%b0%9c%ec%99%80-%ea%b0%9c%ec%9a%94/</a>, <a href="https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/" rel="external nofollow noopener noreferrer" target="_blank">https://www.inflearn.com/course/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d-%eb%94%a5%eb%9f%ac%eb%8b%9d-%ea%b0%95%ec%a2%8c/%ea%b8%b0%eb%b3%b8%ec%a0%81%ec%9d%b8-machine-learnnig-%ec%9d%98-%ec%9a%a9%ec%96%b4%ec%99%80-%ea%b0%9c%eb%85%90-%ec%84%a4%eb%aa%85/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/30/adl1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 클래스</title>
      <link>http://dudri63.github.io/2019/01/29/python8/</link>
      <guid>http://dudri63.github.io/2019/01/29/python8/</guid>
      <pubDate>Tue, 29 Jan 2019 12:31:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 클래스&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 클래스&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 클래스</a></p><hr><p><a name="1">1. 클래스</a></p><p>C 언어는 가장 많이 사용하는 프로그래밍 언어 중 하나이지만 클래스가 없다. 즉, 클래스가 없어도 프로그램을 충분히 만들 수 있다.<br>그러나 프로그램 작성 시 클래스를 사용하면 프로그래머가 얻을 수 있는 이점이 굉장히 많다.</p><p>클래스는 ‘과자틀’, 객체는 과자틀에 의해 만들어진 ‘과자’에 비유할 수 있다.<br>클래스란 똑같은 무엇인가를 계속해서 만들어낼 수 있는 설계 도면 같은 것이고, 객체란 클래스에 의해서 만들어진 피조물을 뜻한다.</p><p>클래스에 의해서 만들어진 객체는 중요한 특징이 있다. 그것은 객체별로 독립적인 성격을 갖는다는 것이다. 동일한 클래스에 의해 생성된 객체들은 서로에게 전혀 영향을 주지 않는다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Cal:# Cal이라는 새로운 class를 정의</span><br><span class="line">    def __init__(self, v1, v2): # 생성자</span><br><span class="line">        self.v1 = v1</span><br><span class="line">        self.v2 = v2</span><br><span class="line"> </span><br><span class="line">    def add(self):# add 함수</span><br><span class="line">        return self.v1+self.v2</span><br><span class="line"> </span><br><span class="line">    def subtract(self):  # subtract 함수</span><br><span class="line">        return self.v1-self.v2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">c1 = Cal(10,10)# 객체 c1 생성 및 변수에 객체 할당</span><br><span class="line">print(c1.add())# 객체의 멤버에 접근</span><br><span class="line">print(c1.subtract()) # 객체의 멤버에 접근</span><br><span class="line">c2 = Cal(30,20)# 객체 c2 생성 및 변수에 객체 할당</span><br><span class="line">print(c2.add())# 객체의 멤버에 접근</span><br><span class="line">print(c2.subtract())# 객체의 멤버에 접근</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-1.png"><br></div><ul><li>__init__ : 생성자<br>객체를 생성할 때, 생성자의 self를 제외한 매개변수 숫자만큼 인자를 채워야 한다.<br>ex. __init(self,v1, v2)__ -&gt; c1 = Cal(v1,v2)</li><li>self : 객체의 인스턴스 그 자체, 파이썬에서는 클래스의 메소드를 정의할 때 self를 꼭 명시해야 한다.</li></ul><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        self.value = v</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.value)</span><br><span class="line"> </span><br><span class="line">c1 = C(10)</span><br><span class="line">print(c1.value)# 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출 </span><br><span class="line">c1.value = 20# 객체 c1의 멤버 변수 value의 값을 변경</span><br><span class="line">print(c1.value)# 객체 c1의 멤버 변수 value를 인자로 print() 함수 호출</span><br><span class="line">c1.show()# 객체 c1의 멤버 함수 show()를 호출, show() 함수는 value의 값을 인자로 print() 함수 호출</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-2.png"><br></div><hr><p>cf. 객체와 인스턴스</p><p>클래스에 의해서 만들어진 객체를 인스턴스라고도 한다. 그러나 객체와 인스턴스는 미묘하지만 차이점이 있다. 예를 들어 Cookie라는 클래스가 있다고 가정한다. a = Cookie() 로 만들어진 a는 객체이다. 그리고 a라는 객체는 Cookie의 인스턴스이다. 즉, 인스턴스라는 말은 특정 객체(a)가 어떤 클래스(Cookie)의 객체인지를 관계 위주로 설명할 때 사용된다. 즉, “a는 인스턴스” 보다는 “a는 객체”라는 표현이 어울리며, “a는 Cookie의 객체” 보다는 “a는 Cookie의 인스턴스”라는 표현이 훨씬 잘 어울린다.</p><hr><p>cf. 변수 </p><p>값을 넣을 수 있는 이름이 붙어있는 공간. 일반적으로 값을 변경할 수 있다. 값을 변경할 수 없을 경우 특별하게 ‘상수’라고 한다.</p><hr><p>cf. 인스턴스 변수와 클래스 변수</p><p>인스턴스 변수와 클래스 변수를 합쳐서 ‘멤버 변수’라고 한다. 인스턴스 변수는 객체를 생성할 때 생성된다. 각각의 인스턴스마다 다른 값을 가질 수 있다. 클래스 변수는 인스턴스 변수에 static이 붙은 형식이다. 인스턴스 변수는 각각 고유한 값을 가질 수 있는 것에 반해 클래스 변수는 모든 인스턴스가 동일한 값을 공유한다. 인스턴스 변수, 클래스 변수 모두 Class 내부에서 선언된다.</p><hr><p>cf. 캡슐화</p><p>캡슐화(Encapsulation)는 객체 지향 프로그래미에서 다음 2가지 측면이 있다.</p><ul><li>객체의 속성과 행위를 하나로 묶고,</li><li>실제 구현 내용을 외부에 감추어 은닉한다.</li></ul><p>외부로부터 영향을 받지 변경되지 않도록 기본적으로 캡슐화를 이용한다. 함수나 변수도 캡슐로 감싼 예 중 하나이다. 또한 함수들을 다시 묶어서 모듈로 감쌀 수도 있다. 접근 지정자를 따로 지정하여 외부에서 캡슐에 얼마나 접근할 수 있을지 설정하기도 한다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class C(object):</span><br><span class="line">    def __init__(self, v):</span><br><span class="line">        self.value = v</span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.value)</span><br><span class="line">    def getValue(self):# 인스턴스의 value를 반환</span><br><span class="line">        return self.value</span><br><span class="line">    def setValue(self, v):# 인스턴스의 value를 설정 </span><br><span class="line">        self.value = v</span><br><span class="line">c1 = C(10)# C의 인스턴스 c1 생성 </span><br><span class="line">print(c1.getValue())# c1의 value값을 받아온 뒤, print() 호출</span><br><span class="line">c1.setValue(20)# c1의 value값을 설정</span><br><span class="line">print(c1.getValue())# c1의 value값을 받아온 뒤, print() 호출</span><br></pre></td></tr></table></figure><p>set은 객체 내부의 데이터를 직접 바꾸기 위한 메소드,<br>get은 객체 내부의 데이터를 직접 받아오기 위한 메소드이다.</p><div align="center"><br><img src="/image/py8-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    bag = []# bag 속성(클래스 속성)</span><br><span class="line"> </span><br><span class="line">    def put_bag(self, stuff):</span><br><span class="line">        self.bag.append(stuff)</span><br><span class="line"> </span><br><span class="line">james = Person()</span><br><span class="line">james.put_bag(&apos;책&apos;)</span><br><span class="line"> </span><br><span class="line">maria = Person()</span><br><span class="line">maria.put_bag(&apos;열쇠&apos;)</span><br><span class="line"> </span><br><span class="line">print(james.bag)</span><br><span class="line">print(maria.bag)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-4.png"><br></div><p><strong>클래스 속성</strong>으로서 bag 속성을 만들었다. james 인스턴스에서 ‘책’을 넣었고, maria 인스턴스에서 ‘열쇠’를 넣었는데, james, maria 모두 bag 속성으로서 책과 열쇠를 모두 갖는다.<br>클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bag = []# bag 속성(인스턴스 속성)</span><br><span class="line"> </span><br><span class="line">    def put_bag(self, stuff):</span><br><span class="line">        self.bag.append(stuff)</span><br><span class="line"> </span><br><span class="line">james = Person()</span><br><span class="line">james.put_bag(&apos;책&apos;)</span><br><span class="line"> </span><br><span class="line">maria = Person()</span><br><span class="line">maria.put_bag(&apos;열쇠&apos;)</span><br><span class="line"> </span><br><span class="line">print(james.bag)</span><br><span class="line">print(maria.bag)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py8-5.png"><br></div><p><strong>인스턴스 속성</strong>으로서 bag 속성을 만들었다. 이 경우, 클래스 속성으로 만들었을 때와는 달리 각 인스턴스마다 고유한 속성을 갖게 된다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>05-1 클래스, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/28" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/28</a></li><li>35.1 크래스 속성과 인스턴스 속성 알아보기, 코딩도장, 2019. 1. 29, <a href="https://dojang.io/mod/page/view.php?id=2378" rel="external nofollow noopener noreferrer" target="_blank">https://dojang.io/mod/page/view.php?id=2378</a></li><li>객체와 변수, 생활코딩, 2019. 1. 29, <a href="https://opentutorials.org/course/1750/10000" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/10000</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/python8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 동전 거스름돈 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/29/algo23/</link>
      <guid>http://dudri63.github.io/2019/01/29/algo23/</guid>
      <pubDate>Tue, 29 Jan 2019 09:07:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 동전 거스름돈&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 동전 거스름돈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;거스름돈을
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 동전 거스름돈</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 동전 거스름돈</a></p><p>거스름돈을 동전으로 받을 때, 누구나 적은 수의 동전을 받길 원한다고 가정한다.<br>동전 거스름돈 문제는 그리디 알고리즘으로 해결할 수도 있으나, 160원짜리 동전을 추가로 발행하는 등의 상황이 있을 때는 항상 최적해를 찾을 수는 없다.<br>동적 계획 알고리즘은 모든 동전 거스름돈 문제에 대하여 항상 최적해를 찾는다.</p><p>다른 문제들과 마찬가지로 동적 계획 알고리즘을 고안하기 위해서는 부분문제들을 찾아내야 한다.<br>동전 거스름돈 문제에 주어지는 일반적인 문제 요소들을 고려한다.<br>정해진 동전의 종류, 거스름돈이 그것들이다.</p><p>동전 거스름돈 문제도 배낭 문제와 마찬가지로 동전 거스름돈도 1원씩 증가시켜 문제를 해결한다.<br>그리고 부분문제들의 해를 1차원 배열 C에 저장한다.</p><ul><li>1원을 거슬러 받을 때 사용되는 최소의 동전 수 C[1]</li><li>2원을 거슬러 받을 때 사용되는 최소의 동전 수 C[2]</li><li>3원을 거슬러 받을 때 사용되는 최소의 동전 수 C[3]<br>…</li><li>n원을 거슬러 받을 때 사용되는 최소의 동전 수 C[n]</li></ul><p>그렇다면, C[j]를 구하는 데 어떤 부분문제가 필요한가?</p><ul><li>500원짜리 동전이 거스름돈 j원에 필요하면 C[j-500] = C[j-d<sub>1</sub>]에 500원짜리 동전 1개를 추가한다.</li><li>100원짜리 동전이 거스름돈 j원에 필요하면 C[j-100] = C[j-d<sub>2</sub>]에 100원짜리 동전 1개를 추가&gt;한다. </li><li>50원짜리 동전이 거스름돈 j원에 필요하면 C[j-50] = C[j-d<sub>3</sub>]에 50원짜리 동전 1개를 추가&gt;한다.</li><li>10원짜리 동전이 거스름돈 j원에 필요하면 C[j-10] = C[j-d<sub>4</sub>]에 10원짜리 동전 1개를 추가&gt;한다.</li><li>1원짜리 동전이 거스름돈 j원에 필요하면 C[j-1] = C[j-d<sub>5</sub>]에 1원짜리 동전 1개를 추가&gt;한다.</li></ul><p>위 다섯 가지 중에서 가장 작은 값을 C[j]로 정한다. 그리하여 C[j]의 정의는 다음과 같다.</p><p>C[j] = min<sub>1&lt;=i&lt;=k</sub>{C[j-d<sub>i</sub>] + 1}, if j &gt;= d<sub>i</sub></p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 거스름돈 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 배열 C는 최소의 동전 수를 저장하는 데 사용된다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DPCoinChange</span><br><span class="line">입력: 거스름돈 n원, k개의 동전의 액면, d1&gt;d2&gt;...&gt;dk=1</span><br><span class="line">출력: C[n]</span><br><span class="line">for i = 1 to n C[i] = ∞</span><br><span class="line">C[0] = 0</span><br><span class="line">for j = 1 to n &#123;// j는 1원부터 증가하는 임시 거스름돈 액수, j=n이면 입력에 주어진 거스름돈</span><br><span class="line">  for i = 1 to k &#123;// 액면이 가장 높은 동전부터 1원짜리 동전까지</span><br><span class="line">    if (di &lt;= j) and (C[j-di] + 1 &lt; C[j])// 액면이 가장 높은 동전부터 1원짜리 동전까지</span><br><span class="line">      C[j] = C[j-di] + 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return C[n]</span><br></pre></td></tr></table></figure></p><p>다음은 d<sub>1</sub>=16, d<sub>2</sub>=10, d<sub>3</sub>=5, d<sub>4</sub>=1이고, 거스름돈 n=20일 때, DPCoinChange 알고리즘이 수행되는 과정이다.</p><div align="center"><br><img src="/image/algo23-1.png"><br></div><ul><li><p>Line 4~5 : 배열 C를 초기화한다.<br><img src="/image/algo23-2.png">  </p></li><li><p>Line 6~9 : j = 1일 때(임시 거스름론), </p><ul><li><p>i = 1, 2, 3일 때,<br>d<sub>1</sub> = 16 &gt; j, d<sub>2</sub>=10 &gt; j, d<sub>3</sub>=5 &gt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 4일 때,<br>d<sub>4</sub> = 1 &lt; j, C[j-d<sub>4</sub>]+1 = C[1-1]+1 = 0+1 = 1 &lt; C[j] = C[1] = ∞<br>if 조건을 만족<br>C[j] = C[j-d<sub>4</sub>] + 1 = C[1] = C[1-1] + 1 = 0 + 1 = 1</p></li></ul></li><li><p>Line 6~9 : j = 2, 3, 4일 때,</p><ul><li>i = 4일 때에만 if 조건을 만족함(j = 1일 때와 동일)<br>C[2] = C[2-1] + 1 = 2, C[3] = 3, C[4] = 4</li></ul><p><img src="/image/algo23-3.png"></p></li><li><p>Line 6~9 : j = 5일 때</p><ul><li><p>i = 1, 2일 때,<br>d<sub>1</sub> = 16 &gt; j, d<sub>2</sub>=10 &gt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 3일 때,<br>d<sub>3</sub> = 5 = j, C[j-d<sub>3</sub>]+1 = C[5-5]+1 = 0+1 = 1 &lt; C[j] = C[5] = ∞<br>if 조건을 만족<br>C[5] = C[j-d<sub>3</sub>]+1 = C[5-5]+1 = 0+1 = 1</p></li><li><p>i = 4일 때,<br>d<sub>4</sub> = 1 = j, C[j-d<sub>4</sub>]+1 = C[5-1]+1 = 4+1 = 5 &gt; C[j] = C[5] = 1<br>if 조건을 만족하지 않음</p></li></ul></li><li><p>Line 6~9 : j = 6, 7, 8, 9일 때</p><ul><li>i = 3일 경우에만 if 조건을 만족함(j = 5일 때와 동일)<br>C[6] = C[6-5] + 1 = 2, C[7] = 3, C[8] = 4, C[9] = 5</li></ul></li></ul><p><img src="/image/algo23-4.png"></p><ul><li><p>Line 6~9 : j = 10일 때</p><ul><li><p>i = 1일 때,<br>d<sub>1</sub> = 16 &gt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 2일 때,<br>d<sub>2</sub> = 10 = j, C[j-d<sub>2</sub>]+1 = C[10-10]+1 = 0+1 = 1 &lt; C[j] = C[10] = ∞<br>if 조건을 만족<br>C[10] = C[j-d<sub>2</sub>]+1 = C[10-10]+1 = 0+1 = 1</p></li><li><p>i = 3,4 일 때,<br>d<sub>i</sub> &lt; j = 10,<br>C[j-d<sub>3</sub>]+1 = C[10-5]+1 = 2 &gt; 1, C[j-d<sub>4</sub>]+1 = C[10-1]+1 = 6 &gt; 1<br>if 조건을 만족하지 않음</p></li></ul></li><li><p>Line 6~9 : j = 11, 12, 13, 14, 15일 때</p><ul><li>i = 2일 경우에만 if 조건을 만족함(j = 10일 때와 동일)<br>C[11] = 2, C[12] = 3, C[13] = 4, C[14] = 5</li></ul></li></ul><p><img src="/image/algo23-5.png"></p><ul><li><p>Line 6~9 : j =15일 때</p><ul><li><p>i = 1일 때,<br>d<sub>1</sub> = 16 &lt; j<br>if 조건을 만족하지 않음</p></li><li><p>i = 2일 때,<br>d<sub>2</sub> = 10 &gt; j, C[j-d<sub>2</sub>]+1 = C[15-10]+1 = 1+1 = 2 &lt; C[j] = C[10] = ∞<br>if 조건을 만족<br>C[15] = C[j-d<sub>2</sub>]+1 = C[15-10]+1 = 2</p></li><li><p>i = 3,4일 때,<br>if 조건을 만족하지 않음</p></li></ul></li></ul><p><img src="/image/algo23-6.png"></p><ul><li><p>Line 6~9 : j = 16일 때</p><ul><li>i = 1일 때,<br>d<sub>1</sub> = 16 = j, C[j-d<sub>1</sub>]+1 = C[16-16]+1 = 0+1 = 1 &lt; C[j] = C[16] = ∞<br>if 조건을 만족<br>C[16] = C[j-d<sub>1</sub>]+1 = C[16-16]+1 = 0+1 = 1</li><li>i = 2, 3, 4일 때,<br>if 조건을 만족하지 않음</li></ul></li><li><p>Line 6~9 : j = 17, 18, 19일 때</p><ul><li>i = 1일 경우에만 if 조건을 만족함(j = 16일 때와 동일)<br>C[17] = 2, C[18] = 3, C[19] = 4</li></ul></li></ul><p><img src="/image/algo23-7.png"></p><ul><li><p>Line 6~9 : j = 20일 때</p><ul><li><p>i = 1<br>if 조건을 만족하지 않음</p></li><li><p>i = 2<br>if 조건을 만족<br>C[20] = C[j-d<sub>2</sub>]+1 = C[10]+1 = 2</p></li><li><p>i = 3<br>C[20] = C[j-d<sub>3</sub>]+1 = C[15]+1 = 3 &gt; 2<br>if 조건을 만족하지 않음</p></li><li><p>i = 4일 때<br>C[20] = C[j-d<sub>4</sub>]+1 = C[19]+1 = 5 &gt; 2<br>if 조건을 만족하지 않음</p></li></ul></li></ul><p><img src="/image/algo23-8.png"></p><ul><li>Line 12 C[20] = 2를 return</li></ul><p><a name="3">3. 시간복잡도</a> </p><p>DPCoinChange 알고리즘의 시간복잡도는 O(nk)이다.<br>왜냐하면 거스름돈 j가 1원부터 n원까지 변하며, 각각의 j에 대하여 최악의 경우 모든 동전을 1번씩 고려하기 때문이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/algo23/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 배낭 문제 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/29/algo22/</link>
      <guid>http://dudri63.github.io/2019/01/29/algo22/</guid>
      <pubDate>Tue, 29 Jan 2019 06:53:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 배낭 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#1&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 배낭 문제&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;배
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 배낭 문제</a><br><a href="#1">2. 알고리즘</a><br><a href="#1">3. 시간 복잡도</a></p><hr><p><a name="1">1. 배낭 문제</a></p><p><strong>배낭 문제(Knapsack)</strong>는 n개의 물건과 각 물건 i의 무게 w<sub>i</sub>와 가치 v<sub>i</sub>가 주어지고, 배낭의 용량이 C일 때, 배낭에 담을 수 있는 물건의 최대 가치를 찾는 문제이다.<br>단, 배나에 담은 물건의 무게의 합이 C를 초과하지 말아야 하고, 각 물건은 1개씩만 있다. 이러한 배낭 문제를 <strong>0-1 배낭 문제</strong>라고 하는데, 이는 각 물건이 담기지 않은 경우 ‘0’, 담긴 경우 ‘1’로 간주하기 때문이다.</p><p>배낭 문제는 제한적입 입력에 대해서 동적 계획 알고리즘으로 풀 수 있다.<br>배낭 문제의 부분 문제를 정의하기 위해서 물건, 물건의 무게, 물건의 가치, 배낭의 용량, 4가지의 요소를 고려할 수 있다.</p><p>배낭 문제의 부분문제의 정의를 위해 물건은 하나씩 차례로 고려하면 되지만, 물건의 무게는 각각 다를 수 있기 때문에, 무게에 대해서는 배낭의 용량 0(kg)으로부터 1(kg)씩 증가하여 입력으로 주어진 용량 C가 될 때까지 변화시켜 가며 물건을 배낭에 담는 것이 가치가 더 커지는지를 결정해야 한다. 따라서 배낭 용량이 0부터 1씩 증가할 경우의 용량을 ‘임시’ 배낭 용량이라고 한다.<br>따라서 배낭 문제의 부분문제를 다음과 같이 정의할 수 있다.</p><p>K[i,w] = 물건 1~i까지만 고려하고, (임시) 배낭 용량이 w일 때의 최대 가치<br>단, i - 1, 2, …, n, w = 1, 2, 3, …, C이다.</p><p>문제의 최적해는 K[n,C]이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 배낭 문제의 동적 계획 알고리즘이다. 2차원 배열 K가 최대 가치를 저장하는 데 사용된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Knapsack</span><br><span class="line">입력: 배낭의 용량 C, n개의 물건, 각 물건 i의 무게 wi, 가치 vi, 단, i = 1,2,3,...,n</span><br><span class="line">출력: K[n,C]</span><br><span class="line">for i = 0 to nK[i,0]=0// 배낭의 용량이 0일 때 총 가치 0으로 초기화</span><br><span class="line">for w = 0 to CK[0,w]=0// 배낭에 아무것도 담기지 않았을 때 총 가치 0으로 초기화</span><br><span class="line">for i = 1 to n &#123;</span><br><span class="line">  for w = 1 to C &#123;</span><br><span class="line">    if (wi &gt; w)// 물건 i의 무게가 임시 배낭의 용량을 초과하면</span><br><span class="line">      K[i,w] = K[i-1,w]</span><br><span class="line">    else// 물건 i를 배낭에 담지 않을 경우와 담을 경우를 고려</span><br><span class="line">      K[i,w] = max&#123;K[i-1,w], K[i-1,w-wi]+vi&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return K[n,C]</span><br></pre></td></tr></table></figure><ul><li>Line 8~9 : 현재 배낭에 담으려고 고려하는 물건 i의 무게 w<sub>i</sub>가 임시 배낭의 무게 w보다 크면 배낭에 담을 수 없다. 따라서 K[i,w]는 물건 (i-1)까지 담은 K[i-1,w]가 된다.</li><li>Line 10~11 : 고려하는 물건 i의 무게 w<sub>i</sub>가 임시 배낭의 무게 w보다 같거나 작으면, 물건 i를 배낭에 담을 수 있다. 그러나 배낭에서 물건 i를 담을 공간을 마련하는 작업을 고려하여야 한다.(배낭의 무게가 부족할 경우)</li></ul><p>즉, 물건 i를 배낭에 담기 위해서는 2가지 경우를 살펴보아야 한다.</p><div align="center"><br><img src="/image/algo22-1.png"><br></div><p>1) 물건 i를 배낭에 담을 수 없는 경우, K[i,w] = K[i-1,w]<br>2) 물건 i를 배낭에 담을 수 있는 경우, K[i,w] = max{K[i-1,w],K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>}, 기존 물건을 빼고 물건 i를 담거나, 물건 i를 담지 않거나, 기존 물건들은 배낭에 냅둔 체 물건 i를 새롭게 담는 경우로서 3가지 경우를 망라한다.</p><p>배낭의 용량이 C=10kg, 각 물건의 무게와 가치가 다음과 같을 때 위 알고리즘이 적용되는 것을 본다.</p><div align="center"><br><img src="/image/algo22-2.png"><br><br></div><ul><li>Line 3~4 : 0번 행과 0번 열의 각 원소를 ‘0’으로 초기화한다.</li></ul><div align="center"><br><img src="/image/algo22-3.png"><br><br></div><ul><li><p>Line 5 : 물건을 하나씩 고려하기 위해 물건 번호 i가 1~4까지 변화<br>Line 6 : 배낭의 임시 용량 w가 1씩 증가하여 마지막엔 10kg이 된다.</p><ul><li><p>i = 1일 때,</p><ul><li>w = 1일 때, 물건 1을 배낭에 담으려고 한다. 그러나 w<sub>1</sub>=5 &gt; w=1, K[1,1] = K[1-1,1] = 0</li><li>w = 2, 3, 4일 때, w<sub>1</sub> &gt; w, K[1,2]=K[1,3]=K[1,4]=0</li><li>w = 5일 때, w<sub>1</sub> = w = 5,<br>K[1,5] = max{K[i-1,w], K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>} = max{K[0,5], K[0,0] + 10} = max{0, 10} = 10</li><li>w = 6, 7, 8, 9, 10일 때, w = 5일 때와 같다. K[1,6] = K[1,7] = K[1,8] = K[1,9] = K[1,10] = 10이다.<br><img src="/image/algo22-4.png"></li></ul></li><li><p>i = 2일 때, 물건 1에 대한 부분문제들의 해는 구한 상태, 이를 이용하여 물건 2를 고려한다.</p><ul><li>w = 1, 2, 3일 때, 물건 2를 배낭에 담으려고 한다. 그러나 w<sub>2</sub>=4 &gt; w, K[2,1] = K[2,2] = K[2,3] = 0</li><li>w = 4일 때, 물건 2를 배낭에 담을 수 있다.<br>K[2,4] = max{K[i-1,w], K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>} = max{K[1,4], K[1,0]+40} = max{0, 40} = 40</li><li>w = 5일 때, 물건 2를 배낭에 담을 수 있다. 그러나 물건 1이 배낭에 담았을 때의 가치와 물건 2를 담았을 때의 가치를 비교하여, 더 큰 가치를 얻는 물건을 배낭에 담는다.<br>K[2,5] = max{K[i-1,w], K[i-1,w-w<sub>i</sub>]+v<sub>i</sub>} = max{K[1,5], K[1,1]+40} = max{10,40} = 40<br>물건 1을 배낭에서 뺀 후, 물건 2를 담는 것의 가치가 더 높으므로 물건 2를 담는다.</li><li>w = 6, 7, 8일 때, 물건 1을 빼내고 물건 2를 담는 것이 더 큰 가치를 얻는다. K[2,6] = K[2,7] = K[2,8] = 40</li><li>w = 9일 때, 물건 2를 배낭에 담을 수 있다.<br>K[2,9] = max{K[i-1,w], K[i-1,w-w<sub>i&lt;/sub]&gt;+v<sub>i</sub>} = max{10,50} = 50<br>배낭에 물건 1,2를 모두 담을 수 있고, 그때 가치가 50이 된다.</sub></li><li>w = 10일 때, w = 9일 때와 마찬가지로 물건 1,2를 모두 담을 수 있고, K[2,10] = 50이 된다.<br><img src="/image/algo22-5.png"></li></ul></li><li><p>i = 3, 4일 때 알고리즘 수행 결과는 다음과 같다.<br><img src="/image/algo22-6.png"></p></li></ul></li><li><p>최적해는 물건 2와 4의 가치의 합인 90이다.</p></li></ul><hr><p><a name="3">3. 시간 복잡도</a></p><p>Knapsack 알고리즘은 line 8에서 무게를 한번 비교한 후 line 9에서 1개의 부분문제의 해를 참조 line 11에서 2개희 해를 참조한 계산이므로 O(1) 시간이 걸린다. 그런데, 부분문제의 수는 원소 수인 n*C이므로, 시간복잡도는 O(1)*n*C = O(nC)이다.</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/algo22/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 편집 거리 문제 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/29/algo21/</link>
      <guid>http://dudri63.github.io/2019/01/29/algo21/</guid>
      <pubDate>Tue, 29 Jan 2019 05:32:05 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 편집 거리 문제&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1.편집 거리 문제&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;문서 편
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 편집 거리 문제</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1.편집 거리 문제</a></p><p>문서 편집기를 사용하는 중에 하나의 문자열을 수정하여 다른 문자열로 변환시키고자 할 때, <strong>삽입(insert)</strong>, <strong>삭제(delete)</strong>, <strong>대체(substitute)</strong> 연산이 사용된다. 예를 들어, A를 B로 변환시키는 데 필요한 최소의 편집 연산 횟수를 <strong>편집 거리(Edit Distance)</strong>라고 한다. 편집 거리 문제는 편집 거리를 찾는 문제이다.</p><p>예를 들어, ‘strong’을 ‘stone’으로 편집하는 과정을 본다.</p><div align="center"><br><img src="/image/algo21-1.png"><br></div><p>‘s’, ‘t’는 그대로 사용, ‘o’를 삽입, ‘r’, ‘o’를 삭제, ‘n’을 그대로 사용, ‘g’를 ‘e’로 대체한다.<br>이 경우, 총 4회의 편집 연산이 수행되었다.(삽입 1회, 삭제 2회, 대체 1회)</p><div align="center"><br><img src="/image/algo21-2.png"><br></div><p>반면에 위 경우, ‘r’ 삭제, ‘g’를 ‘e’로 대체, 단 2회의 편집 연산을 수행하였다.</p><p>이처럼 문자를 편집할 때, 어떤 연산을 어느 문자에 수행하느냐에 따라서 편집 연산 횟수가 달라진다.</p><div align="center"><br><img src="/image/algo21-3.png"><br></div><p>부분 문제를 정의하기 위하여 스트링 S, T를 위와 같이 지정하고, 길이를 각각 m, n이라고 한다. 그리고 각각의 문자를 s<sub>i</sub>,t<sub>i</sub>이라 한다.</p><p>E[i,j]는 S의 접두부의 i개 문자를 T의 접두부 j개 문자로 변환시키는 데 필요한 최소 편집 연산 횟수, 즉 편집 거리이다.<br>예를 들어, ‘strong’의 접두부는 ‘stro’이므로 i = 4, ‘stone’의 접두부는 ‘sto’이므로 j = 3인데, 각 문자열의 접두부를 바꾸기 위한 편집 거리를 찾는 문제는 E[i,j] = E[4,3]이다.<br>E[4,3]을 점진적으로 E[6,5]를 해결하면 문제의 해를 찾을 수 있다.</p><div align="center"><br><img src="/image/algo21-4.png"><br></div><ul><li>s<sub>1</sub> -&gt; t<sub>1</sub> 부분문제 : E[1,1] = 0</li><li>S<sub>1</sub> -&gt; t<sub>1</sub>t<sub>2</sub> 부분문제 : E[1,2] = 1, ‘s’를 ‘st’로 편집, ‘t’ 삽입 1회 연산</li><li>s<sub>1</sub>s<sub>2</sub> -&gt; t<sub>1</sub> 부분문제 : E[2,1] = 1, ‘st’를 ‘s’로 편집, ‘t’ 삭제 1회 연산</li><li>s<sub>1</sub>s<sub>2</sub> -&gt; t<sub>1</sub>t<sub>2</sub> 부분문제 : E[2,2] = 0</li></ul><p>이 때, 부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub> -&gt; t<sub>1</sub>t<sub>2</sub>t<sub>3</sub> : E[4,3], ‘stro’를 ‘sto’로 편집은 어떻게 계산하는가?</p><ul><li>E[4,2] (부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub>s<sub>4</sub> -&gt; t<sub>1</sub>t<sub>2</sub>)를 알면, t<sub>3</sub> = ‘o’를 삽입하면 된다. 그러므로 E[4,3] = E[4,2] + 1이다.</li><li>E[3,3] (부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub> -&gt; t<sub>1</sub>t<sub>2</sub>t<sub>3</sub>)를 알면, s<sub>4</sub> = ‘o’를 삭제하면 된다. 그러므로 E[4,3] = E[3,3] + 1이다.</li><li>E[3,2] (부분문제 s<sub>1</sub>s<sub>2</sub>s<sub>3</sub> -&gt; t<sub>1</sub>t<sub>2</sub>)를 알면, s<sub>4</sub> -&gt; t<sub>3</sub>로 편집하는데 필요한 연산을 계산하면 도니다. 그러나 이 경우, 2개의 문자가 ‘o’로 같으므로 편집할 필요가 없다. 그러므로 E[4,3] = E[3,2]이다.</li></ul><div align="center"><br><img src="/image/algo21-5.png"><br></div><p>따라서 E[4,3]의 편집 거리를 계산하려면 앞의 3가지 부분문제의 해, 즉, E[4,2], E[3,3], E[3,2]의 편집 거리를 알아야 한다. 그런데 이 경우, (2+1), (1+1), 1 중에서 최솟값인 1이 E[4,3]의 편집 거리가 된다.</p><p>일반적으로 E[i-1,j], E[i,j-1], E[i-1,j-1]의 해가 미리 계산되어 있으면 E[i,j]를 계산할 수 있다. 그러므로 편집 거리 문제의 부분문제 간의 함축적인 순서는 다음과 같다.</p><div align="center"><br><img src="/image/algo21-6.png"><br></div><p>위 E[4,3] 예제와 비교하면, 위 그림이 의미하는 바는 금방 파악된다.<br>세 가지 경우 중 가장 적은 값을 E[i,j]의 해로서 선택한다.<br>E[i,j] = min{E[i,j-1]+1, E[i-1,j]+1, E[i-1,j-1]+a} 단, if s<sub>i</sub>=t<sub>j</sub> a=0, else a=1</p><p>위 식을 위해, E[0,0], E[1,0], … , E[m,0]과 E[0,1], E[0,2], … , E[0,n]을 다음과 같이 초기화한다.</p><div align="center"><br><img src="/image/algo21-7.png"><br>ε = (공 문자열)<br></div><br>공 문자열에서 문자열이 하나씩 추가되는 것이므로 삽입 연산에 의해 1씩 증가하는 것은 자명한 사실이다.<br><br><strong><strong><em>**</em></strong></strong><br><br><a name="2">2. 알고리즘</a><br><br>다음은 편집 거리 문제를 위한 동적 계획 알고리즘이다. 알고리즘에서 2차원 배열 E는 편집 거리를 저장하는 데 사용된다.<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EditDistance</span><br><span class="line">입력: 스트링 S,T, 단, S와 T의 길이는 각각 m,n이다.</span><br><span class="line">출력: S를 T로 변환하는 편집 거리, E[m,n]</span><br><span class="line">for i=0 to m E[i,0]=i// 0번 열의 초기화</span><br><span class="line">for j=0 to n E[0,j]=j// 0번 행의 초기화</span><br><span class="line">for i=1 to m</span><br><span class="line">  for j=1 to n</span><br><span class="line">    E[i,j] = min&#123;E[i,jj-1]+1, E[i-1,j]+1, E[i-1,j-1]+a&#125;</span><br><span class="line">return E[m,n]</span><br></pre></td></tr></table></figure><br><br><div align="center"><br><img src="/image/algo21-8.png"><br></div><p>위 그림은 EditDistance 알고리즘이 ‘strong’을 ‘stone’으로 바꾸는 데 필요한 거리를 계산한 결과인 배열 E이다.<br>a = 0 or a = 1인 경우에 유의하여 9시, 11시, 12시 방향에서 가장 작은 값을 푸른색 배경의 셀에 넣으면서 나아가면 된다.</p><hr><p><a name="3">3. 시간 복잡도</a></p><p>EditDistance 알고리즘의 시간복잡도는 O(mn)이다. 총 부분문제의 수가 m*n이고, 각 부분문제를 해결하기 위해서 주위의 3개의 부분문제들의 해를 참조한 후 최솟값을 찾는 것이므로 O(1) 시간이 걸리기 때문이다. </p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/algo21/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 함수, 모듈</title>
      <link>http://dudri63.github.io/2019/01/29/python7/</link>
      <guid>http://dudri63.github.io/2019/01/29/python7/</guid>
      <pubDate>Mon, 28 Jan 2019 15:08:23 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 함수&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 모듈&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 함수&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;함수란 믹서기와 같다. 입력값을 가지고 어떤 일을 수핸한 다음에 그 결과물을 내놓는 
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 함수</a><br><a href="#2">2. 모듈</a></p><hr><p><a name="1">1. 함수</a></p><p>함수란 믹서기와 같다. 입력값을 가지고 어떤 일을 수핸한 다음에 그 결과물을 내놓는 역할을 한다.<br>예를 들어 y = 4x + 5도 함수이다.</p><p>프로그래밍을 하다 보면 똑같은 내용을 반복해서 작성할 수 있다. 이 때, 함수를 사용하면 유용하다.<br>또한, 프로그램을 함수화하면 프로그램의 흐름을 일목요연하게 볼 수 있다. 이 경우, 에러가 발생 시에도 어디서 발생하였는지 금방 알 수 있다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def a3():# 함수 a3() 정의</span><br><span class="line">    print(&apos;aaa&apos;)</span><br><span class="line">a3()</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-1.png"><br></div><p>def : 함수를 정의한다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def a3():</span><br><span class="line">    return &apos;aaa&apos;</span><br><span class="line">print(a3())</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-2.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def a(num):</span><br><span class="line">    return &apos;a&apos;*num</span><br><span class="line">print(a(3))</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def make_string(str, num):</span><br><span class="line">    return str*num</span><br><span class="line">print(make_string(&apos;b&apos;, 3))</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-4.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">def login(_id):</span><br><span class="line">    members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]</span><br><span class="line">    for member in members:</span><br><span class="line">        if member == _id:</span><br><span class="line">            return True</span><br><span class="line">    return False</span><br><span class="line">if login(input_id):</span><br><span class="line">    print(&apos;Hello, &apos;+input_id)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;Who are you?&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-5.png"><br></div><hr><p><a name="2">2. 모듈</a></p><p>모듈이란 함수나 변수 또는 클래스들을 모아놓은 파일이다.<br>또한, 모듈은 다른 파이썬 프로그램에서 불러와 사용할 수 있게끔 만들어진 파이썬 파일이라고도 할 수 있다.<br>다른 사람들이 이미 만들어놓은 모듈을 사용할 수도 있고, 직접 만들어서 사용할 수도 있다.</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line">print(math.ceil(2.9))</span><br><span class="line">print(math.floor(2.9))</span><br><span class="line">print(math.sqrt(16))</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py7-6.png"><br></div><p>math 모듈은 여러가지 수학 관련 함수를 담고 있는 모듈이다.</p><p>ceil(x) : x를 가까운 정수까지 반올림한 뒤 반환<br>floor(x) : x를 가까운 정수까지 버림한 뒤 반환<br>sqrt(x) : x의 제곱근을 반환</p><hr><p>egoing.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def a():</span><br><span class="line">    return &apos;a&apos;</span><br><span class="line">def b():</span><br><span class="line">    return &apos;b&apos;</span><br><span class="line">def c():</span><br><span class="line">    return &apos;c&apos;</span><br></pre></td></tr></table></figure></p><p>k8805.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def a():</span><br><span class="line">    return &apos;B&apos;</span><br></pre></td></tr></table></figure></p><p>6.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from egoing import a as z</span><br><span class="line">import k8805 as k</span><br><span class="line">print(z())</span><br><span class="line">print(k.a())</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/py7-7.png"><br></div><p>egoing 모듈로부터 모듈함수를 import할 수 있다. 이 경우, 모듈이름을 붙이지 않고 바로 해당 모듈의 함수를 사용할 수 있다.<br>또한, 모듈을 import할 경우, 해당 모듈 함수를 사용하기 위해서는 모듈이름을 붙여야 한다.</p><hr><p>auth.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def login(_id):</span><br><span class="line">    members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]</span><br><span class="line">    for member in members:</span><br><span class="line">        if member == _id:</span><br><span class="line">            return True</span><br><span class="line">    return False</span><br></pre></td></tr></table></figure></p><p>6.py<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import auth</span><br><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">if auth.login(input_id):</span><br><span class="line">    print(&apos;Hello, &apos;+input_id)</span><br><span class="line">else:</span><br><span class="line">    print(&apos;Who are you?&apos;)</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/py7-8.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>‘04-1 함수’, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/24#_1" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/24#_1</a></li><li>‘05-5 내장 함수’, 점프 투 파이썬, 2019. 1. 29, <a href="https://wikidocs.net/32#len" rel="external nofollow noopener noreferrer" target="_blank">https://wikidocs.net/32#len</a></li><li>‘[파이썬]공통함수,수학(math) 함수’, andamiro25, 2019. 1. 29, <a href="https://andamiro25.tistory.com/" rel="external nofollow noopener noreferrer" target="_blank">https://andamiro25.tistory.com/</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/29/python7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Python] 반복문</title>
      <link>http://dudri63.github.io/2019/01/28/python6/</link>
      <guid>http://dudri63.github.io/2019/01/28/python6/</guid>
      <pubDate>Mon, 28 Jan 2019 14:46:58 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 반복문, while&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 컨테이너와 반복문&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. for&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a name=&quot;1&quot;&gt;1. 반복문, while&lt;/a&gt;&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 반복문, while</a><br><a href="#2">2. 컨테이너와 반복문</a><br><a href="#3">3. for</a></p><hr><p><a name="1">1. 반복문, while</a></p><p>1.1 반복문이 없다면</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;Hello world 0&quot;)</span><br><span class="line">print(&quot;Hello world 9&quot;)</span><br><span class="line">print(&quot;Hello world 18&quot;)</span><br><span class="line">print(&quot;Hello world 27&quot;)</span><br><span class="line">print(&quot;Hello world 36&quot;)</span><br><span class="line">print(&quot;Hello world 45&quot;)</span><br><span class="line">print(&quot;Hello world 54&quot;)</span><br><span class="line">print(&quot;Hello world 63&quot;)</span><br><span class="line">print(&quot;Hello world 72&quot;)</span><br><span class="line">print(&quot;Hello world 81&quot;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-1.png"><br></div><p>1.2 while</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while False:</span><br><span class="line">    print(&apos;Hello world&apos;)</span><br><span class="line">print(&apos;After while&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-2.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 3:</span><br><span class="line">    print(&apos;Hello world&apos;)</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-3.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    print(&apos;print(&quot;Hello world &apos;+str(i*9)+&apos;&quot;)&apos;)</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-4.png"><br></div><p>str() : 숫자를 문자열로 변환하는 함수</p><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    if i == 4:</span><br><span class="line">        print(i)</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-5.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">while i &lt; 10:</span><br><span class="line">    if i == 4:</span><br><span class="line">        break</span><br><span class="line">    print(i)</span><br><span class="line">    i = i + 1</span><br><span class="line">print(&apos;after while&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-6.png"><br></div><hr><p><a name="2">2. 컨테이너와 반복문</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]</span><br><span class="line">i = 0</span><br><span class="line">while i &lt; len(members):</span><br><span class="line">    print(members[i])</span><br><span class="line">    i = i + 1</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-7.png"><br></div><hr><p><a name="3">3. for</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">members = [&apos;egoing&apos;, &apos;leezche&apos;, &apos;graphittie&apos;]</span><br><span class="line">for member in members:</span><br><span class="line">    print(member)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-8.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for item in range(5, 11):</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-9.png"><br></div><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input_id = input(&quot;아이디를 입력해주세요.\n&quot;)</span><br><span class="line">members = [&apos;egoing&apos;, &apos;k8805&apos;, &apos;leezche&apos;]</span><br><span class="line">for member in members:</span><br><span class="line">    if member == input_id:</span><br><span class="line">        print(&apos;Hello!, &apos;+member)</span><br><span class="line">        import sys</span><br><span class="line">        sys.exit()</span><br><span class="line">print(&apos;Who are you?&apos;)</span><br></pre></td></tr></table></figure><div align="center"><br><img src="/image/py6-10.png"><br></div><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>“Python &amp; Ruby”, 생활코딩, 2019. 1. 28, <a href="https://opentutorials.org/course/1750/9621" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9621</a>, <a href="https://opentutorials.org/course/1750/9874" rel="external nofollow noopener noreferrer" target="_blank">https://opentutorials.org/course/1750/9874</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/28/python6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Algorithm] 연속 행렬 곱셈 (동적계획)</title>
      <link>http://dudri63.github.io/2019/01/28/algo20/</link>
      <guid>http://dudri63.github.io/2019/01/28/algo20/</guid>
      <pubDate>Mon, 28 Jan 2019 07:59:17 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;#1&quot;&gt;1. 연속 행렬 곱셉 (Chained Matrix Multiplications)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#2&quot;&gt;2. 알고리즘&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;#3&quot;&gt;3. 시간 복잡도&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a na
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="#1">1. 연속 행렬 곱셉 (Chained Matrix Multiplications)</a><br><a href="#2">2. 알고리즘</a><br><a href="#3">3. 시간 복잡도</a></p><hr><p><a name="1">1. 연속 행렬 곱셉 (Chained Matrix Multiplications)</a></p><p><strong>연속 행렬 곱셉 (Chained Matrix Multiplications)</strong> 문제는 연속된 행렬들의 곱셉에 필요한 원소 간의 최소 곱셉 횟수를 찾는 문제이다.</p><div align="center"><br><img src="/image/algo20-1.png"><br></div><p>예를 들어, 위와 같은 두 개의 행렬을 곱하는 경우, 10*20 행렬 A와 20*5 행렬 B를 곱하는데 원소간의 곱셈 횟수는 10*20*5 = 1000이다. 그리고 두 행렬을 곱한 결과 행렬 C는 10*5이다.</p><div align="center"><br><img src="/image/algo20-2.png"><br></div><p>또 다른 예시로, 세 개의 행렬을 곱하는 경우를 고려한다.<br>행렬의 곱셈에서는 결합법칙이 허용됨을 기억한다. A*B*C = (A*B)*C = A*(B*C)</p><div align="center"><br><img src="/image/algo20-3.png"><br></div><p>A*B를 먼저 계산한 후에 그 결과 행렬과 행렬 C를 곱하는 경우, 곱셈 횟수는 다음과 같다.<br>A*B = 10*20*5 = 1000, AB*C = 10*5*15 = 750<br>총 1000 + 750 = 1750회의 원소의 곱셈이 필요하다.</p><div align="center"><br><img src="/image/algo20-4.png"><br></div><p>B*C를 먼저 계산한 후에 그 결과 행렬과 행렬 A를 곱하는 경우, 곱셈 횟수는 다음과 같다.<br>B*C = 20*5*15 = 1500, A*BC = 10*20*15 = 3000<br>총 1500 + 3000 = 4500회의 원소의 곱셈이 필요하다.</p><p>동일한 결과를 얻음에도 불구하고 원소 간의 곱셈 횟수가 차이가 난다. 따라서 연속 행렬을 곱하는 데 필요한 원소 간의 곱셈 횟수를 최소화시키기 위한 적절한 곱셈 순서를 찾아야 한다.</p><p>연속 행렬 곱셈 문제는 대표적인 동적 계획 알고리즘 문제이다.<br>단, 이웃하는 행렬끼리 먼저 곱해야 하는 특징 때문에 비교적 간단하게 해결할 수 있다.</p><p>행렬 A, B, C, D, E를 곱하는데 다음과 같은 부분 문제가 만들어진다.</p><div align="center"><br><img src="/image/algo20-5.png"><br></div><p><strong>부분 문제들이 겹쳐있다는 것</strong>이 중요하다.</p><div align="center"><br><img src="/image/algo20-6.png"><br></div><p>크기가 3인 부분문제가 3인 경우도 서로 이웃하는 부분문제들끼리 겹쳐 있음을 알 수 있다. 마지막 부분문제의 갯수가 1개인 경우는 주어진 문제로서 입력이다.</p><hr><p><a name="2">2. 알고리즘</a></p><p>다음은 연속 행렬 곱셈을 위한 동적 계획 알고리즘이다.<br>단, 원소 간의 최소 곱셈 횟수를 C[i,j]에 저장한다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">MatrixChain</span><br><span class="line">입력: 연속된 행렬 A1\*A2\*...\*An,</span><br><span class="line">출력: 입력의 행렬 곱셈에 필요한 원소 간의 최소 곱셈 횟수</span><br><span class="line">for i = 1 to n</span><br><span class="line">  C[i,i] = 0</span><br><span class="line">for L = 1 to n-1 &#123;//L은 부분문제의 크기를 조절하는 인덱스</span><br><span class="line">  for i = 1 to n-L &#123;</span><br><span class="line">    j = i + L</span><br><span class="line">    C[i,j] = ∞</span><br><span class="line">    for k = i to j-1 &#123;</span><br><span class="line">      temp = C[i,k] + C[k+1,j] + d(i-1)dkdj</span><br><span class="line">      if (temp &lt; C[i,j])</span><br><span class="line">        C[i,j] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">return C[1,n]</span><br></pre></td></tr></table></figure></p><div align="center"><br><img src="/image/algo20-7.png"><br></div><p>A1 : 10*20, A2 : 20*5, A3 : 5*15, A4 : 15*30일 때, MatrixChain 알고리즘 수행 과정은 다음과 같다.</p><ul><li>Line 4~5 : C[1,1] = C[2,2] = C[3,3], C[4,4] = 0으로 초기화</li></ul><div align="center"><br><img src="/image/algo20-8.png"><br><br></div><ul><li>Line 6 : L이 1부터 n-1 = 4-1 = 3까지 변하고, 각각의 L값에 대해, i가 변화, C[i,j]를 계산</li><li>L = 1일 때, i는 1부터 n-L = 4-1 = 3까지 변한다.<ul><li>i = 1이면, j = i+L = 1+1 = 2, C[1,2] = ∞,<br>temp = C[1,1] + C[2,2] + d<sub>0</sub>d<sub>1</sub>d<sub>2</sub> = 0 + 0 + (10*20*5) = 1000<br>temp = 1000 &lt; C[1,2] = ∞, C[1,2] = 1000</li><li>i = 2이면, j = i+L = 2+1 = 3, C[2,3] = ∞<br>temp = C[2,2] + C[3,3] + d<sub>1</sub>d<sub>2</sub>d<sub>3</sub> = 0 + 0 + (20*5*15) = 1500<br>temp = 1500 &lt; C[2,3] = ∞, C[2,3] = 1500</li><li>i = 3이면, j = i+L = 3+1 = 4, C[3,4] = ∞<br>temp = C[3,3] + C[4,4] + d<sub>2</sub>d<sub>3</sub>d<sub>4</sub> = 0 + 0 + (5*15*30) = 2250<br>temp = 2250 &lt; C[3,4] = ∞, C[3,4] = 2250</li></ul></li></ul><div align="center"><br><img src="/image/algo20-9.png"><br>A1 * A2 = 1000, A2 * A3 = 1500, A3 * A4 = 2250<br><br></div><ul><li><p>L = 2일 때, i는 1부터 n-L = 4-2 = 2까지 변한다.</p><ul><li><p>i = 1이면, j = i+L = 1+2 = 3, C[1,3] = ∞</p><ul><li><p>k = 1일 때, temp = C[1,1] + C[2,3] + d<sub>0</sub>d<sub>1</sub>d<sub>3</sub> = 0 + 1500 + (10*20*15) = 4500<br>temp = 4500 &lt; C[1,3] = ∞, C[1,3] = 4500<br><img src="/image/algo20-10.png"><br>A2*A3 = 1500, A1*A2A3 = 3000 + 1500</p></li><li><p>k = 2일 때, temp = C[1,2] + C[3,3] + d<sub>0</sub>d<sub>2</sub>d<sub>3</sub> = 1000 + 0 + (10*5*15) = 1750<br>temp = 1750 &lt; C[1,3] = 4500, C[1,3] 1750<br><img src="/image/algo20-11.png"><br>A1*A2 = 1000, A1A2*A3 = 1000 + 750</p></li></ul></li><li><p>i =2이면, j = i+L = 2+2 = 4, C[2,4] = ∞</p><ul><li><p>k = 2일 때, temp = C[2,2] + C[3,4] + d<sub>1</sub>d<sub>2</sub>d<sub>4</sub> = 0 + 2250 + (20*5*30) = 5250<br>temp = 5250 &lt; C[2,4] = ∞, C[2,4] = 5250<br><img src="/image/algo20-12.png"><br>A3*A4 = 2250, A2*A3A4 = 3000 + 2250</p></li><li><p>k = 3일 때, temp = C[2,3] + C[4,4] + d<sub>1</sub>d<sub>3</sub>d<sub>4</sub> = 1500 + 0 + (20*15*30) = 10500<br>temp = 10500 &gt; C[2,4] = 2250, C[2,4] = 5250<br><img src="/image/algo20-13.png"><br>A2*A3 = 1500, A2A3*A4 = 9000 + 1500</p></li></ul></li></ul></li></ul><div align="center"><br><img src="/image/algo20-14.png"><br><br></div><ul><li><p>L = 3일 때, i는 1부터 n-L = 4-3 = 1까지 변한다.(i=1일때만 수행)</p><ul><li><p>i = 1이면, j = i+L = 1+3 = 4, C[1,4] = ∞</p><ul><li><p>k = 1일 때, temp = C[1,1] + C[2,4] = d<sub>0</sub>d<sub>1</sub>d<sub>4</sub> = 0 + 5250 + (10*20*30) = 11250<br>temp = 11250 &lt; C[1,4] = ∞, C[1,4] = 11250<br><img src="/image/algo20-15.png"><br>A2*A3*A4 = 5250, A1*A2A3A4 = 6000</p></li><li><p>k = 2일 때, temp = C[1,2] + C[3,4] = d<sub>0</sub>d<sub>2</sub>d<sub>4</sub> = 1000 + 2250 + (10*5*30) = 4750<br>temp = 4750 &lt; C[1,4] = ∞, C[1,4] = 4750<br><img src="/image/algo20-16.png"><br>A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1000 + 1500 + 2250 = 4750</p></li><li><p>k = 3일 때, temp = C[1,3] + C[4,4] = d<sub>0</sub>d<sub>3</sub>d<sub>4</sub> = 1750 + 0 + (10*15*30) = 6250<br>temp = 6250 &gt; C[1,4] = 4750, C[1,4] = 4750<br><img src="/image/algo20-17.png"><br>A1*A2 = 1000, A3*A4 = 2250, (A1A2)*(A3A4) = 1750 + 4500 = 6250</p></li></ul></li></ul></li></ul><div align="center"><br><img src="/image/algo20-18.png"><br><br></div><ul><li>C[1,4]= 4750을 반환</li></ul><hr><p><a name="3">3. 시간복잡도 </a></p><p>3중 for문 -&gt; O(n<sup>3</sup>)</p><hr><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>양성봉, 『알기 쉬운 알고리즘』. 파주: (주)생능출판사, 2013</li><li>“5장동적계획알고리즘-0”, 영산대학교 교수블로그, 2019. 1. 26, <a href="https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=" rel="external nofollow noopener noreferrer" target="_blank">https://prof.ysu.ac.kr/down.asp?file=5%C0%E5%B5%BF%C0%FB%B0%E8%C8%B9%BE%CB%B0%ED%B8%AE%C1%F2.pptx&amp;kid=</a></li></ul>]]></content:encoded>
      
      <comments>http://dudri63.github.io/2019/01/28/algo20/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
